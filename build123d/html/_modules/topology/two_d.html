

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>topology.two_d &mdash; build123d 0.9.2.dev40+gb1f0eed documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/sphinx_rtd_theme.css?v=3234e928" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c97902b4"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/js/hoverxref.js"></script>
      <script src="../../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../../_static/js/micromodal.min.js"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            build123d
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_builder.html">Key Concepts (builder mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_algebra.html">Key Concepts (algebra mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../moving_objects.html">Moving Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../OpenSCAD.html">Transitioning from OpenSCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introductory_examples.html">Introductory Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../selectors_operators.html">Selectors and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builders.html">Builders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../assemblies.html">Assemblies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips.html">Tips, Best Practices and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../import_export.html">Import/Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cheat_sheet.html">Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../external.html">External Tools and Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builder_api_reference.html">Builder Common API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../direct_api_reference.html">Direct API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">build123d</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">topology.two_d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for topology.two_d</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">build123d topology</span>

<span class="sd">name: two_d.py</span>
<span class="sd">by:   Gumyr</span>
<span class="sd">date: January 07, 2025</span>

<span class="sd">desc:</span>

<span class="sd">This module provides classes and methods for two-dimensional geometric entities in the build123d CAD</span>
<span class="sd">library, focusing on the `Face` and `Shell` classes. These entities form the building blocks for</span>
<span class="sd">creating and manipulating complex 2D surfaces and 3D shells, enabling precise modeling for CAD</span>
<span class="sd">applications.</span>

<span class="sd">Key Features:</span>
<span class="sd">- **Mixin2D**:</span>
<span class="sd">  - Adds shared functionality to `Face` and `Shell` classes, such as splitting, extrusion, and</span>
<span class="sd">    projection operations.</span>

<span class="sd">- **Face Class**:</span>
<span class="sd">  - Represents a 3D bounded surface with advanced features like trimming, offsetting, and Boolean</span>
<span class="sd">    operations.</span>
<span class="sd">  - Provides utilities for creating faces from wires, arrays of points, BÃ©zier surfaces, and ruled</span>
<span class="sd">    surfaces.</span>
<span class="sd">  - Enables geometry queries like normal vectors, surface centers, and planarity checks.</span>

<span class="sd">- **Shell Class**:</span>
<span class="sd">  - Represents a collection of connected faces forming a closed surface.</span>
<span class="sd">  - Supports operations like lofting and sweeping profiles along paths.</span>

<span class="sd">- **Utilities**:</span>
<span class="sd">  - Includes methods for sorting wires into buildable faces and creating holes within faces</span>
<span class="sd">    efficiently.</span>

<span class="sd">The module integrates deeply with OpenCascade to leverage its powerful CAD kernel, offering robust</span>
<span class="sd">and extensible tools for surface and shell creation, manipulation, and analysis.</span>

<span class="sd">license:</span>

<span class="sd">    Copyright 2025 Gumyr</span>

<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>

<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">OCP.TopAbs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRep</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRep_Tool</span><span class="p">,</span> <span class="n">BRep_Builder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAdaptor</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepAdaptor_Surface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAlgo</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepAlgo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAlgoAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepAlgoAPI_Common</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepBuilderAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">,</span> <span class="n">BRepBuilderAPI_MakeShell</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepClass3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepClass3d_SolidClassifier</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepFill</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepFill</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepFilletAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepFilletAPI_MakeFillet2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepGProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepGProp</span><span class="p">,</span> <span class="n">BRepGProp_Face</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepIntCurveSurface</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepIntCurveSurface_Inter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepOffsetAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepOffsetAPI_MakeFilling</span><span class="p">,</span> <span class="n">BRepOffsetAPI_MakePipeShell</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepTools</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepTools</span><span class="p">,</span> <span class="n">BRepTools_ReShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">GProp_GProps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Geom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geom_BezierSurface</span><span class="p">,</span> <span class="n">Geom_Surface</span><span class="p">,</span> <span class="n">Geom_RectangularTrimmedSurface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomAPI_PointsToBSplineSurface</span><span class="p">,</span> <span class="n">GeomAPI_ProjectPointOnSurf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAbs</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomAbs_C0</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Precision</span><span class="w"> </span><span class="kn">import</span> <span class="n">Precision</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeFix</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeFix_Solid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Standard</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Standard_Failure</span><span class="p">,</span>
    <span class="n">Standard_NoSuchObject</span><span class="p">,</span>
    <span class="n">Standard_ConstructionError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.StdFail</span><span class="w"> </span><span class="kn">import</span> <span class="n">StdFail_NotDone</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TColStd</span><span class="w"> </span><span class="kn">import</span> <span class="n">TColStd_HArray2OfReal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TColgp</span><span class="w"> </span><span class="kn">import</span> <span class="n">TColgp_HArray2OfPnt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopExp</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopExp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopTools</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopoDS</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopoDS</span><span class="p">,</span> <span class="n">TopoDS_Face</span><span class="p">,</span> <span class="n">TopoDS_Shape</span><span class="p">,</span> <span class="n">TopoDS_Shell</span><span class="p">,</span> <span class="n">TopoDS_Solid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.gce</span><span class="w"> </span><span class="kn">import</span> <span class="n">gce_MakeLin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.gp</span><span class="w"> </span><span class="kn">import</span> <span class="n">gp_Pnt</span><span class="p">,</span> <span class="n">gp_Vec</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.build_enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">CenterOf</span><span class="p">,</span> <span class="n">GeomType</span><span class="p">,</span> <span class="n">Keep</span><span class="p">,</span> <span class="n">SortBy</span><span class="p">,</span> <span class="n">Transition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TOLERANCE</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">Color</span><span class="p">,</span>
    <span class="n">Location</span><span class="p">,</span>
    <span class="n">OrientedBoundBox</span><span class="p">,</span>
    <span class="n">Plane</span><span class="p">,</span>
    <span class="n">Vector</span><span class="p">,</span>
    <span class="n">VectorLike</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.one_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mixin1D</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.shape_core</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">ShapeList</span><span class="p">,</span>
    <span class="n">SkipClean</span><span class="p">,</span>
    <span class="n">downcast</span><span class="p">,</span>
    <span class="n">get_top_level_topods_shapes</span><span class="p">,</span>
    <span class="n">_sew_topods_faces</span><span class="p">,</span>
    <span class="n">shapetype</span><span class="p">,</span>
    <span class="n">_topods_entities</span><span class="p">,</span>
    <span class="n">_topods_face_normal_at</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_extrude_topods_shape</span><span class="p">,</span>
    <span class="n">find_max_dimension</span><span class="p">,</span>
    <span class="n">_make_loft</span><span class="p">,</span>
    <span class="n">_make_topods_face_from_wires</span><span class="p">,</span>
    <span class="n">_topods_bool_op</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.zero_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Vertex</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.three_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Solid</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.composite</span><span class="w"> </span><span class="kn">import</span> <span class="n">Compound</span><span class="p">,</span> <span class="n">Curve</span><span class="p">,</span> <span class="n">Sketch</span><span class="p">,</span> <span class="n">Part</span>  <span class="c1"># pylint: disable=R0801</span>


<div class="viewcode-block" id="Mixin2D">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Mixin2D</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Additional methods to add to Face and Shell class&quot;&quot;&quot;</span>

    <span class="n">project_to_viewport</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">project_to_viewport</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">split</span>

    <span class="n">vertices</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">vertex</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">edges</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">edge</span>
    <span class="n">wires</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">wires</span>
    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension of Faces and Shells&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Mixin2D.cast">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.cast">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span><span class="p">:</span>
        <span class="s2">&quot;Returns the right type of wrapper, given a OCCT object&quot;</span>

        <span class="c1"># define the shape lookup table for casting</span>
        <span class="n">constructor_lut</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">:</span> <span class="n">Face</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SHELL</span><span class="p">:</span> <span class="n">Shell</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">shape_type</span> <span class="o">=</span> <span class="n">shapetype</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># NB downcast is needed to handle TopoDS_Shape types</span>
        <span class="k">return</span> <span class="n">constructor_lut</span><span class="p">[</span><span class="n">shape_type</span><span class="p">](</span><span class="n">downcast</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin2D.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unused - only here because Mixin1D is a subclass of Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse normal operator -&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid Shape&quot;</span><span class="p">)</span>
        <span class="n">new_surface</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_surface</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Complemented</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">new_surface</span>

<div class="viewcode-block" id="Mixin2D.face">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.face">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">face</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Face&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_single_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin2D.faces">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;faces - all the faces in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin2D.find_intersection_points">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.find_intersection_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_intersection_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">TOLERANCE</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Vector</span><span class="p">,</span> <span class="n">Vector</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find point and normal at intersection</span>

<span class="sd">        Return both the point(s) and normal(s) of the intersection of the axis and the shape</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Axis): axis defining the intersection line</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[Vector, Vector]]: Point and normal of intersection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">intersection_line</span> <span class="o">=</span> <span class="n">gce_MakeLin</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
        <span class="n">intersect_maker</span> <span class="o">=</span> <span class="n">BRepIntCurveSurface_Inter</span><span class="p">()</span>
        <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">intersection_line</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">intersect_maker</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">inter_pt</span> <span class="o">=</span> <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Pnt</span><span class="p">()</span>
            <span class="c1"># Calculate distance along axis</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">inter_pt</span><span class="p">))</span><span class="o">.</span><span class="n">Z</span>
            <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Face</span><span class="p">(),</span>  <span class="c1"># TopoDS_Face</span>
                    <span class="n">Vector</span><span class="p">(</span><span class="n">inter_pt</span><span class="p">),</span>
                    <span class="n">distance</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

        <span class="n">intersections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">intersecting_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">]</span>
        <span class="n">intersecting_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">]</span>
        <span class="n">intersecting_normals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_topods_face_normal_at</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">intersecting_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intersecting_faces</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pnt</span><span class="p">,</span> <span class="n">normal</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">intersecting_points</span><span class="p">,</span> <span class="n">intersecting_normals</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pnt</span><span class="p">,</span> <span class="n">normal</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Mixin2D.offset">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of self moved along the normal by amount&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">moved</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span> <span class="o">*</span> <span class="n">amount</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin2D.shell">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.shell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Shell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_single_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin2D.shells">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin2D.shells">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Shell</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;shells - all the shells in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Face">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Face</span><span class="p">(</span><span class="n">Mixin2D</span><span class="p">,</span> <span class="n">Shape</span><span class="p">[</span><span class="n">TopoDS_Face</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Face in build123d represents a 3D bounded surface within the topological data</span>
<span class="sd">    structure. It encapsulates geometric information, defining a face of a 3D shape.</span>
<span class="sd">    These faces are integral components of complex structures, such as solids and</span>
<span class="sd">    shells. Face enables precise modeling and manipulation of surfaces, supporting</span>
<span class="sd">    operations like trimming, filleting, and Boolean operations.&quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-public-methods</span>

    <span class="n">order</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="c1"># ---- Constructor ----</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Face</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a Face from an OCCT TopoDS_Shape/TopoDS_Face</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (TopoDS_Shape, optional): OCCT Face.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">outer_wire</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">inner_wires</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Wire</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a planar Face from a boundary Wire with optional hole Wires.</span>

<span class="sd">        Args:</span>
<span class="sd">            outer_wire (Wire): closed perimeter wire</span>
<span class="sd">            inner_wires (Iterable[Wire], optional): holes. Defaults to None.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="n">outer_wire</span><span class="p">,</span> <span class="n">inner_wires</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">6</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">l_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopoDS_Shape</span><span class="p">):</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Wire</span><span class="p">):</span>
                <span class="n">outer_wire</span><span class="p">,</span> <span class="n">inner_wires</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="mi">5</span> <span class="o">-</span> <span class="n">l_a</span>
                <span class="p">)</span>

        <span class="n">unknown_args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;outer_wire&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;inner_wires&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;obj&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;label&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;color&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">unknown_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected argument(s) </span><span class="si">{</span><span class="n">unknown_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">outer_wire</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;outer_wire&quot;</span><span class="p">,</span> <span class="n">outer_wire</span><span class="p">)</span>
        <span class="n">inner_wires</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;inner_wires&quot;</span><span class="p">,</span> <span class="n">inner_wires</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outer_wire</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inner_topods_wires</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">wrapped</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">inner_wires</span><span class="p">]</span> <span class="k">if</span> <span class="n">inner_wires</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_make_topods_face_from_wires</span><span class="p">(</span><span class="n">outer_wire</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">inner_topods_wires</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Faces can optionally record the plane it was created on for later extrusion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created_on</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">area_without_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total surface area of the face, including the areas of any holes.</span>

<span class="sd">        This property returns the overall area of the face as if the inner boundaries (holes)</span>
<span class="sd">        were filled in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The total surface area, including the area of holes. Returns 0.0 if</span>
<span class="sd">            the face is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">without_holes</span><span class="p">()</span><span class="o">.</span><span class="n">area</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axis_of_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the rotational axis of a cylinder or torus&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">())</span> <span class="o">==</span> <span class="n">Geom_RectangularTrimmedSurface</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CYLINDER</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span><span class="o">.</span><span class="n">Cylinder</span><span class="p">()</span><span class="o">.</span><span class="n">Axis</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">TORUS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span><span class="o">.</span><span class="n">Axis</span><span class="p">())</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axes_of_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Axis</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes and returns the axes of symmetry for a planar face.</span>

<span class="sd">        The method determines potential symmetry axes by analyzing the faceâs</span>
<span class="sd">        geometry:</span>
<span class="sd">        - It first validates that the face is non-empty and planar.</span>
<span class="sd">        - For faces with inner wires (holes), it computes the centroid of the</span>
<span class="sd">          holes and the face&#39;s overall center (COG).</span>
<span class="sd">            If the holes&#39; centroid significantly deviates from the COG (beyond</span>
<span class="sd">            a specified tolerance), the symmetry axis is taken along the line</span>
<span class="sd">            connecting these points; otherwise, each holeâs center is used to</span>
<span class="sd">            generate a candidate axis.</span>
<span class="sd">        - For faces without holes, candidate directions are derived by sampling</span>
<span class="sd">          midpoints along the outer wire&#39;s edges.</span>
<span class="sd">            If curved edges are present, additional candidate directions are</span>
<span class="sd">            obtained from an oriented bounding box (OBB) constructed around the</span>
<span class="sd">            face.</span>

<span class="sd">        For each candidate direction, the face is split by a plane (defined</span>
<span class="sd">        using the candidate direction and the faceâs normal).  The top half of the face</span>
<span class="sd">        is then mirrored across this plane, and if the area of the intersection between</span>
<span class="sd">        the mirrored half and the bottom half matches the bottom halfâs area within a</span>
<span class="sd">        small tolerance, the direction is accepted as an axis of symmetry.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Axis]: A list of Axis objects, each defined by the face&#39;s</span>
<span class="sd">                center and a direction vector, representing the symmetry axes of</span>
<span class="sd">                the face.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the face or its underlying representation is empty.</span>
<span class="sd">            ValueError: If the face is not planar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t determine axes_of_symmetry of empty face&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar_face</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axes_of_symmetry only supports for planar faces&quot;</span><span class="p">)</span>

        <span class="n">cog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span>
        <span class="n">shape_inner_wires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_wires</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shape_inner_wires</span><span class="p">:</span>
            <span class="n">hole_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">Face</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">shape_inner_wires</span><span class="p">]</span>
            <span class="n">holes_centroid</span> <span class="o">=</span> <span class="n">Face</span><span class="o">.</span><span class="n">combined_center</span><span class="p">(</span><span class="n">hole_faces</span><span class="p">)</span>
            <span class="c1"># If the holes aren&#39;t centered on the cog the axis of symmetry must be</span>
            <span class="c1"># through the cog and hole centroid</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">holes_centroid</span> <span class="o">-</span> <span class="n">cog</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TOLERANCE</span><span class="p">:</span>
                <span class="n">cross_dirs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">holes_centroid</span> <span class="o">-</span> <span class="n">cog</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># There may be an axis of symmetry through the center of the holes</span>
                <span class="n">cross_dirs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">f</span><span class="o">.</span><span class="n">center</span><span class="p">()</span> <span class="o">-</span> <span class="n">cog</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">hole_faces</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curved_edges</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outer_wire</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">shape_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_wire</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">curved_edges</span><span class="p">:</span>
                <span class="n">obb</span> <span class="o">=</span> <span class="n">OrientedBoundBox</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">corners</span> <span class="o">=</span> <span class="n">obb</span><span class="o">.</span><span class="n">corners</span>
                <span class="n">obb_edges</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">corners</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">e</span> <span class="o">@</span> <span class="n">p</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">shape_edges</span> <span class="o">+</span> <span class="n">obb_edges</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mid_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="o">@</span> <span class="n">p</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">shape_edges</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
            <span class="n">cross_dirs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mid_point</span> <span class="o">-</span> <span class="n">cog</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="k">for</span> <span class="n">mid_point</span> <span class="ow">in</span> <span class="n">mid_points</span><span class="p">]</span>

        <span class="n">symmetry_dirs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Vector</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cross_dir</span> <span class="ow">in</span> <span class="n">cross_dirs</span><span class="p">:</span>
            <span class="c1"># Split the face by the potential axis and flip the top</span>
            <span class="n">split_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span>
                <span class="n">origin</span><span class="o">=</span><span class="n">cog</span><span class="p">,</span>
                <span class="n">x_dir</span><span class="o">=</span><span class="n">cross_dir</span><span class="p">,</span>
                <span class="n">z_dir</span><span class="o">=</span><span class="n">cross_dir</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normal</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># Split by plane</span>
            <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_plane</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">bottom</span><span class="p">):</span>  <span class="c1"># exit early if not same</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Impossible to actually happen?</span>
                <span class="k">continue</span>

            <span class="n">top_list</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">top</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">top</span><span class="p">])</span>
            <span class="n">bottom_list</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">bottom</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">bottom</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bottom_list</span><span class="p">):</span>  <span class="c1"># exit early unequal length</span>
                <span class="k">continue</span>

            <span class="n">bottom_list</span> <span class="o">=</span> <span class="n">bottom_list</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="p">(</span><span class="n">cog</span><span class="p">,</span> <span class="n">cross_dir</span><span class="p">))</span>
            <span class="n">top_flipped_list</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
                <span class="n">f</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">split_plane</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">top_list</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="p">(</span><span class="n">cog</span><span class="p">,</span> <span class="n">cross_dir</span><span class="p">))</span>

            <span class="n">bottom_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">bottom_list</span><span class="p">)</span>
            <span class="n">intersect_area</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">flipped_face</span><span class="p">,</span> <span class="n">bottom_face</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">top_flipped_list</span><span class="p">,</span> <span class="n">bottom_list</span><span class="p">):</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="n">flipped_face</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">bottom_face</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">intersect_area</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">Face</span><span class="p">)</span>
                    <span class="n">intersect_area</span> <span class="o">+=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">area</span>

            <span class="k">if</span> <span class="n">intersect_area</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Are the top/bottom the same?</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">intersect_area</span> <span class="o">-</span> <span class="n">bottom_area</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TOLERANCE</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">symmetry_dirs</span><span class="p">:</span>
                    <span class="n">symmetry_dirs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cross_dir</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">opposite</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cross_dir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">TOLERANCE</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">symmetry_dirs</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">opposite</span><span class="p">:</span>
                        <span class="n">symmetry_dirs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cross_dir</span><span class="p">)</span>

        <span class="n">symmetry_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axis</span><span class="p">(</span><span class="n">cog</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">symmetry_dirs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">symmetry_axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center_location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Location at the center of face&quot;&quot;&quot;</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Plane</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">z_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span><span class="o">.</span><span class="n">location</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;geometry of planar face&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar</span><span class="p">:</span>
            <span class="n">flat_face</span><span class="p">:</span> <span class="n">Face</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">flat_face_edges</span> <span class="o">=</span> <span class="n">flat_face</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">flat_face_edges</span><span class="p">):</span>
                <span class="n">flat_face_vertices</span> <span class="o">=</span> <span class="n">flat_face</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;POLYGON&quot;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_face_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">edge_pairs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">flat_face_vertices</span><span class="p">:</span>
                        <span class="n">edge_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">flat_face_edges</span> <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
                        <span class="p">)</span>
                        <span class="n">edge_pair_directions</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">edge_pairs</span>
                        <span class="p">]</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="n">edge_directions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(</span><span class="n">edge_directions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">90</span>
                        <span class="k">for</span> <span class="n">edge_directions</span> <span class="ow">in</span> <span class="n">edge_pair_directions</span>
                    <span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;RECTANGLE&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_face_edges</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">SortBy</span><span class="o">.</span><span class="n">LENGTH</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;SQUARE&quot;</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_curvature_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the signed dot product between the face normal and the vector from the</span>
<span class="sd">        underlying geometry&#39;s reference point to the face center.</span>

<span class="sd">        For a cylinder, the reference is the cylinderâs axis position.</span>
<span class="sd">        For a sphere, it is the sphereâs center.</span>
<span class="sd">        For a torus, we derive a reference point on the central circle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The signed value; positive indicates convexity, negative indicates concavity.</span>
<span class="sd">                Returns 0 if the geometry type is unsupported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CYLINDER</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Geom_RectangularTrimmedSurface</span>
        <span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_of_rotation</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find curvature of empty object&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span> <span class="o">-</span> <span class="n">axis</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">SPHERE</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span>  <span class="c1"># The sphere&#39;s center</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find curvature of empty object&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span> <span class="o">-</span> <span class="n">loc</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">TORUS</span><span class="p">:</span>
            <span class="c1"># Here we assume that for a torus the rotational axis can be converted to a plane,</span>
            <span class="c1"># and we then define the central (or core) circle using the first value of self.radii.</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_of_rotation</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t find curvature of empty object&quot;</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">to_plane</span><span class="p">())</span>
            <span class="n">axis_circle</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">locate</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">pnt_on_axis_circle</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">axis_circle</span><span class="o">.</span><span class="n">distance_to_with_closest_points</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span> <span class="o">-</span> <span class="n">pnt_on_axis_circle</span><span class="p">)</span>

        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_circular_convex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given face is convex relative to its underlying geometry</span>
<span class="sd">        for supported geometries: cylinder, sphere, torus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if convex; otherwise, False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curvature_sign</span> <span class="o">&gt;</span> <span class="n">TOLERANCE</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_circular_concave</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given face is concave relative to its underlying geometry</span>
<span class="sd">        for supported geometries: cylinder, sphere, torus.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if concave; otherwise, False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curvature_sign</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">TOLERANCE</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_planar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the face planar even though its geom_type may not be PLANE&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar_face</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;length of planar face&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar</span><span class="p">:</span>
            <span class="c1"># Reposition on Plane.XY</span>
            <span class="n">flat_face</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">face_vertices</span> <span class="o">=</span> <span class="n">flat_face</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">face_vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">face_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">radii</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the major and minor radii of a torus otherwise None&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">TORUS</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span><span class="o">.</span><span class="n">MajorRadius</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span><span class="o">.</span><span class="n">MinorRadius</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the radius of a cylinder or sphere, otherwise None&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">GeomType</span><span class="o">.</span><span class="n">CYLINDER</span><span class="p">,</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">SPHERE</span><span class="p">]</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Geom_RectangularTrimmedSurface</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span><span class="o">.</span><span class="n">Radius</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;volume - the volume of this Face, which is always zero&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;width of planar face&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar</span><span class="p">:</span>
            <span class="c1"># Reposition on Plane.XY</span>
            <span class="n">flat_face</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">face_vertices</span> <span class="o">=</span> <span class="n">flat_face</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">face_vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">face_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Face.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;extrude</span>

<span class="sd">        Extrude an Edge into a Face.</span>

<span class="sd">        Args:</span>
<span class="sd">            direction (VectorLike): direction and magnitude of extrusion</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Unsupported class</span>
<span class="sd">            RuntimeError: Generated invalid result</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: extruded shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Face</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Face_s</span><span class="p">(</span><span class="n">_extrude_topods_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">direction</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Face.make_bezier_surface">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_bezier_surface">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_bezier_surface</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">]],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_bezier_surface</span>

<span class="sd">        Construct a BÃ©zier surface from the provided 2d array of points.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list[list[VectorLike]]): a 2D list of control points</span>
<span class="sd">            weights (list[list[float]], optional): control point weights. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Too few control points</span>
<span class="sd">            ValueError: Too many control points</span>
<span class="sd">            ValueError: A weight is required for each control point</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: a potentially non-planar face</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;At least two control points must be provided (start, end)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">25</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The maximum number of control points is 25&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A weight must be provided for each control point&quot;</span><span class="p">)</span>

        <span class="n">points_</span> <span class="o">=</span> <span class="n">TColgp_HArray2OfPnt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row_points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_points</span><span class="p">):</span>
                <span class="n">points_</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">weights_</span> <span class="o">=</span> <span class="n">TColStd_HArray2OfReal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row_weights</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_weights</span><span class="p">):</span>
                    <span class="n">weights_</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span>
            <span class="n">bezier</span> <span class="o">=</span> <span class="n">Geom_BezierSurface</span><span class="p">(</span><span class="n">points_</span><span class="p">,</span> <span class="n">weights_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bezier</span> <span class="o">=</span> <span class="n">Geom_BezierSurface</span><span class="p">(</span><span class="n">points_</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">bezier</span><span class="p">,</span> <span class="n">Precision</span><span class="o">.</span><span class="n">Confusion_s</span><span class="p">())</span><span class="o">.</span><span class="n">Face</span><span class="p">())</span></div>


<div class="viewcode-block" id="Face.make_plane">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_plane">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_plane</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a unlimited size Face aligned with plane&quot;&quot;&quot;</span>
        <span class="n">pln_shape</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Face</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">pln_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.make_rect">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_rect">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_rect</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_rect</span>

<span class="sd">        Make a Rectangle centered on center with the given normal</span>

<span class="sd">        Args:</span>
<span class="sd">            width (float, optional): width (local x).</span>
<span class="sd">            height (float, optional): height (local y).</span>
<span class="sd">            plane (Plane, optional): base plane. Defaults to Plane.XY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: The centered rectangle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pln_shape</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="o">-</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">height</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="p">)</span><span class="o">.</span><span class="n">Face</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">pln_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.make_surface">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_surface">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_surface</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">exterior</span><span class="p">:</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
        <span class="n">surface_points</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interior_wires</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Wire</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create Non-Planar Face</span>

<span class="sd">        Create a potentially non-planar face bounded by exterior (wire or edges),</span>
<span class="sd">        optionally refined by surface_points with optional holes defined by</span>
<span class="sd">        interior_wires.</span>

<span class="sd">        Args:</span>
<span class="sd">            exterior (Union[Wire, list[Edge]]): Perimeter of face</span>
<span class="sd">            surface_points (list[VectorLike], optional): Points on the surface that</span>
<span class="sd">                refine the shape. Defaults to None.</span>
<span class="sd">            interior_wires (list[Wire], optional): Hole(s) in the face. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Internal error building face</span>
<span class="sd">            RuntimeError: Error building non-planar face with provided surface_points</span>
<span class="sd">            RuntimeError: Error adding interior hole</span>
<span class="sd">            RuntimeError: Generated face is invalid</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: Potentially non-planar face</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exterior</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exterior</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exterior</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="n">exterior</span>
        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="k">if</span> <span class="n">surface_points</span><span class="p">:</span>
            <span class="n">surface_point_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">surface_points</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">surface_point_vectors</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># First, create the non-planar surface</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">BRepOffsetAPI_MakeFilling</span><span class="p">(</span>
            <span class="c1"># order of energy criterion to minimize for computing the deformation of the surface</span>
            <span class="n">Degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="c1"># average number of points for discretisation of the edges</span>
            <span class="n">NbPtsOnCur</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
            <span class="n">NbIter</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">Anisotropie</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># the maximum distance allowed between the support surface and the constraints</span>
            <span class="n">Tol2d</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span>
            <span class="c1"># the maximum distance allowed between the support surface and the constraints</span>
            <span class="n">Tol3d</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span>
            <span class="c1"># the maximum angle allowed between the normal of the surface and the constraints</span>
            <span class="n">TolAng</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="c1"># the maximum difference of curvature allowed between the surface and the constraint</span>
            <span class="n">TolCurv</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="c1"># the highest degree which the polynomial defining the filling surface can have</span>
            <span class="n">MaxDeg</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
            <span class="c1"># the greatest number of segments which the filling surface can have</span>
            <span class="n">MaxSegments</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exterior</span><span class="p">,</span> <span class="n">Wire</span><span class="p">):</span>
            <span class="n">outside_edges</span> <span class="o">=</span> <span class="n">exterior</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exterior</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">exterior</span>
        <span class="p">):</span>
            <span class="n">outside_edges</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">exterior</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exterior must be a Wire or list of Edges&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">outside_edges</span><span class="p">:</span>
            <span class="n">surface</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">GeomAbs_C0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">surface</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
            <span class="n">surface_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="k">except</span> <span class="p">(</span>
            <span class="n">Standard_Failure</span><span class="p">,</span>
            <span class="n">StdFail_NotDone</span><span class="p">,</span>
            <span class="n">Standard_NoSuchObject</span><span class="p">,</span>
            <span class="n">Standard_ConstructionError</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Error building non-planar face with provided exterior&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">if</span> <span class="n">surface_point_vectors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">surface_point_vectors</span><span class="p">:</span>
                <span class="n">surface</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">surface</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
                <span class="n">surface_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
            <span class="k">except</span> <span class="n">StdFail_NotDone</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Error building non-planar face with provided surface_points&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

        <span class="c1"># Next, add wires that define interior holes - note these wires must be entirely interior</span>
        <span class="k">if</span> <span class="n">interior_wires</span><span class="p">:</span>
            <span class="n">makeface_object</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">surface_face</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">wire</span> <span class="ow">in</span> <span class="n">interior_wires</span><span class="p">:</span>
                <span class="n">makeface_object</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">wire</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">surface_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">makeface_object</span><span class="o">.</span><span class="n">Face</span><span class="p">())</span>
            <span class="k">except</span> <span class="n">StdFail_NotDone</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Error adding interior hole in non-planar face with provided interior_wires&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

        <span class="n">surface_face</span> <span class="o">=</span> <span class="n">surface_face</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">surface_face</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;non planar face is invalid&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">surface_face</span></div>


<div class="viewcode-block" id="Face.make_surface_from_array_of_points">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_surface_from_array_of_points">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_surface_from_array_of_points</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">]],</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">,</span>
        <span class="n">smoothing</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_deg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">max_deg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_surface_from_array_of_points</span>

<span class="sd">        Approximate a spline surface through the provided 2d array of points.</span>
<span class="sd">        The first dimension correspond to points on the vertical direction in the parameter</span>
<span class="sd">        space of the face. The second dimension correspond to points on the horizontal</span>
<span class="sd">        direction in the parameter space of the face. The 2 dimensions are U,V dimensions</span>
<span class="sd">        of the parameter space of the face.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list[list[VectorLike]]): a 2D list of points, first dimension is V</span>
<span class="sd">                parameters second is U parameters.</span>
<span class="sd">            tol (float, optional): tolerance of the algorithm. Defaults to 1e-2.</span>
<span class="sd">            smoothing (Tuple[float, float, float], optional): optional tuple of</span>
<span class="sd">                3 weights use for variational smoothing. Defaults to None.</span>
<span class="sd">            min_deg (int, optional): minimum spline degree. Enforced only when</span>
<span class="sd">                smoothing is None. Defaults to 1.</span>
<span class="sd">            max_deg (int, optional): maximum spline degree. Defaults to 3.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: B-spline approximation failed</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: a potentially non-planar face defined by points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points_</span> <span class="o">=</span> <span class="n">TColgp_HArray2OfPnt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_row</span><span class="p">):</span>
                <span class="n">points_</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_PointsToBSplineSurface</span><span class="p">(</span>
                <span class="n">points_</span><span class="p">,</span> <span class="o">*</span><span class="n">smoothing</span><span class="p">,</span> <span class="n">DegMax</span><span class="o">=</span><span class="n">max_deg</span><span class="p">,</span> <span class="n">Tol3D</span><span class="o">=</span><span class="n">tol</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_PointsToBSplineSurface</span><span class="p">(</span>
                <span class="n">points_</span><span class="p">,</span> <span class="n">DegMin</span><span class="o">=</span><span class="n">min_deg</span><span class="p">,</span> <span class="n">DegMax</span><span class="o">=</span><span class="n">max_deg</span><span class="p">,</span> <span class="n">Tol3D</span><span class="o">=</span><span class="n">tol</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">IsDone</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B-spline approximation failed&quot;</span><span class="p">)</span>

        <span class="n">spline_geom</span> <span class="o">=</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">Surface</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">spline_geom</span><span class="p">,</span> <span class="n">Precision</span><span class="o">.</span><span class="n">Confusion_s</span><span class="p">())</span><span class="o">.</span><span class="n">Face</span><span class="p">())</span></div>


    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_surface_from_curves</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">edge1</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">edge2</span><span class="p">:</span> <span class="n">Edge</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_surface_from_curves</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">wire1</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">wire2</span><span class="p">:</span> <span class="n">Wire</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="o">...</span>

<div class="viewcode-block" id="Face.make_surface_from_curves">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_surface_from_curves">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_surface_from_curves</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_surface_from_curves</span>

<span class="sd">        Create a ruled surface out of two edges or two wires. If wires are used then</span>
<span class="sd">        these must have the same number of edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            curve1 (Union[Edge,Wire]): side of surface</span>
<span class="sd">            curve2 (Union[Edge,Wire]): opposite side of surface</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: potentially non planar surface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve1</span><span class="p">,</span> <span class="n">curve2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Both curves must be of the same type (both Edge or both Wire).&quot;</span>
                <span class="p">)</span>
            <span class="n">curve1</span><span class="p">,</span> <span class="n">curve2</span> <span class="o">=</span> <span class="n">args</span>

        <span class="n">curve1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;edge1&quot;</span><span class="p">,</span> <span class="n">curve1</span><span class="p">)</span>
        <span class="n">curve2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;edge2&quot;</span><span class="p">,</span> <span class="n">curve2</span><span class="p">)</span>
        <span class="n">curve1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;wire1&quot;</span><span class="p">,</span> <span class="n">curve1</span><span class="p">)</span>
        <span class="n">curve2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;wire2&quot;</span><span class="p">,</span> <span class="n">curve2</span><span class="p">)</span>

        <span class="c1"># Handle unexpected kwargs</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected argument(s): </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve1</span><span class="p">,</span> <span class="p">(</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve2</span><span class="p">,</span> <span class="p">(</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Both curves must be of the same type (both Edge or both Wire).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve1</span><span class="p">,</span> <span class="n">Wire</span><span class="p">):</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">BRepFill</span><span class="o">.</span><span class="n">Shell_s</span><span class="p">(</span><span class="n">curve1</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">curve2</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">BRepFill</span><span class="o">.</span><span class="n">Face_s</span><span class="p">(</span><span class="n">curve1</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">curve2</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Face.sew_faces">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.sew_faces">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sew_faces</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">faces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Face</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sew faces</span>

<span class="sd">        Group contiguous faces and return them in a list of ShapeList</span>

<span class="sd">        Args:</span>
<span class="sd">            faces (Iterable[Face]): Faces to sew together</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: OCCT SewedShape generated unexpected output</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[ShapeList[Face]]: grouped contiguous faces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sew the faces</span>
        <span class="n">sewed_shape</span> <span class="o">=</span> <span class="n">_sew_topods_faces</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">wrapped</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">])</span>
        <span class="n">top_level_shapes</span> <span class="o">=</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">sewed_shape</span><span class="p">)</span>
        <span class="n">sewn_faces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapeList</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For each of the top level shapes create a ShapeList of Face</span>
        <span class="k">for</span> <span class="n">top_level_shape</span> <span class="ow">in</span> <span class="n">top_level_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">,</span> <span class="n">TopoDS_Face</span><span class="p">):</span>
                <span class="n">sewn_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ShapeList</span><span class="p">([</span><span class="n">Face</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">)]))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">,</span> <span class="n">TopoDS_Shell</span><span class="p">):</span>
                <span class="n">sewn_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Shell</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">)</span><span class="o">.</span><span class="n">faces</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">,</span> <span class="n">TopoDS_Solid</span><span class="p">):</span>
                <span class="n">sewn_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">ShapeList</span><span class="p">(</span>
                        <span class="n">Face</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">_topods_entities</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;SewedShape returned a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">top_level_shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> which was unexpected&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">sewn_faces</span></div>


<div class="viewcode-block" id="Face.sweep">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.sweep">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sweep</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">profile</span><span class="p">:</span> <span class="n">Curve</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Curve</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">transition</span><span class="o">=</span><span class="n">Transition</span><span class="o">.</span><span class="n">TRANSFORMED</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sweep</span>

<span class="sd">        Sweep a 1D profile along a 1D path. Both the profile and path must be composed</span>
<span class="sd">        of only 1 Edge.</span>

<span class="sd">        Args:</span>
<span class="sd">            profile (Union[Curve,Edge,Wire]): the object to sweep</span>
<span class="sd">            path (Union[Curve,Edge,Wire]): the path to follow when sweeping</span>
<span class="sd">            transition (Transition, optional): handling of profile orientation at C1 path</span>
<span class="sd">                discontinuities. Defaults to Transition.TRANSFORMED.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Only 1 Edge allowed in profile &amp; path</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: resulting face, may be non-planar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: BRepOffsetAPI_MakePipe is an option here</span>
        <span class="c1"># pipe_sweep = BRepOffsetAPI_MakePipe(path.wrapped, profile.wrapped)</span>
        <span class="c1"># pipe_sweep.Build()</span>
        <span class="c1"># return Face(pipe_sweep.Shape())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use Shell.sweep for multi Edge objects&quot;</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="n">profile</span><span class="o">.</span><span class="n">edge</span><span class="p">()])</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="n">path</span><span class="o">.</span><span class="n">edge</span><span class="p">()])</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">BRepOffsetAPI_MakePipeShell</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">SetTransitionMode</span><span class="p">(</span><span class="n">Shape</span><span class="o">.</span><span class="n">_transModeDict</span><span class="p">[</span><span class="n">transition</span><span class="p">])</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Face.center">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.center">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_of</span><span class="p">:</span> <span class="n">CenterOf</span> <span class="o">=</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">GEOMETRY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Center of Face</span>

<span class="sd">        Return the center based on center_of</span>

<span class="sd">        Args:</span>
<span class="sd">            center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">MASS</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">GEOMETRY</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar</span>
        <span class="p">):</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
            <span class="n">BRepGProp</span><span class="o">.</span><span class="n">SurfaceProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">CentreOfMass</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">BOUNDING_BOX</span><span class="p">:</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">GEOMETRY</span><span class="p">:</span>
            <span class="n">u_val0</span><span class="p">,</span> <span class="n">u_val1</span><span class="p">,</span> <span class="n">v_val0</span><span class="p">,</span> <span class="n">v_val1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv_bounds</span><span class="p">()</span>
            <span class="n">u_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_val0</span> <span class="o">+</span> <span class="n">u_val1</span><span class="p">)</span>
            <span class="n">v_val</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_val0</span> <span class="o">+</span> <span class="n">v_val1</span><span class="p">)</span>

            <span class="n">center_point</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
            <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">center_point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">center_point</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.chamfer_2d">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.chamfer_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chamfer_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">distance2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">],</span>
        <span class="n">edge</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply 2D chamfer to a face</span>

<span class="sd">        Args:</span>
<span class="sd">            distance (float): chamfer length</span>
<span class="sd">            distance2 (float): chamfer length</span>
<span class="sd">            vertices (Iterable[Vertex]): vertices to chamfer</span>
<span class="sd">            edge (Edge): identifies the side where length is measured. The vertices must be</span>
<span class="sd">                part of the edge</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Cannot chamfer at this location</span>
<span class="sd">            ValueError: One or more vertices are not part of edge</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: face with a chamfered corner(s)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference_edge</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="n">chamfer_builder</span> <span class="o">=</span> <span class="n">BRepFilletAPI_MakeFillet2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="n">vertex_edge_map</span> <span class="o">=</span> <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">()</span>
        <span class="n">TopExp</span><span class="o">.</span><span class="n">MapShapesAndAncestors_s</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">,</span> <span class="n">vertex_edge_map</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">vertex_edge_map</span><span class="o">.</span><span class="n">FindFromKey</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

            <span class="c1"># Index or iterator access to OCP.TopTools.TopTools_ListOfShape is slow on M1 macs</span>
            <span class="c1"># Using First() and Last() to omit</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">First</span><span class="p">()),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">Last</span><span class="p">()))</span>

            <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">order_chamfer_edges</span><span class="p">(</span><span class="n">reference_edge</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>

            <span class="n">chamfer_builder</span><span class="o">.</span><span class="n">AddChamfer</span><span class="p">(</span>
                <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">edge1</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span>
                <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">edge2</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span>
                <span class="n">distance</span><span class="p">,</span>
                <span class="n">distance2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">chamfer_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">chamfer_builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span></div>


<div class="viewcode-block" id="Face.fillet_2d">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.fillet_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fillet_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply 2D fillet to a face</span>

<span class="sd">        Args:</span>
<span class="sd">          radius: float:</span>
<span class="sd">          vertices: Iterable[Vertex]:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fillet_builder</span> <span class="o">=</span> <span class="n">BRepFilletAPI_MakeFillet2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">fillet_builder</span><span class="o">.</span><span class="n">AddFillet</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>

        <span class="n">fillet_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">fillet_builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span></div>


<div class="viewcode-block" id="Face.geom_adaptor">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.geom_adaptor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_adaptor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geom_Surface</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Geom Surface for this Face&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Surface_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.inner_wires">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.inner_wires">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner_wires</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the inner or hole wires from this Face&quot;&quot;&quot;</span>
        <span class="n">outer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_wire</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wires</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">is_same</span><span class="p">(</span><span class="n">outer</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Face.is_coplanar">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.is_coplanar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_coplanar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is this planar face coplanar with the provided plane&quot;&quot;&quot;</span>
        <span class="n">u_val0</span><span class="p">,</span> <span class="n">_u_val1</span><span class="p">,</span> <span class="n">v_val0</span><span class="p">,</span> <span class="n">_v_val1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv_bounds</span><span class="p">()</span>
        <span class="n">gp_pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
        <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">u_val0</span><span class="p">,</span> <span class="n">v_val0</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">gp_pnt</span><span class="p">))</span>
            <span class="ow">and</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="n">TOLERANCE</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Face.is_inside">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.is_inside">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Point inside Face</span>

<span class="sd">        Returns whether or not the point is inside a Face within the specified tolerance.</span>
<span class="sd">        Points on the edge of the Face are considered inside.</span>

<span class="sd">        Args:</span>
<span class="sd">          point(VectorLike): tuple or Vector representing 3D point to be tested</span>
<span class="sd">          tolerance(float): tolerance for inside determination. Defaults to 1.0e-6.</span>
<span class="sd">          point: VectorLike:</span>
<span class="sd">          tolerance: float:  (Default value = 1.0e-6)</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: indicating whether or not point is within Face</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solid_classifier</span> <span class="o">=</span> <span class="n">BRepClass3d_SolidClassifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">solid_classifier</span><span class="o">.</span><span class="n">Perform</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="o">*</span><span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()),</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solid_classifier</span><span class="o">.</span><span class="n">IsOnAFace</span><span class="p">()</span></div>


        <span class="c1"># surface = BRep_Tool.Surface_s(self.wrapped)</span>
        <span class="c1"># projector = GeomAPI_ProjectPointOnSurf(Vector(point).to_pnt(), surface)</span>
        <span class="c1"># return projector.LowerDistance() &lt;= TOLERANCE</span>

<div class="viewcode-block" id="Face.location_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.location_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">location_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Location at the u/v position of face&quot;&quot;&quot;</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pln</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">z_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pln</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="n">Vector</span><span class="p">(</span><span class="n">x_dir</span><span class="p">),</span> <span class="n">z_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_at</span><span class="p">(</span><span class="n">origin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Location</span><span class="p">(</span><span class="n">pln</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.make_holes">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.make_holes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interior_wires</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Wire</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make Holes in Face</span>

<span class="sd">        Create holes in the Face &#39;self&#39; from interior_wires which must be entirely interior.</span>
<span class="sd">        Note that making holes in faces is more efficient than using boolean operations</span>
<span class="sd">        with solid object. Also note that OCCT core may fail unless the orientation of the wire</span>
<span class="sd">        is correct - use `Wire(forward_wire.wrapped.Reversed())` to reverse a wire.</span>

<span class="sd">        Example:</span>

<span class="sd">            For example, make a series of slots on the curved walls of a cylinder.</span>

<span class="sd">        .. image:: slotted_cylinder.png</span>

<span class="sd">        Args:</span>
<span class="sd">          interior_wires: a list of hole outline wires</span>
<span class="sd">          interior_wires: list[Wire]:</span>

<span class="sd">        Returns:</span>
<span class="sd">          Face: &#39;self&#39; with holes</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: adding interior hole in non-planar face with provided interior_wires</span>
<span class="sd">          RuntimeError: resulting face is not valid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add wires that define interior holes - note these wires must be entirely interior</span>
        <span class="n">makeface_object</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">interior_wire</span> <span class="ow">in</span> <span class="n">interior_wires</span><span class="p">:</span>
            <span class="n">makeface_object</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">interior_wire</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">surface_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">makeface_object</span><span class="o">.</span><span class="n">Face</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">StdFail_NotDone</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Error adding interior hole in non-planar face with provided interior_wires&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

        <span class="n">surface_face</span> <span class="o">=</span> <span class="n">surface_face</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>
        <span class="c1"># if not surface_face.is_valid():</span>
        <span class="c1">#     raise RuntimeError(&quot;non planar face is invalid&quot;)</span>

        <span class="k">return</span> <span class="n">surface_face</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_point</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;normal_at point on surface</span>

<span class="sd">        Args:</span>
<span class="sd">            surface_point (VectorLike, optional): a point that lies on the surface where</span>
<span class="sd">                the normal. Defaults to the center (None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: surface normal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;normal_at u, v values on Face</span>

<span class="sd">        Args:</span>
<span class="sd">            u (float): the horizontal coordinate in the parameter space of the Face,</span>
<span class="sd">                between 0.0 and 1.0</span>
<span class="sd">            v (float): the vertical coordinate in the parameter space of the Face,</span>
<span class="sd">                between 0.0 and 1.0</span>
<span class="sd">                Defaults to the center (None/None)</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Either neither or both u v values must be provided</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: surface normal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Face.normal_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.normal_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;normal_at</span>

<span class="sd">        Computes the normal vector at the desired location on the face.</span>

<span class="sd">        Args:</span>
<span class="sd">            surface_point (VectorLike, optional): a point that lies on the surface where the normal.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: surface normal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surface_point</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">surface_point</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">unknown_args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="s2">&quot;surface_point&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">unknown_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected argument(s) </span><span class="si">{</span><span class="n">unknown_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">surface_point</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;surface_point&quot;</span><span class="p">,</span> <span class="n">surface_point</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">surface_point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span>
        <span class="k">elif</span> <span class="n">surface_point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both u &amp; v values must be specified&quot;</span><span class="p">)</span>

        <span class="c1"># get the geometry</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">surface_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u_val0</span><span class="p">,</span> <span class="n">u_val1</span><span class="p">,</span> <span class="n">v_val0</span><span class="p">,</span> <span class="n">v_val1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv_bounds</span><span class="p">()</span>
            <span class="n">u_val</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_val0</span> <span class="o">+</span> <span class="n">u_val1</span><span class="p">)</span>
            <span class="n">v_val</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_val0</span> <span class="o">+</span> <span class="n">v_val1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># project point on surface</span>
            <span class="n">projector</span> <span class="o">=</span> <span class="n">GeomAPI_ProjectPointOnSurf</span><span class="p">(</span>
                <span class="n">Vector</span><span class="p">(</span><span class="n">surface_point</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">surface</span>
            <span class="p">)</span>

            <span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span> <span class="o">=</span> <span class="n">projector</span><span class="o">.</span><span class="n">LowerDistanceParameters</span><span class="p">()</span>

        <span class="n">gp_pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
        <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span></div>


<div class="viewcode-block" id="Face.outer_wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.outer_wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">outer_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the perimeter wire from this Face&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">(</span><span class="n">BRepTools</span><span class="o">.</span><span class="n">OuterWire_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span></div>


<div class="viewcode-block" id="Face.position_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.position_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;position_at</span>

<span class="sd">        Computes a point on the Face given u, v coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            u (float): the horizontal coordinate in the parameter space of the Face,</span>
<span class="sd">                between 0.0 and 1.0</span>
<span class="sd">            v (float): the vertical coordinate in the parameter space of the Face,</span>
<span class="sd">                between 0.0 and 1.0</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: point on Face</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u_val0</span><span class="p">,</span> <span class="n">u_val1</span><span class="p">,</span> <span class="n">v_val0</span><span class="p">,</span> <span class="n">v_val1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uv_bounds</span><span class="p">()</span>
        <span class="n">u_val</span> <span class="o">=</span> <span class="n">u_val0</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_val1</span> <span class="o">-</span> <span class="n">u_val0</span><span class="p">)</span>
        <span class="n">v_val</span> <span class="o">=</span> <span class="n">v_val0</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_val1</span> <span class="o">-</span> <span class="n">v_val0</span><span class="p">)</span>

        <span class="n">gp_pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
        <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">gp_pnt</span><span class="p">)</span></div>


<div class="viewcode-block" id="Face.project_to_shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.project_to_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_to_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target_object</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project Face to target Object</span>

<span class="sd">        Project a Face onto a Shape generating new Face(s) on the surfaces of the object.</span>

<span class="sd">        A projection with no taper is illustrated below:</span>

<span class="sd">        .. image:: flatProjection.png</span>
<span class="sd">            :alt: flatProjection</span>

<span class="sd">        Note that an array of faces is returned as the projection might result in faces</span>
<span class="sd">        on the &quot;front&quot; and &quot;back&quot; of the object (or even more if there are intermediate</span>
<span class="sd">        surfaces in the projection path). faces &quot;behind&quot; the projection are not</span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_object (Shape): Object to project onto</span>
<span class="sd">            direction (VectorLike): projection direction</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Face]: Face(s) projected on target object ordered by distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_dimension</span> <span class="o">=</span> <span class="n">find_max_dimension</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_object</span><span class="p">])</span>
        <span class="n">extruded_topods_self</span> <span class="o">=</span> <span class="n">_extrude_topods_shape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_dimension</span>
        <span class="p">)</span>

        <span class="n">intersected_shapes</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_object</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;projection to a vertex is not supported&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_object</span><span class="p">,</span> <span class="n">Face</span><span class="p">):</span>
            <span class="n">topods_shape</span> <span class="o">=</span> <span class="n">_topods_bool_op</span><span class="p">(</span>
                <span class="p">(</span><span class="n">extruded_topods_self</span><span class="p">,),</span> <span class="p">(</span><span class="n">target_object</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,),</span> <span class="n">BRepAlgoAPI_Common</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">topods_shape</span><span class="o">.</span><span class="n">IsNull</span><span class="p">():</span>
                <span class="n">intersected_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face</span><span class="p">(</span><span class="n">topods_shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target_shell</span> <span class="ow">in</span> <span class="n">target_object</span><span class="o">.</span><span class="n">shells</span><span class="p">():</span>
                <span class="n">topods_shape</span> <span class="o">=</span> <span class="n">_topods_bool_op</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">extruded_topods_self</span><span class="p">,),</span>
                    <span class="p">(</span><span class="n">target_shell</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,),</span>
                    <span class="n">BRepAlgoAPI_Common</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">topods_shell</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">topods_shape</span><span class="p">):</span>
                    <span class="n">intersected_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Shell</span><span class="p">(</span><span class="n">topods_shell</span><span class="p">))</span>

        <span class="n">intersected_shapes</span> <span class="o">=</span> <span class="n">intersected_shapes</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(),</span> <span class="n">direction</span><span class="p">))</span>
        <span class="n">projected_shapes</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">intersected_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">faces</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape_face</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">face</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">shape_face</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">projected_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape_face</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">projected_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">projected_shapes</span></div>


<div class="viewcode-block" id="Face.to_arcs">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.to_arcs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;to_arcs</span>

<span class="sd">        Approximate planar face with arcs and straight line segments.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: approximated face</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot approximate an empty shape&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">BRepAlgo</span><span class="o">.</span><span class="n">ConvertFace_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span></div>


<div class="viewcode-block" id="Face.without_holes">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.without_holes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">without_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;without_holes</span>

<span class="sd">        Remove all of the holes from this face.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: A new Face instance identical to the original but without any holes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot remove holes from an empty face&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">inner_wires</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_wires</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">holeless</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">reshaper</span> <span class="o">=</span> <span class="n">BRepTools_ReShape</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">hole_wire</span> <span class="ow">in</span> <span class="n">inner_wires</span><span class="p">:</span>
            <span class="n">reshaper</span><span class="o">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">hole_wire</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">modified_shape</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">reshaper</span><span class="o">.</span><span class="n">Apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>
        <span class="n">holeless</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">modified_shape</span>
        <span class="k">return</span> <span class="n">holeless</span></div>


<div class="viewcode-block" id="Face.wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Face.wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the outerwire, generate a warning if inner_wires present&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_wires</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Found holes, returning outer_wire&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_wire</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_uv_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the u min, u max, v min, v max values&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BRepTools</span><span class="o">.</span><span class="n">UVBounds_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>



<div class="viewcode-block" id="Shell">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shell">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Shell</span><span class="p">(</span><span class="n">Mixin2D</span><span class="p">,</span> <span class="n">Shape</span><span class="p">[</span><span class="n">TopoDS_Shell</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Shell is a fundamental component in build123d&#39;s topological data structure</span>
<span class="sd">    representing a connected set of faces forming a closed surface in 3D space. As</span>
<span class="sd">    part of a geometric model, it defines a watertight enclosure, commonly encountered</span>
<span class="sd">    in solid modeling. Shells group faces in a coherent manner, playing a crucial role</span>
<span class="sd">    in representing complex shapes with voids and surfaces. This hierarchical structure</span>
<span class="sd">    allows for efficient handling of surfaces within a model, supporting various</span>
<span class="sd">    operations and analyses.&quot;&quot;&quot;</span>

    <span class="n">order</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="c1"># ---- Constructor ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shell</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a shell from an OCCT TopoDS_Shape/TopoDS_Shell</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (TopoDS_Shape | Face | Iterable[Face], optional): OCCT Shell, Face or Faces.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_list</span> <span class="o">:=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Face</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t create a Shell from empty Face&quot;</span><span class="p">)</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">BRep_Builder</span><span class="p">()</span>
            <span class="n">shell</span> <span class="o">=</span> <span class="n">TopoDS_Shell</span><span class="p">()</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">MakeShell</span><span class="p">(</span><span class="n">shell</span><span class="p">)</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">shell</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">shell</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_sew_topods_faces</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">wrapped</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;volume - the volume of this Shell if manifold, otherwise zero&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_manifold</span><span class="p">:</span>
            <span class="n">solid_shell</span> <span class="o">=</span> <span class="n">ShapeFix_Solid</span><span class="p">()</span><span class="o">.</span><span class="n">SolidFromShell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
            <span class="n">calc_function</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">shape_properties_LUT</span><span class="p">[</span><span class="n">shapetype</span><span class="p">(</span><span class="n">solid_shell</span><span class="p">)]</span>
            <span class="n">calc_function</span><span class="p">(</span><span class="n">solid_shell</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">properties</span><span class="o">.</span><span class="n">Mass</span><span class="p">()</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Shell.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shell.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;extrude</span>

<span class="sd">        Extrude a Wire into a Shell.</span>

<span class="sd">        Args:</span>
<span class="sd">            direction (VectorLike): direction and magnitude of extrusion</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Unsupported class</span>
<span class="sd">            RuntimeError: Generated invalid result</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: extruded shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shell</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Shell_s</span><span class="p">(</span><span class="n">_extrude_topods_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">direction</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Shell.make_loft">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shell.make_loft">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_loft</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">objs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">],</span> <span class="n">ruled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make loft</span>

<span class="sd">        Makes a loft from a list of wires and vertices. Vertices can appear only at the</span>
<span class="sd">        beginning or end of the list, but cannot appear consecutively within the list nor</span>
<span class="sd">        between wires. Wires may be closed or opened.</span>

<span class="sd">        Args:</span>
<span class="sd">            objs (list[Vertex, Wire]): wire perimeters or vertices</span>
<span class="sd">            ruled (bool, optional): stepped or smooth. Defaults to False (smooth).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Too few wires</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shell: Lofted object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_make_loft</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ruled</span><span class="p">))</span></div>


<div class="viewcode-block" id="Shell.sweep">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shell.sweep">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sweep</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">profile</span><span class="p">:</span> <span class="n">Curve</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Curve</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">transition</span><span class="o">=</span><span class="n">Transition</span><span class="o">.</span><span class="n">TRANSFORMED</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sweep</span>

<span class="sd">        Sweep a 1D profile along a 1D path</span>

<span class="sd">        Args:</span>
<span class="sd">            profile (Union[Curve, Edge, Wire]): the object to sweep</span>
<span class="sd">            path (Union[Curve, Edge, Wire]): the path to follow when sweeping</span>
<span class="sd">            transition (Transition, optional): handling of profile orientation at C1 path</span>
<span class="sd">                discontinuities. Defaults to Transition.TRANSFORMED.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shell: resulting Shell, may be non-planar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="o">.</span><span class="n">order_edges</span><span class="p">())</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">BRepOffsetAPI_MakePipeShell</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">SetTransitionMode</span><span class="p">(</span><span class="n">Shape</span><span class="o">.</span><span class="n">_transModeDict</span><span class="p">[</span><span class="n">transition</span><span class="p">])</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Shell.center">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shell.center">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Center of mass of the shell&quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">LinearProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">properties</span><span class="o">.</span><span class="n">CentreOfMass</span><span class="p">())</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">sort_wires_by_build_order</span><span class="p">(</span><span class="n">wire_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Wire</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Wire</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tries to determine how wires should be combined into faces.</span>

<span class="sd">    Assume:</span>
<span class="sd">        The wires make up one or more faces, which could have &#39;holes&#39;</span>
<span class="sd">        Outer wires are listed ahead of inner wires</span>
<span class="sd">        there are no wires inside wires inside wires</span>
<span class="sd">        ( IE, islands -- we can deal with that later on )</span>
<span class="sd">        none of the wires are construction wires</span>

<span class="sd">    Compute:</span>
<span class="sd">        one or more sets of wires, with the outer wire listed first, and inner</span>
<span class="sd">        ones</span>

<span class="sd">    Returns, list of lists.</span>

<span class="sd">    Args:</span>
<span class="sd">      wire_list: list[Wire]:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check if we have something to sort at all</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wire_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">wire_list</span><span class="p">,</span>
        <span class="p">]</span>

    <span class="c1"># make a Face, NB: this might return a compound of faces</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="n">wire_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wire_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="o">.</span><span class="n">faces</span><span class="p">():</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">face</span><span class="o">.</span><span class="n">outer_wire</span><span class="p">(),</span>
            <span class="p">]</span>
            <span class="o">+</span> <span class="n">face</span><span class="o">.</span><span class="n">inner_wires</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gumyr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
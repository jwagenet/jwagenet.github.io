

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>topology.one_d &mdash; build123d 0.9.2.dev40+gb1f0eed documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/sphinx_rtd_theme.css?v=3234e928" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c97902b4"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/js/hoverxref.js"></script>
      <script src="../../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../../_static/js/micromodal.min.js"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            build123d
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_builder.html">Key Concepts (builder mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_algebra.html">Key Concepts (algebra mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../moving_objects.html">Moving Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../OpenSCAD.html">Transitioning from OpenSCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introductory_examples.html">Introductory Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../selectors_operators.html">Selectors and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builders.html">Builders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../assemblies.html">Assemblies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips.html">Tips, Best Practices and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../import_export.html">Import/Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cheat_sheet.html">Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../external.html">External Tools and Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builder_api_reference.html">Builder Common API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../direct_api_reference.html">Direct API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">build123d</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">topology.one_d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for topology.one_d</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">build123d topology</span>

<span class="sd">name: one_d.py</span>
<span class="sd">by:   Gumyr</span>
<span class="sd">date: January 07, 2025</span>

<span class="sd">desc:</span>

<span class="sd">This module defines the classes and methods for one-dimensional geometric entities in the build123d</span>
<span class="sd">CAD library. It focuses on `Edge` and `Wire`, representing essential topological elements like</span>
<span class="sd">curves and connected sequences of curves within a 3D model. These entities are pivotal for</span>
<span class="sd">constructing complex shapes, boundaries, and paths in CAD applications.</span>

<span class="sd">Key Features:</span>
<span class="sd">- **Edge Class**:</span>
<span class="sd">  - Represents curves such as lines, arcs, splines, and circles.</span>
<span class="sd">  - Supports advanced operations like trimming, offsetting, splitting, and projecting onto shapes.</span>
<span class="sd">  - Includes methods for geometric queries like finding tangent angles, normals, and intersection</span>
<span class="sd">    points.</span>

<span class="sd">- **Wire Class**:</span>
<span class="sd">  - Represents a connected sequence of edges forming a continuous path.</span>
<span class="sd">  - Supports operations such as closure, projection, and edge manipulation.</span>

<span class="sd">- **Mixin1D**:</span>
<span class="sd">  - Shared functionality for both `Edge` and `Wire` classes, enabling splitting, extrusion, and</span>
<span class="sd">    1D-specific operations.</span>

<span class="sd">This module integrates deeply with OpenCascade, leveraging its robust geometric and topological</span>
<span class="sd">operations. It provides utility functions to create, manipulate, and query 1D geometric entities,</span>
<span class="sd">ensuring precise and efficient workflows in 3D modeling tasks.</span>

<span class="sd">license:</span>

<span class="sd">    Copyright 2025 Gumyr</span>

<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>

<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">copysign</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">floor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">OCP.TopAbs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRep</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRep_Tool</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAdaptor</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepAdaptor_CompCurve</span><span class="p">,</span> <span class="n">BRepAdaptor_Curve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAlgoAPI</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BRepAlgoAPI_Common</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Section</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Splitter</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepBuilderAPI</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BRepBuilderAPI_DisconnectedWire</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_EmptyWire</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakePolygon</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeWire</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_NonManifoldWire</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepExtrema</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepExtrema_DistShapeShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepFilletAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepFilletAPI_MakeFillet2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepGProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepGProp</span><span class="p">,</span> <span class="n">BRepGProp_Face</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepLib</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepLib</span><span class="p">,</span> <span class="n">BRepLib_FindSurface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepOffset</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepOffset_MakeOffset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepOffsetAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepOffsetAPI_MakeOffset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepPrimAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepPrimAPI_MakeHalfSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepProj</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepProj_Projection</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepTools</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepTools</span><span class="p">,</span> <span class="n">BRepTools_WireExplorer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GC</span><span class="w"> </span><span class="kn">import</span> <span class="n">GC_MakeArcOfCircle</span><span class="p">,</span> <span class="n">GC_MakeArcOfEllipse</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GCPnts</span><span class="w"> </span><span class="kn">import</span> <span class="n">GCPnts_AbscissaPoint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">GProp_GProps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Geom</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Geom_BezierCurve</span><span class="p">,</span>
    <span class="n">Geom_ConicalSurface</span><span class="p">,</span>
    <span class="n">Geom_CylindricalSurface</span><span class="p">,</span>
    <span class="n">Geom_Plane</span><span class="p">,</span>
    <span class="n">Geom_Surface</span><span class="p">,</span>
    <span class="n">Geom_TrimmedCurve</span><span class="p">,</span>
    <span class="n">Geom_Line</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Geom2d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geom2d_Curve</span><span class="p">,</span> <span class="n">Geom2d_Line</span><span class="p">,</span> <span class="n">Geom2d_TrimmedCurve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Geom2dAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geom2dAPI_InterCurveCurve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAPI</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">GeomAPI_IntCS</span><span class="p">,</span>
    <span class="n">GeomAPI_Interpolate</span><span class="p">,</span>
    <span class="n">GeomAPI_PointsToBSpline</span><span class="p">,</span>
    <span class="n">GeomAPI_ProjectPointOnCurve</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAbs</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomAbs_JoinType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAdaptor</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomAdaptor_Curve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomFill</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">GeomFill_CorrectedFrenet</span><span class="p">,</span>
    <span class="n">GeomFill_Frenet</span><span class="p">,</span>
    <span class="n">GeomFill_TrihedronLaw</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.HLRAlgo</span><span class="w"> </span><span class="kn">import</span> <span class="n">HLRAlgo_Projector</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.HLRBRep</span><span class="w"> </span><span class="kn">import</span> <span class="n">HLRBRep_Algo</span><span class="p">,</span> <span class="n">HLRBRep_HLRToShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeAnalysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeAnalysis_FreeBounds</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeFix</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeFix_Shape</span><span class="p">,</span> <span class="n">ShapeFix_Wireframe</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Standard</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Standard_Failure</span><span class="p">,</span>
    <span class="n">Standard_NoSuchObject</span><span class="p">,</span>
    <span class="n">Standard_ConstructionError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TColStd</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TColStd_Array1OfReal</span><span class="p">,</span>
    <span class="n">TColStd_HArray1OfBoolean</span><span class="p">,</span>
    <span class="n">TColStd_HArray1OfReal</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TColgp</span><span class="w"> </span><span class="kn">import</span> <span class="n">TColgp_Array1OfPnt</span><span class="p">,</span> <span class="n">TColgp_Array1OfVec</span><span class="p">,</span> <span class="n">TColgp_HArray1OfPnt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopAbs</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopAbs_Orientation</span><span class="p">,</span> <span class="n">TopAbs_ShapeEnum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopExp</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopExp</span><span class="p">,</span> <span class="n">TopExp_Explorer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopLoc</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopLoc_Location</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopTools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TopTools_HSequenceOfShape</span><span class="p">,</span>
    <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">,</span>
    <span class="n">TopTools_IndexedMapOfShape</span><span class="p">,</span>
    <span class="n">TopTools_ListOfShape</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopoDS</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TopoDS</span><span class="p">,</span>
    <span class="n">TopoDS_Compound</span><span class="p">,</span>
    <span class="n">TopoDS_Edge</span><span class="p">,</span>
    <span class="n">TopoDS_Face</span><span class="p">,</span>
    <span class="n">TopoDS_Shape</span><span class="p">,</span>
    <span class="n">TopoDS_Shell</span><span class="p">,</span>
    <span class="n">TopoDS_Wire</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.gp</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">gp_Ax1</span><span class="p">,</span>
    <span class="n">gp_Ax2</span><span class="p">,</span>
    <span class="n">gp_Ax3</span><span class="p">,</span>
    <span class="n">gp_Circ</span><span class="p">,</span>
    <span class="n">gp_Dir</span><span class="p">,</span>
    <span class="n">gp_Dir2d</span><span class="p">,</span>
    <span class="n">gp_Elips</span><span class="p">,</span>
    <span class="n">gp_Pnt</span><span class="p">,</span>
    <span class="n">gp_Pnt2d</span><span class="p">,</span>
    <span class="n">gp_Trsf</span><span class="p">,</span>
    <span class="n">gp_Vec</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.build_enums</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AngularDirection</span><span class="p">,</span>
    <span class="n">CenterOf</span><span class="p">,</span>
    <span class="n">FrameMethod</span><span class="p">,</span>
    <span class="n">GeomType</span><span class="p">,</span>
    <span class="n">Keep</span><span class="p">,</span>
    <span class="n">Kind</span><span class="p">,</span>
    <span class="n">PositionMode</span><span class="p">,</span>
    <span class="n">Side</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEG2RAD</span><span class="p">,</span>
    <span class="n">TOLERANCE</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">Color</span><span class="p">,</span>
    <span class="n">Location</span><span class="p">,</span>
    <span class="n">Plane</span><span class="p">,</span>
    <span class="n">Vector</span><span class="p">,</span>
    <span class="n">VectorLike</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.shape_core</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">ShapeList</span><span class="p">,</span>
    <span class="n">SkipClean</span><span class="p">,</span>
    <span class="n">TrimmingTool</span><span class="p">,</span>
    <span class="n">downcast</span><span class="p">,</span>
    <span class="n">get_top_level_topods_shapes</span><span class="p">,</span>
    <span class="n">shapetype</span><span class="p">,</span>
    <span class="n">topods_dim</span><span class="p">,</span>
    <span class="n">unwrap_topods_compound</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_extrude_topods_shape</span><span class="p">,</span>
    <span class="n">isclose_b</span><span class="p">,</span>
    <span class="n">_make_topods_face_from_wires</span><span class="p">,</span>
    <span class="n">_topods_bool_op</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.zero_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">topo_explore_common_vertex</span><span class="p">,</span> <span class="n">Vertex</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.two_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Shell</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.three_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Solid</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.composite</span><span class="w"> </span><span class="kn">import</span> <span class="n">Compound</span><span class="p">,</span> <span class="n">Curve</span><span class="p">,</span> <span class="n">Sketch</span><span class="p">,</span> <span class="n">Part</span>  <span class="c1"># pylint: disable=R0801</span>


<div class="viewcode-block" id="Mixin1D">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Mixin1D</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Methods to add to the Edge and Wire classes&quot;&quot;&quot;</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension of Edges and Wires&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Are the start and end points equal?&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t determine if empty Edge or Wire is closed&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">IsClosed_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Does the Edge/Wire loop forward or reverse&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t determine direction of empty Edge or Wire&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Orientation</span><span class="p">()</span> <span class="o">==</span> <span class="n">TopAbs_Orientation</span><span class="o">.</span><span class="n">TopAbs_FORWARD</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_interior</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the edge is an interior edge.</span>

<span class="sd">        An interior edge lies between surfaces that are part of the body (internal</span>
<span class="sd">        to the geometry) and does not form part of the exterior boundary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the edge is an interior edge, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the faces connected to this edge and offset them</span>
        <span class="n">topods_face_pair</span> <span class="o">=</span> <span class="n">topo_explore_connected_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">offset_face_pair</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">offset_topods_face</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">topods_face_pair</span>
        <span class="p">]</span>

        <span class="c1"># Intersect the offset faces</span>
        <span class="n">sectionor</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Section</span><span class="p">(</span>
            <span class="n">offset_face_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset_face_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PerformNow</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">sectionor</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">face_intersection_result</span> <span class="o">=</span> <span class="n">sectionor</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>

        <span class="c1"># If an edge was created the faces intersect and the edge is interior</span>
        <span class="n">explorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">face_intersection_result</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Edge or Wire length&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GCPnts_AbscissaPoint</span><span class="o">.</span><span class="n">Length_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the radius.</span>

<span class="sd">        Note that when applied to a Wire, the radius is simply the radius of the first edge.</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>
<span class="sd">          radius</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: if kernel can not reduce the shape to a circular edge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">circ</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Circle</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">Standard_NoSuchObject</span><span class="p">,</span> <span class="n">Standard_Failure</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape could not be reduced to a circle&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>
        <span class="k">return</span> <span class="n">circ</span><span class="o">.</span><span class="n">Radius</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;volume - the volume of this Edge or Wire, which is always zero&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Mixin1D.cast">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.cast">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">:</span>
        <span class="s2">&quot;Returns the right type of wrapper, given a OCCT object&quot;</span>

        <span class="c1"># Extend the lookup table with additional entries</span>
        <span class="n">constructor_lut</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span>
            <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">shape_type</span> <span class="o">=</span> <span class="n">shapetype</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># NB downcast is needed to handle TopoDS_Shape types</span>
        <span class="k">return</span> <span class="n">constructor_lut</span><span class="p">[</span><span class="n">shape_type</span><span class="p">](</span><span class="n">downcast</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin1D.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unused - only here because Mixin1D is a subclass of Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fuse shape to wire/edge operator +&quot;&quot;&quot;</span>

        <span class="c1"># Convert `other` to list of base topods objects and filter out None values</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">summands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summands</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">shape</span>
                <span class="c1"># for o in (other if isinstance(other, (list, tuple)) else [other])</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="p">([</span><span class="n">other</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="c1"># If there is nothing to add return the original object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">summands</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">topods_dim</span><span class="p">(</span><span class="n">summand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">summand</span> <span class="ow">in</span> <span class="n">summands</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only shapes with the same dimension can be added&quot;</span><span class="p">)</span>

        <span class="c1"># Convert back to Edge/Wire objects now that it&#39;s safe to do so</span>
        <span class="n">summands</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mixin1D</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">summands</span><span class="p">]</span>
        <span class="n">summand_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">summand</span> <span class="ow">in</span> <span class="n">summands</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">summand</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># an empty object</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">summands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">summands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">summand_edges</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">summands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">sum_shape</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">sum_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="o">+</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">summand_edges</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">sum_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">sum_shape</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="c1"># If there is only one Edge, return that</span>
        <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">sum_shape</span><span class="o">.</span><span class="n">edge</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_shape</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">sum_shape</span>

        <span class="k">return</span> <span class="n">sum_shape</span>

<div class="viewcode-block" id="Mixin1D.__matmul__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.__matmul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Position on wire operator @&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">position</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.__mod__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.__mod__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tangent on wire operator %&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="n">position</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Location on wire operator ^&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_at</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

<div class="viewcode-block" id="Mixin1D.center">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.center">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_of</span><span class="p">:</span> <span class="n">CenterOf</span> <span class="o">=</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">GEOMETRY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Center of object</span>

<span class="sd">        Return the center based on center_of</span>

<span class="sd">        Args:</span>
<span class="sd">            center_of (CenterOf, optional): centering option. Defaults to CenterOf.GEOMETRY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">GEOMETRY</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">MASS</span><span class="p">:</span>
            <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
            <span class="n">BRepGProp</span><span class="o">.</span><span class="n">LinearProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">properties</span><span class="o">.</span><span class="n">CentreOfMass</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">BOUNDING_BOX</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">middle</span></div>


<div class="viewcode-block" id="Mixin1D.common_plane">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.common_plane">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">common_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lines</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Plane</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;common_plane</span>

<span class="sd">        Find the plane containing all the edges/wires (including self). If there</span>
<span class="sd">        is no common plane return None. If the edges are coaxial, select one</span>
<span class="sd">        of the infinite number of valid planes.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines (sequence of Edge | Wire): edges in common with self</span>

<span class="sd">        Returns:</span>
<span class="sd">            None |  Plane: Either the common plane or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="c1"># Note: BRepLib_FindSurface is not helpful as it requires the</span>
        <span class="c1"># Edges to form a surface perimeter.</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lines</span><span class="p">]</span> <span class="k">if</span> <span class="n">line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">(</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">all_lines</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only Edges or Wires are valid&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Are they all co-axial - if so, select one of the infinite planes</span>
        <span class="n">all_edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_lines</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">all_edges</span><span class="p">):</span>
            <span class="n">as_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axis</span><span class="p">(</span><span class="n">e</span> <span class="o">@</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">%</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">all_edges</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a0</span><span class="o">.</span><span class="n">is_coaxial</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="k">for</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">as_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">as_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
                <span class="n">x_dir</span> <span class="o">=</span> <span class="n">as_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span>
                <span class="n">z_dir</span> <span class="o">=</span> <span class="n">as_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">x_dir</span>
                <span class="n">c_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">z_dir</span><span class="o">=</span><span class="n">z_dir</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">c_plane</span><span class="o">.</span><span class="n">shift_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># not coaxial</span>
            <span class="c1"># Shorten any infinite lines (from converted Axis)</span>
            <span class="n">normal_lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="mf">1e50</span><span class="p">,</span> <span class="n">all_lines</span><span class="p">))</span>
            <span class="n">infinite_lines</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mf">1e50</span><span class="p">,</span> <span class="n">all_lines</span><span class="p">)</span>
            <span class="n">shortened_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">trim_to_length</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">infinite_lines</span><span class="p">]</span>
            <span class="n">all_lines</span> <span class="o">=</span> <span class="n">normal_lines</span> <span class="o">+</span> <span class="n">shortened_lines</span>

            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">all_lines</span><span class="p">:</span>
                <span class="n">num_points</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span> <span class="k">else</span> <span class="mi">8</span>
                <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">)]</span>
                <span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>  <span class="c1"># unique points</span>
            <span class="n">extreme_areas</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">vector1</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vector2</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">area</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">vector1</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                <span class="n">extreme_areas</span><span class="p">[</span><span class="n">area</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span>
            <span class="c1"># The points that create the largest area make the most accurate plane</span>
            <span class="n">extremes</span> <span class="o">=</span> <span class="n">extreme_areas</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">extreme_areas</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># Create a plane from these points</span>
            <span class="n">x_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">extremes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extremes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
            <span class="n">z_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">extremes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">extremes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x_dir</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span>
                    <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">extremes</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">3</span><span class="p">),</span> <span class="n">z_dir</span><span class="o">=</span><span class="n">z_dir</span>
                <span class="p">)</span>
                <span class="n">c_plane</span> <span class="o">=</span> <span class="n">c_plane</span><span class="o">.</span><span class="n">shift_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># There is no valid common plane</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Are all of the points on the common plane</span>
                <span class="n">common</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">c_plane</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">c_plane</span> <span class="k">if</span> <span class="n">common</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Mixin1D.edge">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Edge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_single_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;edges - all the edges in this Shape&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Wire</span><span class="p">):</span>
            <span class="c1"># The WireExplorer is a tool to explore the edges of a wire in a connection order.</span>
            <span class="n">explorer</span> <span class="o">=</span> <span class="n">BRepTools_WireExplorer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

            <span class="n">edge_list</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
                <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">explorer</span><span class="o">.</span><span class="n">Current</span><span class="p">()))</span>
                <span class="n">explorer</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">edge_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">edge_list</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Degenerated_s</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.end_point">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.end_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">end_point</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The end point of this edge.</span>

<span class="sd">        Note that circles may have identical start and end points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
        <span class="n">umax</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">LastParameter</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">umax</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin1D.location_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.location_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">location_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span>
        <span class="n">frame_method</span><span class="p">:</span> <span class="n">FrameMethod</span> <span class="o">=</span> <span class="n">FrameMethod</span><span class="o">.</span><span class="n">FRENET</span><span class="p">,</span>
        <span class="n">planar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">x_dir</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locations along curve</span>

<span class="sd">        Generate a location along the underlying curve.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance (float): distance or parameter value</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode.</span>
<span class="sd">                Defaults to PositionMode.PARAMETER.</span>
<span class="sd">            frame_method (FrameMethod, optional): moving frame calculation method.</span>
<span class="sd">                The FRENET frame can twist or flip unexpectedly, especially near flat</span>
<span class="sd">                spots. The CORRECTED frame behaves more like a camera dolly or</span>
<span class="sd">                sweep profile would  it&#39;s smoother and more stable.</span>
<span class="sd">                Defaults to FrameMethod.FRENET.</span>
<span class="sd">            planar (bool, optional): planar mode. Defaults to None.</span>
<span class="sd">            x_dir (VectorLike, optional): override the x_dir to help with plane</span>
<span class="sd">                creation along a 1D shape. Must be perpendicalar to shapes tangent.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        .. deprecated::</span>
<span class="sd">            The `planar` parameter is deprecated and will be removed in a future release.</span>
<span class="sd">            Use `x_dir` to specify orientation instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Location: A Location object representing local coordinate system</span>
<span class="sd">                at the specified distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">position_mode</span> <span class="o">==</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="n">law</span><span class="p">:</span> <span class="n">GeomFill_TrihedronLaw</span>
        <span class="k">if</span> <span class="n">frame_method</span> <span class="o">==</span> <span class="n">FrameMethod</span><span class="o">.</span><span class="n">FRENET</span><span class="p">:</span>
            <span class="n">law</span> <span class="o">=</span> <span class="n">GeomFill_Frenet</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">law</span> <span class="o">=</span> <span class="n">GeomFill_CorrectedFrenet</span><span class="p">()</span>

        <span class="n">law</span><span class="o">.</span><span class="n">SetCurve</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>

        <span class="n">tangent</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">binormal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">(),</span> <span class="n">gp_Vec</span><span class="p">(),</span> <span class="n">gp_Vec</span><span class="p">()</span>

        <span class="n">law</span><span class="o">.</span><span class="n">D0</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">tangent</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">binormal</span><span class="p">)</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

        <span class="n">transformation</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">planar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;planar&#39; parameter is deprecated and will be removed in a future version. &quot;</span>
                <span class="s2">&quot;Use &#39;x_dir&#39; to control orientation instead.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">planar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">planar</span><span class="p">:</span>
            <span class="n">transformation</span><span class="o">.</span><span class="n">SetTransformation</span><span class="p">(</span>
                <span class="n">gp_Ax3</span><span class="p">(</span><span class="n">pnt</span><span class="p">,</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">XYZ</span><span class="p">())),</span> <span class="n">gp_Ax3</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>

                <span class="n">transformation</span><span class="o">.</span><span class="n">SetTransformation</span><span class="p">(</span>
                    <span class="n">gp_Ax3</span><span class="p">(</span><span class="n">pnt</span><span class="p">,</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="n">tangent</span><span class="o">.</span><span class="n">XYZ</span><span class="p">()),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">x_dir</span><span class="p">)</span><span class="o">.</span><span class="n">to_dir</span><span class="p">()),</span> <span class="n">gp_Ax3</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">Standard_ConstructionError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to create location with given x_dir </span><span class="si">{</span><span class="n">x_dir</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;x_dir must be perpendicular to shape&#39;s tangent &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">tangent</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformation</span><span class="o">.</span><span class="n">SetTransformation</span><span class="p">(</span>
                <span class="n">gp_Ax3</span><span class="p">(</span><span class="n">pnt</span><span class="p">,</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="n">tangent</span><span class="o">.</span><span class="n">XYZ</span><span class="p">()),</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">XYZ</span><span class="p">())),</span> <span class="n">gp_Ax3</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="n">TopLoc_Location</span><span class="p">(</span><span class="n">transformation</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">loc</span></div>


<div class="viewcode-block" id="Mixin1D.locations">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.locations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">locations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span>
        <span class="n">frame_method</span><span class="p">:</span> <span class="n">FrameMethod</span> <span class="o">=</span> <span class="n">FrameMethod</span><span class="o">.</span><span class="n">FRENET</span><span class="p">,</span>
        <span class="n">planar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">x_dir</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locations along curve</span>

<span class="sd">        Generate location along the curve</span>

<span class="sd">        Args:</span>
<span class="sd">            distances (Iterable[float]): distance or parameter values</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode.</span>
<span class="sd">                Defaults to PositionMode.PARAMETER.</span>
<span class="sd">            frame_method (FrameMethod, optional): moving frame calculation method.</span>
<span class="sd">                Defaults to FrameMethod.FRENET.</span>
<span class="sd">            planar (bool, optional): planar mode. Defaults to False.</span>
<span class="sd">            x_dir (VectorLike, optional): override the x_dir to help with plane</span>
<span class="sd">                creation along a 1D shape. Must be perpendicalar to shapes tangent.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        .. deprecated::</span>
<span class="sd">            The `planar` parameter is deprecated and will be removed in a future release.</span>
<span class="sd">            Use `x_dir` to specify orientation instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Location]: A list of Location objects representing local coordinate</span>
<span class="sd">                systems at the specified distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location_at</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">position_mode</span><span class="p">,</span> <span class="n">frame_method</span><span class="p">,</span> <span class="n">planar</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distances</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="Mixin1D.normal">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the normal Vector. Only possible for planar curves.</span>

<span class="sd">        :return: normal vector</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
        <span class="n">gtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span>

        <span class="k">if</span> <span class="n">gtype</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CIRCLE</span><span class="p">:</span>
            <span class="n">circ</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">Circle</span><span class="p">()</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">Axis</span><span class="p">()</span><span class="o">.</span><span class="n">Direction</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">gtype</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">ELLIPSE</span><span class="p">:</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">Ellipse</span><span class="p">()</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ell</span><span class="o">.</span><span class="n">Axis</span><span class="p">()</span><span class="o">.</span><span class="n">Direction</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">find_surface</span> <span class="o">=</span> <span class="n">BRepLib_FindSurface</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">OnlyPlane</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">find_surface</span><span class="o">.</span><span class="n">Surface</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">Geom_Plane</span><span class="p">):</span>
                <span class="n">pln</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">Pln</span><span class="p">()</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">pln</span><span class="o">.</span><span class="n">Axis</span><span class="p">()</span><span class="o">.</span><span class="n">Direction</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normal not defined&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Mixin1D.offset_2d">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.offset_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Kind</span><span class="o">.</span><span class="n">ARC</span><span class="p">,</span>
        <span class="n">side</span><span class="p">:</span> <span class="n">Side</span> <span class="o">=</span> <span class="n">Side</span><span class="o">.</span><span class="n">BOTH</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2d Offset</span>

<span class="sd">        Offsets a planar edge/wire</span>

<span class="sd">        Args:</span>
<span class="sd">            distance (float): distance from edge/wire to offset</span>
<span class="sd">            kind (Kind, optional): offset corner transition. Defaults to Kind.ARC.</span>
<span class="sd">            side (Side, optional): side to place offset. Defaults to Side.BOTH.</span>
<span class="sd">            closed (bool, optional): if Side!=BOTH, close the LEFT or RIGHT</span>
<span class="sd">                offset. Defaults to True.</span>
<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Multiple Wires generated</span>
<span class="sd">            RuntimeError: Unexpected result type</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: offset wire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-branches, too-many-locals, too-many-statements</span>
        <span class="n">kind_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Kind</span><span class="o">.</span><span class="n">ARC</span><span class="p">:</span> <span class="n">GeomAbs_JoinType</span><span class="o">.</span><span class="n">GeomAbs_Arc</span><span class="p">,</span>
            <span class="n">Kind</span><span class="o">.</span><span class="n">INTERSECTION</span><span class="p">:</span> <span class="n">GeomAbs_JoinType</span><span class="o">.</span><span class="n">GeomAbs_Intersection</span><span class="p">,</span>
            <span class="n">Kind</span><span class="o">.</span><span class="n">TANGENT</span><span class="p">:</span> <span class="n">GeomAbs_JoinType</span><span class="o">.</span><span class="n">GeomAbs_Tangent</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Wire</span><span class="p">)</span> <span class="k">else</span> <span class="n">Wire</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>

        <span class="c1"># Avoiding a bug when the wire contains a single Edge</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">edge</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]</span>
            <span class="n">topods_wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">topods_wire</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">wrapped</span>

        <span class="n">offset_builder</span> <span class="o">=</span> <span class="n">BRepOffsetAPI_MakeOffset</span><span class="p">()</span>
        <span class="n">offset_builder</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">kind_dict</span><span class="p">[</span><span class="n">kind</span><span class="p">])</span>
        <span class="c1"># offset_builder.SetApprox(True)</span>
        <span class="n">offset_builder</span><span class="o">.</span><span class="n">AddWire</span><span class="p">(</span><span class="n">topods_wire</span><span class="p">)</span>
        <span class="n">offset_builder</span><span class="o">.</span><span class="n">Perform</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">offset_builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">unwrap_topods_compound</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">fully</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">TopoDS_Wire</span><span class="p">):</span>
            <span class="n">offset_wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Likely multiple Wires were generated</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unexpected result type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">!=</span> <span class="n">Side</span><span class="o">.</span><span class="n">BOTH</span><span class="p">:</span>
            <span class="c1"># Find and remove the end arcs</span>
            <span class="n">offset_edges</span> <span class="o">=</span> <span class="n">offset_wire</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="n">edges_to_keep</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">offset_edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CIRCLE</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">arc_center</span> <span class="o">==</span> <span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">edge</span><span class="o">.</span><span class="n">arc_center</span> <span class="o">==</span> <span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edges_to_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">edges_to_keep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">edges_to_keep</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">wires</span> <span class="o">=</span> <span class="p">[</span><span class="n">Wire</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">edges_to_keep</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wires</span><span class="p">]</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">line</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">get_signed_angle</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">centers</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="n">Side</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span>
                <span class="n">offset_wire</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset_wire</span> <span class="o">=</span> <span class="n">wires</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

            <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
                <span class="n">self0</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">self1</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">end0</span> <span class="o">=</span> <span class="n">offset_wire</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">end1</span> <span class="o">=</span> <span class="n">offset_wire</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">self0</span> <span class="o">-</span> <span class="n">end0</span><span class="p">)</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOLERANCE</span><span class="p">:</span>
                    <span class="n">edge0</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">self0</span><span class="p">,</span> <span class="n">end0</span><span class="p">)</span>
                    <span class="n">edge1</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">self1</span><span class="p">,</span> <span class="n">end1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge0</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">self0</span><span class="p">,</span> <span class="n">end1</span><span class="p">)</span>
                    <span class="n">edge1</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">self1</span><span class="p">,</span> <span class="n">end0</span><span class="p">)</span>
                <span class="n">offset_wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset_wire</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="o">+</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">edge0</span><span class="p">,</span> <span class="n">edge1</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="n">offset_edges</span> <span class="o">=</span> <span class="n">offset_wire</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">offset_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">offset_wire</span></div>


<div class="viewcode-block" id="Mixin1D.param_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.param_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameter along a curve</span>

<span class="sd">        Compute parameter value at the specified normalized distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            d (float): normalized distance (0.0 &gt;= d &gt;= 1.0)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: parameter value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>

        <span class="n">length</span> <span class="o">=</span> <span class="n">GCPnts_AbscissaPoint</span><span class="o">.</span><span class="n">Length_s</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GCPnts_AbscissaPoint</span><span class="p">(</span>
            <span class="n">curve</span><span class="p">,</span> <span class="n">length</span> <span class="o">*</span> <span class="n">distance</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="n">FirstParameter</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">Parameter</span><span class="p">()</span></div>


<div class="viewcode-block" id="Mixin1D.perpendicular_line">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.perpendicular_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">perpendicular_line</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">u_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;perpendicular_line</span>

<span class="sd">        Create a line on the given plane perpendicular to and centered on beginning of self</span>

<span class="sd">        Args:</span>
<span class="sd">            length (float): line length</span>
<span class="sd">            u_value (float): position along line between 0.0 and 1.0</span>
<span class="sd">            plane (Plane, optional): plane containing perpendicular line. Defaults to Plane.XY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: perpendicular line</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">u_value</span><span class="p">)</span>
        <span class="n">local_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="n">u_value</span><span class="p">),</span> <span class="n">z_dir</span><span class="o">=</span><span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span>
        <span class="p">)</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span>
            <span class="n">start</span> <span class="o">+</span> <span class="n">local_plane</span><span class="o">.</span><span class="n">y_dir</span> <span class="o">*</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">start</span> <span class="o">-</span> <span class="n">local_plane</span><span class="o">.</span><span class="n">y_dir</span> <span class="o">*</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">line</span></div>


<div class="viewcode-block" id="Mixin1D.position_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.position_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">position_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Position At</span>

<span class="sd">        Generate a position along the underlying curve.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance (float): distance or parameter value</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode. Defaults to</span>
<span class="sd">                PositionMode.PARAMETER.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: position on the underlying curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">position_mode</span> <span class="o">==</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">param</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin1D.positions">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.positions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">positions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Positions along curve</span>

<span class="sd">        Generate positions along the underlying curve</span>

<span class="sd">        Args:</span>
<span class="sd">            distances (Iterable[float]): distance or parameter values</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode.</span>
<span class="sd">                Defaults to PositionMode.PARAMETER.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Vector]: positions along curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">position_mode</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">]</span></div>


<div class="viewcode-block" id="Mixin1D.project">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.project">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">:</span> <span class="n">Face</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">closest</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project onto a face along the specified direction</span>

<span class="sd">        Args:</span>
<span class="sd">          face: Face:</span>
<span class="sd">          direction: VectorLike:</span>
<span class="sd">          closest: bool:  (Default value = True)</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t project an empty Edge or Wire&quot;</span><span class="p">)</span>

        <span class="n">bldr</span> <span class="o">=</span> <span class="n">BRepProj_Projection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">face</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="o">.</span><span class="n">to_dir</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">TopoDS_Compound</span> <span class="o">=</span> <span class="n">bldr</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>

        <span class="c1"># select the closest projection if requested</span>
        <span class="n">return_value</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">closest</span><span class="p">:</span>
            <span class="n">dist_calc</span> <span class="o">=</span> <span class="n">BRepExtrema_DistShapeShape</span><span class="p">()</span>
            <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">inf</span>

            <span class="c1"># for shape in shapes:</span>
            <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS2</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">dist_calc</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_calc</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span>
                    <span class="n">return_value</span> <span class="o">=</span> <span class="n">Mixin1D</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
                <span class="n">Mixin1D</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Mixin1D.project_to_viewport">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.project_to_viewport">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_to_viewport</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">viewport_origin</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span>
        <span class="n">viewport_up</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">look_at</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;project_to_viewport</span>

<span class="sd">        Project a shape onto a viewport returning visible and hidden Edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            viewport_origin (VectorLike): location of viewport</span>
<span class="sd">            viewport_up (VectorLike, optional): direction of the viewport y axis.</span>
<span class="sd">                Defaults to (0, 0, 1).</span>
<span class="sd">            look_at (VectorLike, optional): point to look at.</span>
<span class="sd">                Defaults to None (center of shape).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[ShapeList[Edge],ShapeList[Edge]]: visible &amp; hidden Edges</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">extract_edges</span><span class="p">(</span><span class="n">compound</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the extracted edges</span>

            <span class="c1"># Create a TopExp_Explorer to traverse the sub-shapes of the compound</span>
            <span class="n">explorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">compound</span><span class="p">,</span> <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">)</span>

            <span class="c1"># Loop through the sub-shapes and extract edges</span>
            <span class="k">while</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">explorer</span><span class="o">.</span><span class="n">Current</span><span class="p">())</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="n">explorer</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">edges</span>

        <span class="c1"># Setup the projector</span>
        <span class="n">hidden_line_removal</span> <span class="o">=</span> <span class="n">HLRBRep_Algo</span><span class="p">()</span>
        <span class="n">hidden_line_removal</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="n">viewport_origin</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">viewport_origin</span><span class="p">)</span>
        <span class="n">look_at</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">look_at</span><span class="p">)</span> <span class="k">if</span> <span class="n">look_at</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="n">projection_dir</span><span class="p">:</span> <span class="n">Vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">viewport_origin</span> <span class="o">-</span> <span class="n">look_at</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">viewport_up</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">viewport_up</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">camera_coordinate_system</span> <span class="o">=</span> <span class="n">gp_Ax2</span><span class="p">()</span>
        <span class="n">camera_coordinate_system</span><span class="o">.</span><span class="n">SetAxis</span><span class="p">(</span>
            <span class="n">gp_Ax1</span><span class="p">(</span><span class="n">viewport_origin</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">projection_dir</span><span class="o">.</span><span class="n">to_dir</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">camera_coordinate_system</span><span class="o">.</span><span class="n">SetYDirection</span><span class="p">(</span><span class="n">viewport_up</span><span class="o">.</span><span class="n">to_dir</span><span class="p">())</span>
        <span class="n">projector</span> <span class="o">=</span> <span class="n">HLRAlgo_Projector</span><span class="p">(</span><span class="n">camera_coordinate_system</span><span class="p">)</span>

        <span class="n">hidden_line_removal</span><span class="o">.</span><span class="n">Projector</span><span class="p">(</span><span class="n">projector</span><span class="p">)</span>
        <span class="n">hidden_line_removal</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">hidden_line_removal</span><span class="o">.</span><span class="n">Hide</span><span class="p">()</span>

        <span class="n">hlr_shapes</span> <span class="o">=</span> <span class="n">HLRBRep_HLRToShape</span><span class="p">(</span><span class="n">hidden_line_removal</span><span class="p">)</span>

        <span class="c1"># Create the visible edges</span>
        <span class="n">visible_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">VCompound</span><span class="p">(),</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">Rg1LineVCompound</span><span class="p">(),</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">OutLineVCompound</span><span class="p">(),</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="o">.</span><span class="n">IsNull</span><span class="p">():</span>
                <span class="n">visible_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>

        <span class="c1"># Create the hidden edges</span>
        <span class="n">hidden_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">HCompound</span><span class="p">(),</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">OutLineHCompound</span><span class="p">(),</span>
            <span class="n">hlr_shapes</span><span class="o">.</span><span class="n">Rg1LineHCompound</span><span class="p">(),</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="o">.</span><span class="n">IsNull</span><span class="p">():</span>
                <span class="n">hidden_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>

        <span class="c1"># Fix the underlying geometry - otherwise we will get segfaults</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">visible_edges</span><span class="p">:</span>
            <span class="n">BRepLib</span><span class="o">.</span><span class="n">BuildCurves3d_s</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hidden_edges</span><span class="p">:</span>
            <span class="n">BRepLib</span><span class="o">.</span><span class="n">BuildCurves3d_s</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">)</span>

        <span class="c1"># convert to native shape objects</span>
        <span class="n">visible_edges</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">visible_edges</span><span class="p">)</span>
        <span class="n">hidden_edges</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hidden_edges</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">visible_edges</span><span class="p">,</span> <span class="n">hidden_edges</span><span class="p">)</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">TrimmingTool</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Keep</span><span class="o">.</span><span class="n">TOP</span><span class="p">,</span> <span class="n">Keep</span><span class="o">.</span><span class="n">BOTTOM</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split and keep inside or outside&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">TrimmingTool</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Keep</span><span class="o">.</span><span class="n">ALL</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split and return the unordered pieces&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">TrimmingTool</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">Self</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Self</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split and keep inside and outside&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">TrimmingTool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split and keep inside (default)&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Mixin1D.split">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.split">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">TrimmingTool</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Keep</span> <span class="o">=</span> <span class="n">Keep</span><span class="o">.</span><span class="n">TOP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split</span>

<span class="sd">        Split this shape by the provided plane or face.</span>

<span class="sd">        Args:</span>
<span class="sd">            surface (Plane | Face): surface to segment shape</span>
<span class="sd">            keep (Keep, optional): which object(s) to save. Defaults to Keep.TOP.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: result of split</span>
<span class="sd">        Returns:</span>
<span class="sd">            Self | list[Self] | None,</span>
<span class="sd">            Tuple[Self | list[Self] | None]: The result of the split operation.</span>

<span class="sd">            - **Keep.TOP**: Returns the top as a `Self` or `list[Self]`, or `None`</span>
<span class="sd">              if no top is found.</span>
<span class="sd">            - **Keep.BOTTOM**: Returns the bottom as a `Self` or `list[Self]`, or `None`</span>
<span class="sd">              if no bottom is found.</span>
<span class="sd">            - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is</span>
<span class="sd">              either a `Self` or `list[Self]`, or `None` if no corresponding part is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape_list</span> <span class="o">=</span> <span class="n">TopTools_ListOfShape</span><span class="p">()</span>
        <span class="n">shape_list</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="c1"># Define the splitting tool</span>
        <span class="n">trim_tool</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Face</span><span class="p">()</span>  <span class="c1"># Plane to Face</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">Plane</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">tool</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="p">)</span>
        <span class="n">tool_list</span> <span class="o">=</span> <span class="n">TopTools_ListOfShape</span><span class="p">()</span>
        <span class="n">tool_list</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">trim_tool</span><span class="p">)</span>

        <span class="c1"># Create the splitter algorithm</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Splitter</span><span class="p">()</span>

        <span class="c1"># Set the shape to be split and the splitting tool (plane face)</span>
        <span class="n">splitter</span><span class="o">.</span><span class="n">SetArguments</span><span class="p">(</span><span class="n">shape_list</span><span class="p">)</span>
        <span class="n">splitter</span><span class="o">.</span><span class="n">SetTools</span><span class="p">(</span><span class="n">tool_list</span><span class="p">)</span>

        <span class="c1"># Perform the splitting operation</span>
        <span class="n">splitter</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="n">split_result</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">splitter</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="c1"># Remove unnecessary TopoDS_Compound around single shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">split_result</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
            <span class="n">split_result</span> <span class="o">=</span> <span class="n">unwrap_topods_compound</span><span class="p">(</span><span class="n">split_result</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># For speed the user may just want all the objects which they</span>
        <span class="c1"># can sort more efficiently then the generic algorithm below</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">split_result</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
            <span class="c1"># Get a TopoDS_Face to work with from the tool</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trim_tool</span><span class="p">,</span> <span class="n">TopoDS_Shell</span><span class="p">):</span>
                <span class="n">faceExplorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">trim_tool</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">)</span>
                <span class="n">tool_face</span> <span class="o">=</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Face_s</span><span class="p">(</span><span class="n">faceExplorer</span><span class="o">.</span><span class="n">Current</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tool_face</span> <span class="o">=</span> <span class="n">trim_tool</span>

            <span class="c1"># Create a reference point off the +ve side of the tool</span>
            <span class="n">surface_point</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
            <span class="n">surface_normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
            <span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span><span class="p">,</span> <span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span> <span class="o">=</span> <span class="n">BRepTools</span><span class="o">.</span><span class="n">UVBounds_s</span><span class="p">(</span><span class="n">tool_face</span><span class="p">)</span>
            <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="n">tool_face</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span>
                <span class="p">(</span><span class="n">u_min</span> <span class="o">+</span> <span class="n">u_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">v_min</span> <span class="o">+</span> <span class="n">v_max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">surface_point</span><span class="p">,</span> <span class="n">surface_normal</span>
            <span class="p">)</span>
            <span class="n">normalized_surface_normal</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span>
                <span class="n">surface_normal</span><span class="o">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">surface_normal</span><span class="o">.</span><span class="n">Y</span><span class="p">(),</span> <span class="n">surface_normal</span><span class="o">.</span><span class="n">Z</span><span class="p">()</span>
            <span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
            <span class="n">surface_point</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">surface_point</span><span class="p">)</span>
            <span class="n">ref_point</span> <span class="o">=</span> <span class="n">surface_point</span> <span class="o">+</span> <span class="n">normalized_surface_normal</span>

            <span class="c1"># Create a HalfSpace - Solidish object to determine top/bottom</span>
            <span class="n">halfSpaceMaker</span> <span class="o">=</span> <span class="n">BRepPrimAPI_MakeHalfSpace</span><span class="p">(</span><span class="n">trim_tool</span><span class="p">,</span> <span class="n">ref_point</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>
            <span class="n">tool_solid</span> <span class="o">=</span> <span class="n">halfSpaceMaker</span><span class="o">.</span><span class="n">Solid</span><span class="p">()</span>

        <span class="n">tops</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bottoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">split_result</span><span class="p">):</span>
            <span class="n">sub_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
                <span class="n">is_up</span> <span class="o">=</span> <span class="n">tool</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">sub_shape</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Intersect self and the thickened tool</span>
                <span class="n">is_up_obj</span> <span class="o">=</span> <span class="n">_topods_bool_op</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">part</span><span class="p">,),</span> <span class="p">(</span><span class="n">tool_solid</span><span class="p">,),</span> <span class="n">BRepAlgoAPI_Common</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="c1"># Check for valid intersections</span>
                <span class="n">BRepGProp</span><span class="o">.</span><span class="n">LinearProperties_s</span><span class="p">(</span><span class="n">is_up_obj</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
                <span class="c1"># Mass represents the total length for linear properties</span>
                <span class="n">is_up</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">Mass</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">TOLERANCE</span>
            <span class="p">(</span><span class="n">tops</span> <span class="k">if</span> <span class="n">is_up</span> <span class="k">else</span> <span class="n">bottoms</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_shape</span><span class="p">)</span>

        <span class="n">top</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tops</span> <span class="k">else</span> <span class="n">tops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">tops</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">bottoms</span> <span class="k">else</span> <span class="n">bottoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bottoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">bottoms</span>

        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">TOP</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">top</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">BOTTOM</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bottom</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Mixin1D.start_point">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.start_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_point</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The start point of this edge</span>

<span class="sd">        Note that circles may have identical start and end points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
        <span class="n">umin</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">FirstParameter</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">umin</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin1D.tangent_angle_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.tangent_angle_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tangent_angle_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">location_param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tangent_angle_at</span>

<span class="sd">        Compute the tangent angle at the specified location</span>

<span class="sd">        Args:</span>
<span class="sd">            location_param (float, optional): distance or parameter value. Defaults to 0.5.</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode.</span>
<span class="sd">                Defaults to PositionMode.PARAMETER.</span>
<span class="sd">            plane (Plane, optional): plane line was constructed on. Defaults to Plane.XY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: angle in degrees between 0 and 360</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tan_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="n">location_param</span><span class="p">,</span> <span class="n">position_mode</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">x_dir</span><span class="o">.</span><span class="n">get_signed_angle</span><span class="p">(</span><span class="n">tan_vector</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>
        <span class="k">return</span> <span class="n">angle</span></div>


<div class="viewcode-block" id="Mixin1D.tangent_at">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.tangent_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tangent_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">position_mode</span><span class="p">:</span> <span class="n">PositionMode</span> <span class="o">=</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tangent_at</span>

<span class="sd">        Find the tangent at a given position on the 1D shape where the position</span>
<span class="sd">        is either a float (or int) parameter or a point that lies on the shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            position (float |  VectorLike): distance, parameter value, or</span>
<span class="sd">                point on shape. Defaults to 0.5.</span>
<span class="sd">            position_mode (PositionMode, optional): position calculation mode.</span>
<span class="sd">                Defaults to PositionMode.PARAMETER.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: invalid position</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: tangent value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">position_mode</span> <span class="o">==</span> <span class="n">PositionMode</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">:</span>
                <span class="n">parameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">position</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pnt</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position must be a float or a point&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>
            <span class="c1"># GeomAPI_ProjectPointOnCurve only works with Edges so find</span>
            <span class="c1"># the closest Edge if the shape has multiple Edges.</span>
            <span class="n">my_edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">pnt</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_edges</span><span class="p">)]</span>
            <span class="n">sorted_distances</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">closest_edge</span> <span class="o">=</span> <span class="n">my_edges</span><span class="p">[</span><span class="n">sorted_distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># Get the extreme of the parameter values for this Edge</span>
            <span class="n">first</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">closest_edge</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">last</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">closest_edge</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Extract the Geom_Curve from the Shape</span>
            <span class="n">curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Curve_s</span><span class="p">(</span><span class="n">closest_edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">projector</span> <span class="o">=</span> <span class="n">GeomAPI_ProjectPointOnCurve</span><span class="p">(</span><span class="n">pnt</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">curve</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">projector</span><span class="o">.</span><span class="n">LowerDistanceParameter</span><span class="p">()</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
        <span class="n">curve</span><span class="o">.</span><span class="n">D1</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">gp_Dir</span><span class="p">(</span><span class="n">res</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mixin1D.vertex">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Vertex&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_single_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.vertices">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;vertices - all the vertices in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Wire&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_single_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mixin1D.wires">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Mixin1D.wires">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wires</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wires - all the wires in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Edge">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Edge</span><span class="p">(</span><span class="n">Mixin1D</span><span class="p">,</span> <span class="n">Shape</span><span class="p">[</span><span class="n">TopoDS_Edge</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An Edge in build123d is a fundamental element in the topological data structure</span>
<span class="sd">    representing a one-dimensional geometric entity within a 3D model. It encapsulates</span>
<span class="sd">    information about a curve, which could be a line, arc, or other parametrically</span>
<span class="sd">    defined shape. Edge is crucial in for precise modeling and manipulation of curves,</span>
<span class="sd">    facilitating operations like filleting, chamfering, and Boolean operations. It</span>
<span class="sd">    serves as a building block for constructing complex structures, such as wires</span>
<span class="sd">    and faces.&quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-public-methods</span>

    <span class="n">order</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># ---- Constructor ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Edge</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build an Edge from an OCCT TopoDS_Shape/TopoDS_Edge</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (TopoDS_Edge | Axis, optional): OCCT Edge or Axis.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span>
                <span class="n">Geom_Line</span><span class="p">(</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">to_dir</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">arc_center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;center of an underlying circle or ellipse geometry.&quot;&quot;&quot;</span>

        <span class="n">geom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span>
        <span class="n">geom_adaptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CIRCLE</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">geom_adaptor</span><span class="o">.</span><span class="n">Circle</span><span class="p">()</span><span class="o">.</span><span class="n">Position</span><span class="p">()</span><span class="o">.</span><span class="n">Location</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">ELLIPSE</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">geom_adaptor</span><span class="o">.</span><span class="n">Ellipse</span><span class="p">()</span><span class="o">.</span><span class="n">Position</span><span class="p">()</span><span class="o">.</span><span class="n">Location</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">geom_type</span><span class="si">}</span><span class="s2"> has no arc center&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_value</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Edge.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;extrude</span>

<span class="sd">        Extrude a Vertex into an Edge.</span>

<span class="sd">        Args:</span>
<span class="sd">            direction (VectorLike): direction and magnitude of extrusion</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Unsupported class</span>
<span class="sd">            RuntimeError: Generated invalid result</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: extruded shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">_extrude_topods_shape</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">direction</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Edge.make_bezier">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_bezier">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_bezier</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">cntl_pnts</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_bezier</span>

<span class="sd">        Create a rational (with weights) or non-rational bezier curve.  The first and last</span>
<span class="sd">        control points represent the start and end of the curve respectively.  If weights</span>
<span class="sd">        are provided, there must be one provided for each control point.</span>

<span class="sd">        Args:</span>
<span class="sd">            cntl_pnts (sequence[VectorLike]): points defining the curve</span>
<span class="sd">            weights (list[float], optional): control point weights list. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Too few control points</span>
<span class="sd">            ValueError: Too many control points</span>
<span class="sd">            ValueError: A weight is required for each control point</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: bezier curve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cntl_pnts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;At least two control points must be provided (start, end)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cntl_pnts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The maximum number of control points is 25&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cntl_pnts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A weight must be provided for each control point&quot;</span><span class="p">)</span>

        <span class="n">cntl_gp_pnts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector</span><span class="p">(</span><span class="n">cntl_pnt</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">()</span> <span class="k">for</span> <span class="n">cntl_pnt</span> <span class="ow">in</span> <span class="n">cntl_pnts</span><span class="p">]</span>

        <span class="c1"># The poles are stored in an OCCT Array object</span>
        <span class="n">poles</span> <span class="o">=</span> <span class="n">TColgp_Array1OfPnt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cntl_gp_pnts</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cntl_gp_pnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cntl_gp_pnts</span><span class="p">):</span>
            <span class="n">poles</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cntl_gp_pnt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">pole_weights</span> <span class="o">=</span> <span class="n">TColStd_Array1OfReal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="n">pole_weights</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span>
            <span class="n">bezier_curve</span> <span class="o">=</span> <span class="n">Geom_BezierCurve</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">pole_weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bezier_curve</span> <span class="o">=</span> <span class="n">Geom_BezierCurve</span><span class="p">(</span><span class="n">poles</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">bezier_curve</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span></div>


<div class="viewcode-block" id="Edge.make_circle">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_circle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_circle</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
        <span class="n">start_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">end_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">360</span><span class="p">,</span>
        <span class="n">angular_direction</span><span class="p">:</span> <span class="n">AngularDirection</span> <span class="o">=</span> <span class="n">AngularDirection</span><span class="o">.</span><span class="n">COUNTER_CLOCKWISE</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make circle</span>

<span class="sd">        Create a circle centered on the origin of plane</span>

<span class="sd">        Args:</span>
<span class="sd">            radius (float): circle radius</span>
<span class="sd">            plane (Plane, optional): base plane. Defaults to Plane.XY.</span>
<span class="sd">            start_angle (float, optional): start of arc angle. Defaults to 360.0.</span>
<span class="sd">            end_angle (float, optional): end of arc angle. Defaults to 360.</span>
<span class="sd">            angular_direction (AngularDirection, optional): arc direction.</span>
<span class="sd">                Defaults to AngularDirection.COUNTER_CLOCKWISE.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: full or partial circle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circle_gp</span> <span class="o">=</span> <span class="n">gp_Circ</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">to_gp_ax2</span><span class="p">(),</span> <span class="n">radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_angle</span> <span class="o">==</span> <span class="n">end_angle</span><span class="p">:</span>  <span class="c1"># full circle case</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">circle_gp</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># arc case</span>
            <span class="n">ccw</span> <span class="o">=</span> <span class="n">angular_direction</span> <span class="o">==</span> <span class="n">AngularDirection</span><span class="o">.</span><span class="n">COUNTER_CLOCKWISE</span>
            <span class="k">if</span> <span class="n">ccw</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">start_angle</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">end_angle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">end_angle</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">start_angle</span><span class="p">)</span>
            <span class="n">circle_geom</span> <span class="o">=</span> <span class="n">GC_MakeArcOfCircle</span><span class="p">(</span><span class="n">circle_gp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ccw</span><span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">circle_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Edge.make_ellipse">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_ellipse">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_ellipse</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">x_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">y_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
        <span class="n">start_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">end_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">angular_direction</span><span class="p">:</span> <span class="n">AngularDirection</span> <span class="o">=</span> <span class="n">AngularDirection</span><span class="o">.</span><span class="n">COUNTER_CLOCKWISE</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make ellipse</span>

<span class="sd">        Makes an ellipse centered at the origin of plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_radius (float): x radius of the ellipse (along the x-axis of plane)</span>
<span class="sd">            y_radius (float): y radius of the ellipse (along the y-axis of plane)</span>
<span class="sd">            plane (Plane, optional): base plane. Defaults to Plane.XY.</span>
<span class="sd">            start_angle (float, optional): Defaults to 360.0.</span>
<span class="sd">            end_angle (float, optional): Defaults to 360.0.</span>
<span class="sd">            angular_direction (AngularDirection, optional): arc direction.</span>
<span class="sd">                Defaults to AngularDirection.COUNTER_CLOCKWISE.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: full or partial ellipse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">gp_Ax1</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span><span class="o">.</span><span class="n">to_dir</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">y_radius</span> <span class="o">&gt;</span> <span class="n">x_radius</span><span class="p">:</span>
            <span class="c1"># swap x and y radius and rotate by 90 afterwards to create an ellipse</span>
            <span class="c1"># with x_radius &lt; y_radius</span>
            <span class="n">correction_angle</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">*</span> <span class="n">DEG2RAD</span>
            <span class="n">ellipse_gp</span> <span class="o">=</span> <span class="n">gp_Elips</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">to_gp_ax2</span><span class="p">(),</span> <span class="n">y_radius</span><span class="p">,</span> <span class="n">x_radius</span><span class="p">)</span><span class="o">.</span><span class="n">Rotated</span><span class="p">(</span>
                <span class="n">ax1</span><span class="p">,</span> <span class="n">correction_angle</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">correction_angle</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">ellipse_gp</span> <span class="o">=</span> <span class="n">gp_Elips</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">to_gp_ax2</span><span class="p">(),</span> <span class="n">x_radius</span><span class="p">,</span> <span class="n">y_radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_angle</span> <span class="o">==</span> <span class="n">end_angle</span><span class="p">:</span>  <span class="c1"># full ellipse case</span>
            <span class="n">ellipse</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">ellipse_gp</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># arc case</span>
            <span class="c1"># take correction_angle into account</span>
            <span class="n">ellipse_geom</span> <span class="o">=</span> <span class="n">GC_MakeArcOfEllipse</span><span class="p">(</span>
                <span class="n">ellipse_gp</span><span class="p">,</span>
                <span class="n">start_angle</span> <span class="o">*</span> <span class="n">DEG2RAD</span> <span class="o">-</span> <span class="n">correction_angle</span><span class="p">,</span>
                <span class="n">end_angle</span> <span class="o">*</span> <span class="n">DEG2RAD</span> <span class="o">-</span> <span class="n">correction_angle</span><span class="p">,</span>
                <span class="n">angular_direction</span> <span class="o">==</span> <span class="n">AngularDirection</span><span class="o">.</span><span class="n">COUNTER_CLOCKWISE</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
            <span class="n">ellipse</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">ellipse_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">ellipse</span></div>


<div class="viewcode-block" id="Edge.make_helix">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_helix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_helix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">pitch</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">normal</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">lefthand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_helix</span>

<span class="sd">        Make a helix with a given pitch, height and radius. By default a cylindrical surface is</span>
<span class="sd">        used to create the helix. If the :angle: is set (the apex given in degree) a conical</span>
<span class="sd">        surface is used instead.</span>

<span class="sd">        Args:</span>
<span class="sd">            pitch (float): distance per revolution along normal</span>
<span class="sd">            height (float): total height</span>
<span class="sd">            radius (float):</span>
<span class="sd">            center (VectorLike, optional): Defaults to (0, 0, 0).</span>
<span class="sd">            normal (VectorLike, optional): Defaults to (0, 0, 1).</span>
<span class="sd">            angle (float, optional): conical angle. Defaults to 0.0.</span>
<span class="sd">            lefthand (bool, optional): Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: helix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="c1"># 1. build underlying cylindrical/conical surface</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">geom_surf</span><span class="p">:</span> <span class="n">Geom_Surface</span> <span class="o">=</span> <span class="n">Geom_CylindricalSurface</span><span class="p">(</span>
                <span class="n">gp_Ax3</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">to_dir</span><span class="p">()),</span> <span class="n">radius</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geom_surf</span> <span class="o">=</span> <span class="n">Geom_ConicalSurface</span><span class="p">(</span>
                <span class="n">gp_Ax3</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">to_dir</span><span class="p">()),</span>
                <span class="n">angle</span> <span class="o">*</span> <span class="n">DEG2RAD</span><span class="p">,</span>
                <span class="n">radius</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># 2. construct an segment in the u,v domain</span>

        <span class="c1"># Determine the length of the 2d line which will be wrapped around the surface</span>
        <span class="n">line_sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">lefthand</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">line_dir</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">line_sign</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pitch</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
        <span class="n">line_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="n">line_dir</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>

        <span class="c1"># Create an infinite 2d line in the direction of the  helix</span>
        <span class="n">helix_line</span> <span class="o">=</span> <span class="n">Geom2d_Line</span><span class="p">(</span><span class="n">gp_Pnt2d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gp_Dir2d</span><span class="p">(</span><span class="n">line_dir</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">line_dir</span><span class="o">.</span><span class="n">Y</span><span class="p">))</span>
        <span class="c1"># Trim the line to the desired length</span>
        <span class="n">helix_curve</span> <span class="o">=</span> <span class="n">Geom2d_TrimmedCurve</span><span class="p">(</span>
            <span class="n">helix_line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">line_len</span><span class="p">,</span> <span class="n">theAdjustPeriodic</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># 3. Wrap the line around the surface</span>
        <span class="n">edge_builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">helix_curve</span><span class="p">,</span> <span class="n">geom_surf</span><span class="p">)</span>
        <span class="n">topods_edge</span> <span class="o">=</span> <span class="n">edge_builder</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>

        <span class="c1"># 4. Convert the edge made with 2d geometry to 3d</span>
        <span class="n">BRepLib</span><span class="o">.</span><span class="n">BuildCurves3d_s</span><span class="p">(</span><span class="n">topods_edge</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="n">MaxSegment</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">topods_edge</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.make_line">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_line">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_line</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">point1</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">point2</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a line between two points</span>

<span class="sd">        Args:</span>
<span class="sd">          point1: VectorLike: that represents the first point</span>
<span class="sd">          point2: VectorLike: that represents the second point</span>

<span class="sd">        Returns:</span>
<span class="sd">          A linear edge between the two provided points</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span>
                <span class="n">Vector</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">()</span>
            <span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Edge.make_mid_way">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_mid_way">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_mid_way</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">first</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">middle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make line between edges</span>

<span class="sd">        Create a new linear Edge between the two provided Edges. If the Edges are parallel</span>
<span class="sd">        but in the opposite directions one Edge is flipped such that the mid way Edge isn&#39;t</span>
<span class="sd">        truncated.</span>

<span class="sd">        Args:</span>
<span class="sd">            first (Edge): first reference Edge</span>
<span class="sd">            second (Edge): second reference Edge</span>
<span class="sd">            middle (float, optional): factional distance between Edges. Defaults to 0.5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: linear Edge between two Edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">to_axis</span><span class="p">()</span><span class="o">.</span><span class="n">is_opposite</span><span class="p">(</span><span class="n">second</span><span class="o">.</span><span class="n">to_axis</span><span class="p">())</span>
        <span class="n">pnts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span>
                <span class="n">first</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">second</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="k">if</span> <span class="n">flip</span> <span class="k">else</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="o">*</span><span class="n">pnts</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.make_spline">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_spline">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_spline</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">],</span>
        <span class="n">tangents</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spline</span>

<span class="sd">        Interpolate a spline through the provided points.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list[VectorLike]):  the points defining the spline</span>
<span class="sd">            tangents (list[VectorLike], optional): start and finish tangent.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            periodic (bool, optional): creation of periodic curves. Defaults to False.</span>
<span class="sd">            parameters (list[float], optional): the value of the parameter at each</span>
<span class="sd">                interpolation point. (The interpolated curve is represented as a vector-valued</span>
<span class="sd">                function of a scalar parameter.) If periodic == True, then len(parameters)</span>
<span class="sd">                must be len(interpolation points) + 1, otherwise len(parameters)</span>
<span class="sd">                must be equal to len(interpolation points). Defaults to None.</span>
<span class="sd">            scale (bool, optional): whether to scale the specified tangent vectors before</span>
<span class="sd">                interpolating. Each tangent is scaled, so it&#39;s length is equal to the derivative</span>
<span class="sd">                of the Lagrange interpolated curve. I.e., set this to True, if you want to use</span>
<span class="sd">                only the direction of the tangent vectors specified by `tangents` , but not</span>
<span class="sd">                their magnitude. Defaults to True.</span>
<span class="sd">            tol (float, optional): tolerance of the algorithm (consult OCC documentation).</span>
<span class="sd">                Used to check that the specified points are not too close to each other, and</span>
<span class="sd">                that tangent vectors are not too short. (In either case interpolation may fail.).</span>
<span class="sd">                Defaults to 1e-6.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Parameter for each interpolation point</span>
<span class="sd">            ValueError: Tangent for each interpolation point</span>
<span class="sd">            ValueError: B-spline interpolation failed</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: the spline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">point_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tangents</span><span class="p">:</span>
            <span class="n">tangent_vectors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tangents</span><span class="p">)</span>
        <span class="n">pnts</span> <span class="o">=</span> <span class="n">TColgp_HArray1OfPnt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">):</span>
            <span class="n">pnts</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_Interpolate</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">)</span> <span class="o">+</span> <span class="n">periodic</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;There must be one parameter for each interpolation point &quot;</span>
                    <span class="s2">&quot;(plus one if periodic), or none specified. Parameter count: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">, point count: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">parameters_array</span> <span class="o">=</span> <span class="n">TColStd_HArray1OfReal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">p_index</span><span class="p">,</span> <span class="n">p_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
                <span class="n">parameters_array</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">p_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p_value</span><span class="p">)</span>

            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_Interpolate</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">parameters_array</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tangents</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Specify only initial and final tangent:</span>
                <span class="n">spline_builder</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span>
                    <span class="n">tangent_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">tangent_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">scale</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;There must be one tangent for each interpolation point, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;or just two end point tangents. Tangent count: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">)</span><span class="si">}</span><span class="s2">, point count: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">point_vectors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Specify a tangent for each interpolation point:</span>
                <span class="n">tangents_array</span> <span class="o">=</span> <span class="n">TColgp_Array1OfVec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">))</span>
                <span class="n">tangent_enabled_array</span> <span class="o">=</span> <span class="n">TColStd_HArray1OfBoolean</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">t_index</span><span class="p">,</span> <span class="n">t_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tangent_vectors</span><span class="p">):</span>
                    <span class="n">tangent_enabled_array</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">t_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">tangent_vec</span> <span class="o">=</span> <span class="n">t_value</span> <span class="k">if</span> <span class="n">t_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Vector</span><span class="p">()</span>
                    <span class="n">tangents_array</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">t_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tangent_vec</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

                <span class="n">spline_builder</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="n">tangents_array</span><span class="p">,</span> <span class="n">tangent_enabled_array</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">spline_builder</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">IsDone</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B-spline interpolation failed&quot;</span><span class="p">)</span>

        <span class="n">spline_geom</span> <span class="o">=</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">Curve</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">spline_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span></div>


<div class="viewcode-block" id="Edge.make_spline_approx">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_spline_approx">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_spline_approx</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">],</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span>
        <span class="n">smoothing</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_deg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">max_deg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_spline_approx</span>

<span class="sd">        Approximate a spline through the provided points.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (list[Vector]):</span>
<span class="sd">            tol (float, optional): tolerance of the algorithm. Defaults to 1e-3.</span>
<span class="sd">            smoothing (Tuple[float, float, float], optional): optional tuple of 3 weights</span>
<span class="sd">                use for variational smoothing. Defaults to None.</span>
<span class="sd">            min_deg (int, optional): minimum spline degree. Enforced only when smoothing</span>
<span class="sd">                is None. Defaults to 1.</span>
<span class="sd">            max_deg (int, optional): maximum spline degree. Defaults to 6.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: B-spline approximation failed</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: spline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pnts</span> <span class="o">=</span> <span class="n">TColgp_HArray1OfPnt</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="n">pnts</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_PointsToBSpline</span><span class="p">(</span>
                <span class="n">pnts</span><span class="p">,</span> <span class="o">*</span><span class="n">smoothing</span><span class="p">,</span> <span class="n">DegMax</span><span class="o">=</span><span class="n">max_deg</span><span class="p">,</span> <span class="n">Tol3D</span><span class="o">=</span><span class="n">tol</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spline_builder</span> <span class="o">=</span> <span class="n">GeomAPI_PointsToBSpline</span><span class="p">(</span>
                <span class="n">pnts</span><span class="p">,</span> <span class="n">DegMin</span><span class="o">=</span><span class="n">min_deg</span><span class="p">,</span> <span class="n">DegMax</span><span class="o">=</span><span class="n">max_deg</span><span class="p">,</span> <span class="n">Tol3D</span><span class="o">=</span><span class="n">tol</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">IsDone</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B-spline approximation failed&quot;</span><span class="p">)</span>

        <span class="n">spline_geom</span> <span class="o">=</span> <span class="n">spline_builder</span><span class="o">.</span><span class="n">Curve</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">spline_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span></div>


<div class="viewcode-block" id="Edge.make_tangent_arc">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_tangent_arc">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_tangent_arc</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">tangent</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tangent Arc</span>

<span class="sd">        Makes a tangent arc from point start, in the direction of tangent and ends at end.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (VectorLike): start point</span>
<span class="sd">            tangent (VectorLike): start tangent</span>
<span class="sd">            end (VectorLike): end point</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: circular arc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circle_geom</span> <span class="o">=</span> <span class="n">GC_MakeArcOfCircle</span><span class="p">(</span>
            <span class="n">Vector</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">circle_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span></div>


<div class="viewcode-block" id="Edge.make_three_point_arc">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.make_three_point_arc">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_three_point_arc</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">point1</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">point2</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">point3</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Three Point Arc</span>

<span class="sd">        Makes a three point arc through the provided points</span>

<span class="sd">        Args:</span>
<span class="sd">            point1 (VectorLike): start point</span>
<span class="sd">            point2 (VectorLike): middle point</span>
<span class="sd">            point3 (VectorLike): end point</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: a circular arc through the three points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circle_geom</span> <span class="o">=</span> <span class="n">GC_MakeArcOfCircle</span><span class="p">(</span>
            <span class="n">Vector</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point3</span><span class="p">)</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">circle_geom</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">())</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Edge.close">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close an Edge&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Edge.distribute_locations">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.distribute_locations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distribute_locations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Edge</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">positions_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Distribute Locations</span>

<span class="sd">        Distribute locations along edge or wire.</span>

<span class="sd">        Args:</span>
<span class="sd">          self: Wire:Edge:</span>
<span class="sd">          count(int): Number of locations to generate</span>
<span class="sd">          start(float): position along Edge|Wire to start. Defaults to 0.0.</span>
<span class="sd">          stop(float): position along Edge|Wire to end. Defaults to 1.0.</span>
<span class="sd">          positions_only(bool): only generate position not orientation. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">          list[Location]: locations distributed along Edge|Wire</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: count must be two or greater</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;count must be two or greater&quot;</span><span class="p">)</span>

        <span class="n">t_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

        <span class="n">locations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locations</span><span class="p">(</span><span class="n">t_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">positions_only</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">:</span>
                <span class="n">loc</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">locations</span></div>


<div class="viewcode-block" id="Edge.find_intersection_points">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.find_intersection_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_intersection_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">TOLERANCE</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vector</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;find_intersection_points</span>

<span class="sd">        Determine the points where a 2D edge crosses itself or another 2D edge</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Axis | Edge): curve to compare with</span>
<span class="sd">            tolerance (float, optional): the precision of computing the intersection points.</span>
<span class="sd">                 Defaults to TOLERANCE.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Vector]: list of intersection points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert an Axis into an edge at least as large as self and Axis start point</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
            <span class="n">self_bbox_w_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">Vertex</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">self_bbox_w_edge</span><span class="o">.</span><span class="n">diagonal</span><span class="p">),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="n">self_bbox_w_edge</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># To determine the 2D plane to work on</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_plane</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All objects must be on the same plane&quot;</span><span class="p">)</span>
        <span class="c1"># Convert the plane into a Geom_Surface</span>
        <span class="n">pln_shape</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Face</span><span class="p">()</span>
        <span class="n">edge_surface</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Surface_s</span><span class="p">(</span><span class="n">pln_shape</span><span class="p">)</span>

        <span class="n">self_2d_curve</span><span class="p">:</span> <span class="n">Geom2d_Curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">CurveOnPlane_s</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
            <span class="n">edge_surface</span><span class="p">,</span>
            <span class="n">TopLoc_Location</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_2d_curve</span><span class="p">:</span> <span class="n">Geom2d_Curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">CurveOnPlane_s</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
                <span class="n">edge_surface</span><span class="p">,</span>
                <span class="n">TopLoc_Location</span><span class="p">(),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">intersector</span> <span class="o">=</span> <span class="n">Geom2dAPI_InterCurveCurve</span><span class="p">(</span>
                <span class="n">self_2d_curve</span><span class="p">,</span> <span class="n">edge_2d_curve</span><span class="p">,</span> <span class="n">tolerance</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">intersector</span> <span class="o">=</span> <span class="n">Geom2dAPI_InterCurveCurve</span><span class="p">(</span><span class="n">self_2d_curve</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="n">crosses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Vector</span><span class="p">(</span><span class="n">intersector</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">intersector</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Y</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intersector</span><span class="o">.</span><span class="n">NbPoints</span><span class="p">())</span>
        <span class="p">]</span>
        <span class="c1"># Convert back to global coordinates</span>
        <span class="n">crosses</span> <span class="o">=</span> <span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">from_local_coords</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">crosses</span><span class="p">]</span>

        <span class="c1"># crosses may contain points beyond the ends of the edge so</span>
        <span class="c1"># .. filter those out</span>
        <span class="n">valid_crosses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">crosses</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOLERANCE</span>
                        <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOLERANCE</span>
                    <span class="p">):</span>
                        <span class="n">valid_crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOLERANCE</span><span class="p">:</span>
                        <span class="n">valid_crosses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># skip invalid points</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">valid_crosses</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.find_tangent">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.find_tangent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_tangent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;find_tangent</span>

<span class="sd">        Find the parameter values of self where the tangent is equal to angle.</span>

<span class="sd">        Args:</span>
<span class="sd">            angle (float): target angle in degrees</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[float]: u values between 0.0 and 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">%</span> <span class="mi">360</span>  <span class="c1"># angle needs to always be positive 0..360</span>
        <span class="n">u_values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_angle_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">angle</span><span class="p">:</span>
                <span class="n">u_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Solve this problem geometrically by creating a tangent curve and finding intercepts</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">)</span>  <span class="c1"># if closed don&#39;t include end point</span>
            <span class="n">tan_pnts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">previous_tangent</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># When angles go from 360 to 0 a discontinuity is created so add 360 to these</span>
            <span class="c1"># values and intercept another line</span>
            <span class="n">discontinuities</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">101</span> <span class="o">-</span> <span class="n">periodic</span><span class="p">):</span>
                <span class="n">tangent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangent_angle_at</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="n">discontinuities</span> <span class="o">*</span> <span class="mi">360</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">previous_tangent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">previous_tangent</span> <span class="o">-</span> <span class="n">tangent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">300</span>
                <span class="p">):</span>
                    <span class="n">discontinuities</span> <span class="o">=</span> <span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">previous_tangent</span> <span class="o">-</span> <span class="n">tangent</span><span class="p">)</span>
                    <span class="n">tangent</span> <span class="o">+=</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">discontinuities</span>
                <span class="n">previous_tangent</span> <span class="o">=</span> <span class="n">tangent</span>
                <span class="n">tan_pnts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tangent</span><span class="p">))</span>

            <span class="c1"># Generate a first differential curve from the tangent points</span>
            <span class="n">tan_curve</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_spline</span><span class="p">(</span><span class="n">tan_pnts</span><span class="p">)</span>

            <span class="c1"># Use the bounding box to find the min and max values</span>
            <span class="n">tan_curve_bbox</span> <span class="o">=</span> <span class="n">tan_curve</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span>
            <span class="n">min_range</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">*</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">tan_curve_bbox</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">360</span><span class="p">))</span>
            <span class="n">max_range</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">*</span> <span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">tan_curve_bbox</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">Y</span> <span class="o">/</span> <span class="mi">360</span><span class="p">))</span>

            <span class="c1"># Create a horizontal line for each 360 cycle and intercept it</span>
            <span class="n">intercept_pnts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_range</span><span class="p">,</span> <span class="n">max_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">360</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">angle</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">angle</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">intercept_pnts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tan_curve</span><span class="o">.</span><span class="n">find_intersection_points</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

            <span class="n">u_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">intercept_pnts</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">u_values</span></div>


<div class="viewcode-block" id="Edge.geom_adaptor">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.geom_adaptor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_adaptor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BRepAdaptor_Curve</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Geom Curve from this Edge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BRepAdaptor_Curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.intersect">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.intersect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">to_intersect</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Plane</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vertex</span> <span class="o">|</span> <span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;intersect Edge with Edge or Axis</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Edge |  Axis): other object</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape |  None: Compound of vertices and/or edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">planes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Plane</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edges_common_to_planes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_intersect</span><span class="p">:</span>
            <span class="k">match</span> <span class="n">obj</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">Axis</span><span class="p">():</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
                <span class="k">case</span> <span class="n">Edge</span><span class="p">():</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">Plane</span><span class="p">():</span>
                    <span class="n">planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown object type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Find any edge / edge intersection points</span>
        <span class="n">points_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="n">Vector</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Find crossing points</span>
        <span class="k">for</span> <span class="n">edge_pair</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">edge_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find_intersection_points</span><span class="p">(</span><span class="n">edge_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">points_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">))</span>

        <span class="c1"># Find common end points</span>
        <span class="n">self_end_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="n">edge_end_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="n">common_end_points</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">self_end_points</span><span class="p">,</span> <span class="n">edge_end_points</span><span class="p">)</span>

        <span class="c1"># Find any edge / plane intersection points &amp; edges</span>
        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">plane</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">,</span> <span class="n">planes</span><span class="p">):</span>
            <span class="c1"># Find point intersections</span>
            <span class="n">geom_line</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Curve_s</span><span class="p">(</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">geom_plane</span> <span class="o">=</span> <span class="n">Geom_Plane</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">local_coord_system</span><span class="p">)</span>
            <span class="n">intersection_calculator</span> <span class="o">=</span> <span class="n">GeomAPI_IntCS</span><span class="p">(</span><span class="n">geom_line</span><span class="p">,</span> <span class="n">geom_plane</span><span class="p">)</span>
            <span class="n">plane_intersection_points</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">intersection_calculator</span><span class="o">.</span><span class="n">IsDone</span><span class="p">():</span>
                <span class="n">plane_intersection_points</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">Vector</span><span class="p">(</span><span class="n">intersection_calculator</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intersection_calculator</span><span class="o">.</span><span class="n">NbPoints</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="n">points_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">plane_intersection_points</span><span class="p">))</span>

            <span class="c1"># Find edge intersections</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">plane</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">positions</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">7</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
            <span class="p">):</span>  <span class="c1"># is a 2D edge</span>
                <span class="n">edges_common_to_planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="n">edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">edges_common_to_planes</span><span class="p">)</span>

        <span class="c1"># Find the intersection of all sets</span>
        <span class="n">common_points</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">points_sets</span><span class="p">)</span>
        <span class="n">common_vertices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Vertex</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">common_points</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">common_end_points</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Find Edge/Edge overlaps</span>
        <span class="n">common_edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">common_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_op</span><span class="p">((</span><span class="bp">self</span><span class="p">,),</span> <span class="n">edges</span><span class="p">,</span> <span class="n">BRepAlgoAPI_Common</span><span class="p">())</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">common_vertices</span> <span class="ow">or</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="c1"># If there is just one vertex or edge return it</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">common_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">common_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">common_vertices</span> <span class="o">+</span> <span class="n">common_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Edge.param_at_point">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.param_at_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalized parameter at point along Edge&quot;&quot;&quot;</span>

        <span class="c1"># Note that this search algorithm would ideally be replaced with</span>
        <span class="c1"># an OCP based solution, something like that which is shown below.</span>
        <span class="c1"># However, there are known issues with the OCP methods for some</span>
        <span class="c1"># curves which may return negative values or incorrect values at</span>
        <span class="c1"># end points. Also note that this search takes about 1.5ms while</span>
        <span class="c1"># the OCP methods take about 0.4ms.</span>
        <span class="c1">#</span>
        <span class="c1"># curve = BRep_Tool.Curve_s(self.wrapped, float(), float())</span>
        <span class="c1"># param_min, param_max = BRep_Tool.Range_s(self.wrapped)</span>
        <span class="c1"># projector = GeomAPI_ProjectPointOnCurve(point.to_pnt(), curve)</span>
        <span class="c1"># param_value = projector.LowerDistanceParameter()</span>
        <span class="c1"># u_value = (param_value - param_min) / (param_max - param_min)</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">isclose_b</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">point</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">TOLERANCE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;point (</span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">) is not on edge&quot;</span><span class="p">)</span>

        <span class="c1"># Function to be minimized</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>

        <span class="c1"># Find the u value that results in a point within tolerance of the target</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="mf">0.0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)],</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">TOLERANCE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">u_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">u_value</span></div>


<div class="viewcode-block" id="Edge.project_to_shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.project_to_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_to_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_object</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project Edge</span>

<span class="sd">        Project an Edge onto a Shape generating new wires on the surfaces of the object</span>
<span class="sd">        one and only one of `direction` or `center` must be provided. Note that one or</span>
<span class="sd">        more wires may be generated depending on the topology of the target object and</span>
<span class="sd">        location/direction of projection.</span>

<span class="sd">        To avoid flipping the normal of a face built with the projected wire the orientation</span>
<span class="sd">        of the output wires are forced to be the same as self.</span>

<span class="sd">        Args:</span>
<span class="sd">          target_object: Object to project onto</span>
<span class="sd">          direction: Parallel projection direction. Defaults to None.</span>
<span class="sd">          center: Conical center of projection. Defaults to None.</span>
<span class="sd">          target_object: Shape:</span>
<span class="sd">          direction: VectorLike:  (Default value = None)</span>
<span class="sd">          center: VectorLike:  (Default value = None)</span>

<span class="sd">        Returns:</span>
<span class="sd">          : Projected Edge(s)</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: Only one of direction or center must be provided</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">projected_wires</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">project_to_shape</span><span class="p">(</span><span class="n">target_object</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
        <span class="n">projected_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">edges</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">projected_wires</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">projected_edges</span></div>


<div class="viewcode-block" id="Edge.reversed">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.reversed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of self with the opposite orientation&quot;&quot;&quot;</span>
        <span class="n">reversed_edge</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">first</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">last</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Curve_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">ReversedParameter</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">ReversedParameter</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="n">topods_edge</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">Reversed</span><span class="p">(),</span> <span class="n">last</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>
        <span class="n">reversed_edge</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">topods_edge</span>
        <span class="k">return</span> <span class="n">reversed_edge</span></div>


<div class="viewcode-block" id="Edge.to_axis">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.to_axis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axis</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate a linear Edge to an Axis&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">!=</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;to_axis is only valid for linear Edges not </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">Axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="Edge.to_wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.to_wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Edge as Wire&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span></div>


<div class="viewcode-block" id="Edge.trim">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.trim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;trim</span>

<span class="sd">        Create a new edge by keeping only the section between start and end.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): 0.0 &lt;= start &lt; 1.0</span>
<span class="sd">            end (float): 0.0 &lt; end &lt;= 1.0</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: start &gt;= end</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: trimmed edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start (</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">) must be less than end (</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="n">new_curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Curve_s</span><span class="p">(</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">parm_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">parm_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">trimmed_curve</span> <span class="o">=</span> <span class="n">Geom_TrimmedCurve</span><span class="p">(</span>
            <span class="n">new_curve</span><span class="p">,</span>
            <span class="n">parm_start</span><span class="p">,</span>
            <span class="n">parm_end</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">trimmed_curve</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span></div>


<div class="viewcode-block" id="Edge.trim_to_length">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Edge.trim_to_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim_to_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;trim_to_length</span>

<span class="sd">        Create a new edge starting at the given normalized parameter of a</span>
<span class="sd">        given length.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): 0.0 &lt;= start &lt; 1.0</span>
<span class="sd">            length (float): target length</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: trimmed edge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_curve</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Curve_s</span><span class="p">(</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create an adaptor for the curve</span>
        <span class="n">adaptor_curve</span> <span class="o">=</span> <span class="n">GeomAdaptor_Curve</span><span class="p">(</span><span class="n">new_curve</span><span class="p">)</span>

        <span class="c1"># Find the parameter corresponding to the desired length</span>
        <span class="n">parm_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">abscissa_point</span> <span class="o">=</span> <span class="n">GCPnts_AbscissaPoint</span><span class="p">(</span><span class="n">adaptor_curve</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">parm_start</span><span class="p">)</span>

        <span class="c1"># Get the parameter at the desired length</span>
        <span class="n">parm_end</span> <span class="o">=</span> <span class="n">abscissa_point</span><span class="o">.</span><span class="n">Parameter</span><span class="p">()</span>

        <span class="c1"># Trim the curve to the desired length</span>
        <span class="n">trimmed_curve</span> <span class="o">=</span> <span class="n">Geom_TrimmedCurve</span><span class="p">(</span><span class="n">new_curve</span><span class="p">,</span> <span class="n">parm_start</span><span class="p">,</span> <span class="n">parm_end</span><span class="p">)</span>

        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span><span class="n">trimmed_curve</span><span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Wire</span><span class="p">(</span><span class="n">Mixin1D</span><span class="p">,</span> <span class="n">Shape</span><span class="p">[</span><span class="n">TopoDS_Wire</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Wire in build123d is a topological entity representing a connected sequence</span>
<span class="sd">    of edges forming a continuous curve or path in 3D space. Wires are essential</span>
<span class="sd">    components in modeling complex objects, defining boundaries for surfaces or</span>
<span class="sd">    solids. They store information about the connectivity and order of edges,</span>
<span class="sd">    allowing precise definition of paths within a 3D model.&quot;&quot;&quot;</span>

    <span class="n">order</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="c1"># ---- Constructor ----</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Wire</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a wire from an OCCT TopoDS_Wire</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (TopoDS_Wire, optional): OCCT Wire.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edge</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a Wire from an Edge</span>

<span class="sd">        Args:</span>
<span class="sd">            edge (Edge): Edge to convert to Wire</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wire</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a Wire from an Wire - used when the input could be an Edge or Wire.</span>

<span class="sd">        Args:</span>
<span class="sd">            wire (Wire): Wire to convert to another Wire</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wire</span><span class="p">:</span> <span class="n">Curve</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a Wire from an Curve.</span>

<span class="sd">        Args:</span>
<span class="sd">            curve (Curve): Curve to convert to a Wire</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span>
        <span class="n">sequenced</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a wire from Edges</span>

<span class="sd">        Build a Wire from the provided unsorted Edges. If sequenced is True the</span>
<span class="sd">        Edges are placed in such that the end of the nth Edge is coincident with</span>
<span class="sd">        the n+1th Edge forming an unbroken sequence. Note that sequencing a list</span>
<span class="sd">        is relatively slow.</span>

<span class="sd">        Args:</span>
<span class="sd">            edges (Iterable[Edge]): Edges to assemble</span>
<span class="sd">            sequenced (bool, optional): arrange in order. Defaults to False.</span>
<span class="sd">            label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">            color (Color, optional): Defaults to None.</span>
<span class="sd">            parent (Compound, optional): assembly parent. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">curve</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">wire</span><span class="p">,</span> <span class="n">sequenced</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">9</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">l_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TopoDS_Wire</span><span class="p">):</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Edge</span><span class="p">):</span>
                <span class="n">edge</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Wire</span><span class="p">):</span>
                <span class="n">wire</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>
            <span class="c1"># elif isinstance(args[0], Curve):</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;wrapped&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">topods_dim</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">):</span>  <span class="c1"># Curve</span>
                <span class="n">curve</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">sequenced</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="n">l_a</span><span class="p">)</span>

        <span class="n">unknown_args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;curve&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wire&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;sequenced&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;obj&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;label&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;color&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">unknown_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected argument(s) </span><span class="si">{</span><span class="n">unknown_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
        <span class="n">sequenced</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sequenced&quot;</span><span class="p">,</span> <span class="n">sequenced</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="n">wire</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wire&quot;</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;curve&quot;</span><span class="p">,</span> <span class="n">curve</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">curve</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wire</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">wire</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">elif</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">_make_wire</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">sequenced</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sequenced</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ---- Class Methods ----</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_wire</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span> <span class="n">sequenced</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_make_wire</span>

<span class="sd">        Build a Wire from the provided unsorted Edges. If sequenced is True the</span>
<span class="sd">        Edges are placed in such that the end of the nth Edge is coincident with</span>
<span class="sd">        the n+1th Edge forming an unbroken sequence. Note that sequencing a list</span>
<span class="sd">        is relatively slow.</span>

<span class="sd">        Args:</span>
<span class="sd">            edges (Iterable[Edge]): Edges to assemble</span>
<span class="sd">            sequenced (bool, optional): arrange in order. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Edges are disconnected and can&#39;t be sequenced.</span>
<span class="sd">            RuntimeError: Wire is empty</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: assembled edges</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">closest_to_end</span><span class="p">(</span><span class="n">current</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">unplaced_edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Return the Edge closest to the end of last_edge&quot;&quot;&quot;</span>
            <span class="n">target_point</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">unplaced_edges</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">target_point</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">target_point</span> <span class="o">-</span> <span class="n">e</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sequenced</span><span class="p">:</span>
            <span class="n">placed_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
            <span class="n">unplaced_edges</span> <span class="o">=</span> <span class="n">edges</span>

            <span class="k">while</span> <span class="n">unplaced_edges</span><span class="p">:</span>
                <span class="n">next_edge</span> <span class="o">=</span> <span class="n">closest_to_end</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">placed_edges</span><span class="p">),</span> <span class="n">unplaced_edges</span><span class="p">)</span>
                <span class="n">next_edge_index</span> <span class="o">=</span> <span class="n">unplaced_edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">next_edge</span><span class="p">)</span>
                <span class="n">placed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unplaced_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">next_edge_index</span><span class="p">))</span>

            <span class="n">edges</span> <span class="o">=</span> <span class="n">placed_edges</span>

        <span class="n">wire_builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeWire</span><span class="p">()</span>
        <span class="n">combined_edges</span> <span class="o">=</span> <span class="n">TopTools_ListOfShape</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">combined_edges</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">wire_builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span>

        <span class="n">wire_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wire_builder</span><span class="o">.</span><span class="n">IsDone</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">wire_builder</span><span class="o">.</span><span class="n">Error</span><span class="p">()</span> <span class="o">==</span> <span class="n">BRepBuilderAPI_NonManifoldWire</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Wire is non manifold (e.g. branching, self intersecting)&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">wire_builder</span><span class="o">.</span><span class="n">Error</span><span class="p">()</span> <span class="o">==</span> <span class="n">BRepBuilderAPI_EmptyWire</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Wire is empty&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">wire_builder</span><span class="o">.</span><span class="n">Error</span><span class="p">()</span> <span class="o">==</span> <span class="n">BRepBuilderAPI_DisconnectedWire</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edges are disconnected&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wire_builder</span><span class="o">.</span><span class="n">Wire</span><span class="p">()</span>

<div class="viewcode-block" id="Wire.combine">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.combine">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">wires</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Wire</span> <span class="o">|</span> <span class="n">Edge</span><span class="p">],</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-9</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;combine</span>

<span class="sd">        Combine a list of wires and edges into a list of Wires.</span>

<span class="sd">        Args:</span>
<span class="sd">            wires (Iterable[Wire |  Edge]): unsorted</span>
<span class="sd">            tol (float, optional): tolerance. Defaults to 1e-9.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Wire]: Wires</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges_in</span> <span class="o">=</span> <span class="n">TopTools_HSequenceOfShape</span><span class="p">()</span>
        <span class="n">wires_out</span> <span class="o">=</span> <span class="n">TopTools_HSequenceOfShape</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wires</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">edges</span><span class="p">()]:</span>
            <span class="n">edges_in</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="n">ShapeAnalysis_FreeBounds</span><span class="o">.</span><span class="n">ConnectEdgesToWires_s</span><span class="p">(</span><span class="n">edges_in</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wires_out</span><span class="p">)</span>

        <span class="n">wires</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires_out</span><span class="o">.</span><span class="n">Length</span><span class="p">()):</span>
            <span class="n">wires</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">wires_out</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>

        <span class="k">return</span> <span class="n">wires</span></div>


<div class="viewcode-block" id="Wire.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;extrude - invalid operation for Wire&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Wires can&#39;t be created by extrusion&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Wire.make_circle">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.make_circle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_circle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_circle</span>

<span class="sd">        Makes a circle centered at the origin of plane</span>

<span class="sd">        Args:</span>
<span class="sd">            radius (float): circle radius</span>
<span class="sd">            plane (Plane): base plane. Defaults to Plane.XY</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: a circle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circle_edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_circle</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">([</span><span class="n">circle_edge</span><span class="p">])</span></div>


<div class="viewcode-block" id="Wire.make_convex_hull">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.make_convex_hull">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_convex_hull</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_convex_hull</span>

<span class="sd">        Create a wire of minimum length enclosing all of the provided edges.</span>

<span class="sd">        Note that edges can&#39;t overlap each other.</span>

<span class="sd">        Args:</span>
<span class="sd">            edges (Iterable[Edge]): edges defining the convex hull</span>
<span class="sd">            tolerance (float): allowable error as a fraction of each edge length.</span>
<span class="sd">                Defaults to 1e-3.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: edges overlap</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: convex hull perimeter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-branches, too-many-locals</span>
        <span class="c1"># Algorithm:</span>
        <span class="c1"># 1) create a cloud of points along all edges</span>
        <span class="c1"># 2) create a convex hull which returns facets/simplices as pairs of point indices</span>
        <span class="c1"># 3) find facets that are within an edge but not adjacent and store trim and</span>
        <span class="c1">#    new connecting edge data</span>
        <span class="c1"># 4) find facets between edges and store trim and new connecting edge data</span>
        <span class="c1"># 5) post process the trim data to remove duplicates and store in pairs</span>
        <span class="c1"># 6) create  connecting edges</span>
        <span class="c1"># 7) create trim edges from the original edges and the trim data</span>
        <span class="c1"># 8) return a wire version of all the edges</span>

        <span class="c1"># Possible enhancement: The accuracy of the result could be improved and the</span>
        <span class="c1"># execution time reduced by adaptively placing more points around where the</span>
        <span class="c1"># connecting edges contact the arc.</span>

        <span class="c1"># if any(</span>
        <span class="c1">#     [</span>
        <span class="c1">#         edge_pair[0].overlaps(edge_pair[1])</span>
        <span class="c1">#         for edge_pair in combinations(edges, 2)</span>
        <span class="c1">#     ]</span>
        <span class="c1"># ):</span>
        <span class="c1">#     raise ValueError(&quot;edges overlap&quot;)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">fragments_per_edge</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">points_lookup</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># lookup from point index to edge/position on edge</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># convex hull point cloud</span>

        <span class="c1"># Create points along each edge and the lookup structure</span>
        <span class="k">for</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fragments_per_edge</span><span class="p">):</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">fragments_per_edge</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">points_lookup</span><span class="p">[</span><span class="n">edge_index</span> <span class="o">*</span> <span class="n">fragments_per_edge</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

        <span class="n">convex_hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Filter the fragments</span>
        <span class="n">connecting_edge_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trim_points</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">simplice</span> <span class="ow">in</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="n">edge0</span> <span class="o">=</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edge1</span> <span class="o">=</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Look for connecting edges between edges</span>
            <span class="k">if</span> <span class="n">edge0</span> <span class="o">!=</span> <span class="n">edge1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trim_points</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">edge1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trim_points</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">connecting_edge_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">edge0</span><span class="p">,</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">edge1</span><span class="p">,</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># Look for connecting edges within an edge</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">simplice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">simplice</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">start_pnt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">simplice</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">end_pnt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">simplice</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">edge0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trim_points</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_pnt</span><span class="p">,</span> <span class="n">end_pnt</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trim_points</span><span class="p">[</span><span class="n">edge0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">start_pnt</span><span class="p">,</span> <span class="n">end_pnt</span><span class="p">])</span>
                <span class="n">connecting_edge_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="p">(</span><span class="n">edge0</span><span class="p">,</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">start_pnt</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">start_pnt</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">edge0</span><span class="p">,</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">end_pnt</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">end_pnt</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">trim_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">start_end_pnts</span> <span class="ow">in</span> <span class="n">trim_points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s_points</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">start_end_pnts</span><span class="p">)</span>
            <span class="n">f_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s_points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">f_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s_points</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">trim_data</span><span class="p">[</span><span class="n">edge_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_points</span>

        <span class="n">connecting_edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span>
                <span class="n">edges</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">@</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">@</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">connecting_edge_data</span>
        <span class="p">]</span>
        <span class="n">trimmed_edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">edge_index</span><span class="p">]</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span>
                <span class="n">points_lookup</span><span class="p">[</span><span class="n">trim_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">points_lookup</span><span class="p">[</span><span class="n">trim_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">trim_pairs</span> <span class="ow">in</span> <span class="n">trim_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">trim_pair</span> <span class="ow">in</span> <span class="n">trim_pairs</span>
        <span class="p">]</span>
        <span class="n">hull_wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">connecting_edges</span> <span class="o">+</span> <span class="n">trimmed_edges</span><span class="p">,</span> <span class="n">sequenced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hull_wire</span></div>


<div class="viewcode-block" id="Wire.make_ellipse">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.make_ellipse">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_ellipse</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">x_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">y_radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
        <span class="n">start_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">end_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">angular_direction</span><span class="p">:</span> <span class="n">AngularDirection</span> <span class="o">=</span> <span class="n">AngularDirection</span><span class="o">.</span><span class="n">COUNTER_CLOCKWISE</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make ellipse</span>

<span class="sd">        Makes an ellipse centered at the origin of plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_radius (float): x radius of the ellipse (along the x-axis of plane)</span>
<span class="sd">            y_radius (float): y radius of the ellipse (along the y-axis of plane)</span>
<span class="sd">            plane (Plane, optional): base plane. Defaults to Plane.XY.</span>
<span class="sd">            start_angle (float, optional): _description_. Defaults to 360.0.</span>
<span class="sd">            end_angle (float, optional): _description_. Defaults to 360.0.</span>
<span class="sd">            angular_direction (AngularDirection, optional): arc direction.</span>
<span class="sd">                Defaults to AngularDirection.COUNTER_CLOCKWISE.</span>
<span class="sd">            closed (bool, optional): close the arc. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: an ellipse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ellipse_edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_ellipse</span><span class="p">(</span>
            <span class="n">x_radius</span><span class="p">,</span> <span class="n">y_radius</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">start_angle</span><span class="p">,</span> <span class="n">end_angle</span><span class="p">,</span> <span class="n">angular_direction</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">start_angle</span> <span class="o">!=</span> <span class="n">end_angle</span> <span class="ow">and</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="n">ellipse_edge</span><span class="o">.</span><span class="n">end_point</span><span class="p">(),</span> <span class="n">ellipse_edge</span><span class="o">.</span><span class="n">start_point</span><span class="p">())</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="n">ellipse_edge</span><span class="p">,</span> <span class="n">line</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wire</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">([</span><span class="n">ellipse_edge</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">wire</span></div>


<div class="viewcode-block" id="Wire.make_polygon">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.make_polygon">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">VectorLike</span><span class="p">],</span> <span class="n">close</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_polygon</span>

<span class="sd">        Create an irregular polygon by defining vertices</span>

<span class="sd">        Args:</span>
<span class="sd">            vertices (Iterable[VectorLike]):</span>
<span class="sd">            close (bool, optional): close the polygon. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: an irregular polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vectors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">TOLERANCE</span> <span class="ow">and</span> <span class="n">close</span><span class="p">:</span>
            <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">wire_builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakePolygon</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">:</span>
            <span class="n">wire_builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">wire_builder</span><span class="o">.</span><span class="n">Wire</span><span class="p">())</span></div>


<div class="viewcode-block" id="Wire.make_rect">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.make_rect">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_rect</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make Rectangle</span>

<span class="sd">        Make a Rectangle centered on center with the given normal</span>

<span class="sd">        Args:</span>
<span class="sd">            width (float): width (local x)</span>
<span class="sd">            height (float): height (local y)</span>
<span class="sd">            plane (Plane, optional): plane containing rectangle. Defaults to Plane.XY.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: The centered rectangle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners_local</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
            <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
            <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">corners_world</span> <span class="o">=</span> <span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">from_local_coords</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corners_local</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="o">.</span><span class="n">make_polygon</span><span class="p">(</span><span class="n">corners_world</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="c1"># ---- Static Methods ----</span>

<div class="viewcode-block" id="Wire.order_chamfer_edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.order_chamfer_edges">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_chamfer_edges</span><span class="p">(</span>
        <span class="n">reference_edge</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Edge</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Order the edges of a chamfer relative to a reference Edge&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reference_edge</span><span class="p">:</span>
            <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="k">if</span> <span class="n">edge1</span> <span class="o">==</span> <span class="n">reference_edge</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span>
            <span class="k">if</span> <span class="n">edge2</span> <span class="o">==</span> <span class="n">reference_edge</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edge2</span><span class="p">,</span> <span class="n">edge1</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reference edge not in edges&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Wire.chamfer_2d">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.chamfer_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chamfer_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">distance2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">],</span>
        <span class="n">edge</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;chamfer_2d</span>

<span class="sd">        Apply 2D chamfer to a wire</span>

<span class="sd">        Args:</span>
<span class="sd">            distance (float): chamfer length</span>
<span class="sd">            distance2 (float): chamfer length</span>
<span class="sd">            vertices (Iterable[Vertex]): vertices to chamfer</span>
<span class="sd">            edge (Edge): identifies the side where length is measured. The vertices must be</span>
<span class="sd">                part of the edge</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: chamfered wire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference_edge</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="c1"># Create a face to chamfer</span>
        <span class="n">unchamfered_face</span> <span class="o">=</span> <span class="n">_make_topods_face_from_wires</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">chamfer_builder</span> <span class="o">=</span> <span class="n">BRepFilletAPI_MakeFillet2d</span><span class="p">(</span><span class="n">unchamfered_face</span><span class="p">)</span>

        <span class="n">vertex_edge_map</span> <span class="o">=</span> <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">()</span>
        <span class="n">TopExp</span><span class="o">.</span><span class="n">MapShapesAndAncestors_s</span><span class="p">(</span>
            <span class="n">unchamfered_face</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">,</span> <span class="n">vertex_edge_map</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">vertex_edge_map</span><span class="o">.</span><span class="n">FindFromKey</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

            <span class="c1"># Index or iterator access to OCP.TopTools.TopTools_ListOfShape is slow on M1 macs</span>
            <span class="c1"># Using First() and Last() to omit</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">First</span><span class="p">()),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">Last</span><span class="p">()))</span>

            <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">order_chamfer_edges</span><span class="p">(</span><span class="n">reference_edge</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>

            <span class="n">chamfer_builder</span><span class="o">.</span><span class="n">AddChamfer</span><span class="p">(</span>
                <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">edge1</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span>
                <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">edge2</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span>
                <span class="n">distance</span><span class="p">,</span>
                <span class="n">distance2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">chamfer_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">chamfered_face</span> <span class="o">=</span> <span class="n">chamfer_builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="c1"># Fix the shape</span>
        <span class="n">shape_fix</span> <span class="o">=</span> <span class="n">ShapeFix_Shape</span><span class="p">(</span><span class="n">chamfered_face</span><span class="p">)</span>
        <span class="n">shape_fix</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>
        <span class="n">chamfered_face</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">shape_fix</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="c1"># Return the outer wire</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">(</span><span class="n">BRepTools</span><span class="o">.</span><span class="n">OuterWire_s</span><span class="p">(</span><span class="n">chamfered_face</span><span class="p">))</span></div>


<div class="viewcode-block" id="Wire.close">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close a Wire&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">make_line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_point</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">())</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">combine</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="Wire.fillet_2d">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.fillet_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fillet_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Vertex</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fillet_2d</span>

<span class="sd">        Apply 2D fillet to a wire</span>

<span class="sd">        Args:</span>
<span class="sd">            radius (float):</span>
<span class="sd">            vertices (Iterable[Vertex]): vertices to fillet</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: filleted wire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a face to fillet</span>
        <span class="n">unfilleted_face</span> <span class="o">=</span> <span class="n">_make_topods_face_from_wires</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="c1"># Fillet the face</span>
        <span class="n">fillet_builder</span> <span class="o">=</span> <span class="n">BRepFilletAPI_MakeFillet2d</span><span class="p">(</span><span class="n">unfilleted_face</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">fillet_builder</span><span class="o">.</span><span class="n">AddFillet</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">fillet_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">filleted_face</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">fillet_builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="c1"># Return the outer wire</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">(</span><span class="n">BRepTools</span><span class="o">.</span><span class="n">OuterWire_s</span><span class="p">(</span><span class="n">filleted_face</span><span class="p">))</span></div>


<div class="viewcode-block" id="Wire.fix_degenerate_edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.fix_degenerate_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fix_degenerate_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fix_degenerate_edges</span>

<span class="sd">        Fix a Wire that contains degenerate (very small) edges</span>

<span class="sd">        Args:</span>
<span class="sd">            precision (float): minimum value edge length</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: fixed wire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sf_w</span> <span class="o">=</span> <span class="n">ShapeFix_Wireframe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">sf_w</span><span class="o">.</span><span class="n">SetPrecision</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span>
        <span class="n">sf_w</span><span class="o">.</span><span class="n">SetMaxTolerance</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span>
        <span class="n">sf_w</span><span class="o">.</span><span class="n">FixSmallEdges</span><span class="p">()</span>
        <span class="n">sf_w</span><span class="o">.</span><span class="n">FixWireGaps</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Wire</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">sf_w</span><span class="o">.</span><span class="n">Shape</span><span class="p">()))</span></div>


<div class="viewcode-block" id="Wire.geom_adaptor">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.geom_adaptor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_adaptor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BRepAdaptor_CompCurve</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Geom Comp Curve for this Wire&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BRepAdaptor_CompCurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Wire.order_edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.order_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the edges in self ordered by wire direction and orientation&quot;&quot;&quot;</span>
        <span class="n">ordered_edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">e</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_forward</span> <span class="k">else</span> <span class="n">e</span><span class="o">.</span><span class="n">reversed</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">ordered_edges</span><span class="p">)</span></div>


<div class="viewcode-block" id="Wire.param_at_point">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.param_at_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameter at point on Wire&quot;&quot;&quot;</span>

        <span class="c1"># OCP doesn&#39;t support this so this algorithm finds the edge that contains the</span>
        <span class="c1"># point, finds the u value/fractional distance of the point on that edge and</span>
        <span class="c1"># sums up the length of the edges from the start to the edge with the point.</span>

        <span class="n">wire_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># To start, find the edge at the beginning</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># distance along wire</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="n">edge_list</span><span class="p">:</span>
            <span class="c1"># Find the edge closest to the target</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">target</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>

            <span class="c1"># The edge might be flipped requiring the u value to be reversed</span>
            <span class="n">edge_p0</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">edge_p1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">flipped</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">edge_p0</span><span class="p">)</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">edge_p1</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>

            <span class="c1"># Set the next start to &quot;end&quot; of the current edge</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">edge_p0</span> <span class="k">if</span> <span class="n">flipped</span> <span class="k">else</span> <span class="n">edge_p1</span>

            <span class="c1"># If this edge contain the point, get a fractional distance - otherwise the whole</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">TOLERANCE</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">u_value</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u_value</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">+=</span> <span class="n">u_value</span> <span class="o">*</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span>
                <span class="k">break</span>
            <span class="n">distance</span> <span class="o">+=</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2"> not on wire&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">wire_length</span></div>


<div class="viewcode-block" id="Wire.project_to_shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.project_to_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_to_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_object</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
        <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project Wire</span>

<span class="sd">        Project a Wire onto a Shape generating new wires on the surfaces of the object</span>
<span class="sd">        one and only one of `direction` or `center` must be provided. Note that one or</span>
<span class="sd">        more wires may be generated depending on the topology of the target object and</span>
<span class="sd">        location/direction of projection.</span>

<span class="sd">        To avoid flipping the normal of a face built with the projected wire the orientation</span>
<span class="sd">        of the output wires are forced to be the same as self.</span>

<span class="sd">        Args:</span>
<span class="sd">          target_object: Object to project onto</span>
<span class="sd">          direction: Parallel projection direction. Defaults to None.</span>
<span class="sd">          center: Conical center of projection. Defaults to None.</span>
<span class="sd">          target_object: Shape:</span>
<span class="sd">          direction: VectorLike:  (Default value = None)</span>
<span class="sd">          center: VectorLike:  (Default value = None)</span>

<span class="sd">        Returns:</span>
<span class="sd">          : Projected wire(s)</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: Only one of direction or center must be provided</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">target_object</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t project empty Wires or to empty Shapes&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of either direction or center must be provided&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>  <span class="c1"># for typing, never used</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">direction_vector</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

        <span class="c1"># Project the wire on the target object</span>
        <span class="k">if</span> <span class="n">direction_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">projection_object</span> <span class="o">=</span> <span class="n">BRepProj_Projection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
                <span class="n">target_object</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
                <span class="n">gp_Dir</span><span class="p">(</span><span class="o">*</span><span class="n">direction_vector</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">projection_object</span> <span class="o">=</span> <span class="n">BRepProj_Projection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
                <span class="n">target_object</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
                <span class="n">gp_Pnt</span><span class="p">(</span><span class="o">*</span><span class="n">center_point</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()),</span>
            <span class="p">)</span>

        <span class="c1"># Generate a list of the projected wires with aligned orientation</span>
        <span class="n">output_wires</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Orientation</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">projection_object</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">projected_wire</span> <span class="o">=</span> <span class="n">projection_object</span><span class="o">.</span><span class="n">Current</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">target_orientation</span> <span class="o">==</span> <span class="n">projected_wire</span><span class="o">.</span><span class="n">Orientation</span><span class="p">():</span>
                <span class="n">output_wires</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">projected_wire</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_wires</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">projected_wire</span><span class="o">.</span><span class="n">Reversed</span><span class="p">()))</span>
            <span class="n">projection_object</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;wire generated </span><span class="si">%d</span><span class="s2"> projected wires&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_wires</span><span class="p">))</span>

        <span class="c1"># BRepProj_Projection is inconsistent in the order that it returns projected</span>
        <span class="c1"># wires, sometimes front first and sometimes back - so sort this out by sorting</span>
        <span class="c1"># by distance from the original planar wire</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_wires</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output_wires_distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">planar_wire_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">output_wire</span> <span class="ow">in</span> <span class="n">output_wires</span><span class="p">:</span>
                <span class="n">output_wire_center</span> <span class="o">=</span> <span class="n">output_wire</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">direction_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">output_wire_direction</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">output_wire_center</span> <span class="o">-</span> <span class="n">planar_wire_center</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">output_wire_direction</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">output_wires_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="n">output_wire</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">output_wire_center</span> <span class="o">-</span> <span class="n">planar_wire_center</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output_wires_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">output_wire</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">output_wire_center</span> <span class="o">-</span> <span class="n">center_point</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="n">output_wires_distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;projected, filtered and sorted wire list is of length </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">output_wires_distances</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">output_wires</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">output_wires_distances</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">output_wires</span></div>


<div class="viewcode-block" id="Wire.stitch">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.stitch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Wire</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempt to stich wires</span>

<span class="sd">        Args:</span>
<span class="sd">          other: Wire:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">wire_builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeWire</span><span class="p">()</span>
        <span class="n">wire_builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Wire_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>
        <span class="n">wire_builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Wire_s</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>
        <span class="n">wire_builder</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">wire_builder</span><span class="o">.</span><span class="n">Wire</span><span class="p">())</span></div>


<div class="viewcode-block" id="Wire.to_wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.to_wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Wire - used as a pair with Edge.to_wire when self is Wire | Edge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Wire.trim">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Wire.trim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;trim</span>

<span class="sd">        Create a new wire by keeping only the section between start and end.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): 0.0 &lt;= start &lt; 1.0</span>
<span class="sd">            end (float): 0.0 &lt; end &lt;= 1.0</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: start &gt;= end</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: trimmed wire</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start must be less than end&quot;</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>

        <span class="c1"># If this is really just an edge, skip the complexity of a Wire</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Wire</span><span class="p">([</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)])</span>

        <span class="c1"># For each Edge determine the beginning and end wire parameters</span>
        <span class="c1"># Note that u, v values are parameters along the Wire</span>
        <span class="n">edges_uv_values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Edge</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">found_end_of_wire</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># for finding ends of closed wires</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>  <span class="c1"># Avoid two beginnings or ends</span>
                <span class="n">u</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="n">u</span>
                    <span class="k">if</span> <span class="n">found_end_of_wire</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isclose_b</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isclose_b</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span> <span class="n">u</span>
                <span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="n">found_end_of_wire</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isclose_b</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">isclose_b</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span> <span class="n">v</span>
                <span class="p">)</span>
                <span class="n">found_end_of_wire</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">isclose_b</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">isclose_b</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">isclose_b</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">isclose_b</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">found_end_of_wire</span>
                <span class="p">)</span>

            <span class="c1"># Edge might be reversed and require flipping parms</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="n">v</span> <span class="k">else</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="n">edges_uv_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="n">trimmed_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_uv_values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># Edge not needed</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">u</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># keep whole Edge</span>
                <span class="n">trimmed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">u</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">:</span>  <span class="c1"># Wire trimmed to single Edge</span>
                <span class="n">u_edge</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
                <span class="n">v_edge</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
                <span class="n">u_edge</span><span class="p">,</span> <span class="n">v_edge</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">v_edge</span><span class="p">,</span> <span class="n">u_edge</span><span class="p">)</span> <span class="k">if</span> <span class="n">u_edge</span> <span class="o">&gt;</span> <span class="n">v_edge</span> <span class="k">else</span> <span class="p">(</span><span class="n">u_edge</span><span class="p">,</span> <span class="n">v_edge</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">trimmed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">u_edge</span><span class="p">,</span> <span class="n">v_edge</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">u</span><span class="p">:</span>  <span class="c1"># keep start of Edge</span>
                <span class="n">u_edge</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">u_edge</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">trimmed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_edge</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1">#  v &lt;= end  keep end of Edge</span>
                <span class="n">v_edge</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">v_edge</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">trimmed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">v_edge</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Wire</span><span class="p">(</span><span class="n">trimmed_edges</span><span class="p">)</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">edges_to_wires</span><span class="p">(</span><span class="n">edges</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Edge</span><span class="p">],</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert edges to a list of wires.</span>

<span class="sd">    Args:</span>
<span class="sd">      edges: Iterable[Edge]:</span>
<span class="sd">      tol: float:  (Default value = 1e-6)</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edges_in</span> <span class="o">=</span> <span class="n">TopTools_HSequenceOfShape</span><span class="p">()</span>
    <span class="n">wires_out</span> <span class="o">=</span> <span class="n">TopTools_HSequenceOfShape</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges_in</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
    <span class="n">ShapeAnalysis_FreeBounds</span><span class="o">.</span><span class="n">ConnectEdgesToWires_s</span><span class="p">(</span><span class="n">edges_in</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">wires_out</span><span class="p">)</span>

    <span class="n">wires</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires_out</span><span class="o">.</span><span class="n">Length</span><span class="p">()):</span>
        <span class="c1"># wires.append(Wire(downcast(wires_out.Value(i + 1))))</span>
        <span class="n">wires</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wire</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Wire_s</span><span class="p">(</span><span class="n">wires_out</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>

    <span class="k">return</span> <span class="n">wires</span>


<span class="k">def</span><span class="w"> </span><span class="nf">offset_topods_face</span><span class="p">(</span><span class="n">face</span><span class="p">:</span> <span class="n">TopoDS_Face</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Offset a topods_face&quot;&quot;&quot;</span>
    <span class="n">offsetor</span> <span class="o">=</span> <span class="n">BRepOffset_MakeOffset</span><span class="p">()</span>
    <span class="n">offsetor</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">Offset</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span> <span class="n">Tol</span><span class="o">=</span><span class="n">TOLERANCE</span><span class="p">)</span>
    <span class="n">offsetor</span><span class="o">.</span><span class="n">MakeOffsetShape</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">offsetor</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">topo_explore_connected_edges</span><span class="p">(</span>
    <span class="n">edge</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an edge extracted from a Shape, return the edges connected to it&quot;&quot;&quot;</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edge</span><span class="o">.</span><span class="n">topo_parent</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge has no valid parent&quot;</span><span class="p">)</span>
    <span class="n">given_topods_edge</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span>
    <span class="k">if</span> <span class="n">given_topods_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge is empty&quot;</span><span class="p">)</span>
    <span class="n">connected_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Find all the TopoDS_Edges for this Shape</span>
    <span class="n">topods_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">wrapped</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">topods_edge</span> <span class="ow">in</span> <span class="n">topods_edges</span><span class="p">:</span>
        <span class="c1"># # Don&#39;t match with the given edge</span>
        <span class="k">if</span> <span class="n">given_topods_edge</span><span class="o">.</span><span class="n">IsSame</span><span class="p">(</span><span class="n">topods_edge</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># If the edge shares a vertex with the given edge they are connected</span>
        <span class="k">if</span> <span class="n">topo_explore_common_vertex</span><span class="p">(</span><span class="n">given_topods_edge</span><span class="p">,</span> <span class="n">topods_edge</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">connected_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">topods_edge</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">connected_edges</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">topo_explore_connected_faces</span><span class="p">(</span>
    <span class="n">edge</span><span class="p">:</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TopoDS_Face</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an edge extracted from a Shape, return the topods_faces connected to it&quot;&quot;&quot;</span>

    <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">edge</span><span class="o">.</span><span class="n">topo_parent</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge has no valid parent&quot;</span><span class="p">)</span>

    <span class="c1"># make a edge --&gt; faces mapping</span>
    <span class="n">edge_face_map</span> <span class="o">=</span> <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">()</span>
    <span class="n">TopExp</span><span class="o">.</span><span class="n">MapShapesAndAncestors_s</span><span class="p">(</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">,</span> <span class="n">edge_face_map</span>
    <span class="p">)</span>

    <span class="c1"># Query the map and select only unique faces</span>
    <span class="n">unique_face_map</span> <span class="o">=</span> <span class="n">TopTools_IndexedMapOfShape</span><span class="p">()</span>
    <span class="n">unique_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">edge_face_map</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">edge_face_map</span><span class="o">.</span><span class="n">FindFromKey</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">):</span>
            <span class="n">unique_face_map</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unique_face_map</span><span class="o">.</span><span class="n">Extent</span><span class="p">()):</span>
        <span class="n">unique_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TopoDS</span><span class="o">.</span><span class="n">Face_s</span><span class="p">(</span><span class="n">unique_face_map</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">unique_faces</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gumyr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
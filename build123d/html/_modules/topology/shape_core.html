

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>topology.shape_core &mdash; build123d 0.9.2.dev40+gb1f0eed documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/sphinx_rtd_theme.css?v=3234e928" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c97902b4"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/js/hoverxref.js"></script>
      <script src="../../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../../_static/js/micromodal.min.js"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            build123d
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_builder.html">Key Concepts (builder mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../key_concepts_algebra.html">Key Concepts (algebra mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../moving_objects.html">Moving Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../OpenSCAD.html">Transitioning from OpenSCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introductory_examples.html">Introductory Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../selectors_operators.html">Selectors and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builders.html">Builders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../assemblies.html">Assemblies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips.html">Tips, Best Practices and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../import_export.html">Import/Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cheat_sheet.html">Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../external.html">External Tools and Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../builder_api_reference.html">Builder Common API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../direct_api_reference.html">Direct API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">build123d</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">topology.shape_core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for topology.shape_core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">build123d topology</span>

<span class="sd">name: shape_core.py</span>
<span class="sd">by:   Gumyr</span>
<span class="sd">date: January 07, 2025</span>

<span class="sd">desc:</span>

<span class="sd">This module defines the foundational classes and methods for the build123d CAD library, enabling</span>
<span class="sd">detailed geometric operations and 3D modeling capabilities. It provides a hierarchy of classes</span>
<span class="sd">representing various geometric entities like vertices, edges, wires, faces, shells, solids, and</span>
<span class="sd">compounds. These classes are designed to work seamlessly with the OpenCascade Python bindings,</span>
<span class="sd">leveraging its robust CAD kernel.</span>

<span class="sd">Key Features:</span>
<span class="sd">- **Shape Base Class:** Implements core functionalities such as transformations (rotation,</span>
<span class="sd">  translation, scaling), geometric queries, and boolean operations (cut, fuse, intersect).</span>
<span class="sd">- **Custom Utilities:** Includes helper classes like `ShapeList` for advanced filtering, sorting,</span>
<span class="sd">  and grouping of shapes, and `GroupBy` for organizing shapes by specific criteria.</span>
<span class="sd">- **Type Safety:** Extensive use of Python typing features ensures clarity and correctness in type</span>
<span class="sd">  handling.</span>
<span class="sd">- **Advanced Geometry:** Supports operations like finding intersections, computing bounding boxes,</span>
<span class="sd">  projecting faces, and generating triangulated meshes.</span>

<span class="sd">The module is designed for extensibility, enabling developers to build complex 3D assemblies and</span>
<span class="sd">perform detailed CAD operations programmatically while maintaining a clean and structured API.</span>

<span class="sd">license:</span>

<span class="sd">    Copyright 2025 Gumyr</span>

<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>

<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">cast</span> <span class="k">as</span> <span class="n">tcast</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Protocol</span><span class="p">,</span>
    <span class="n">SupportsIndex</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">OCP.GeomAbs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ga</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">OCP.TopAbs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.lib.pretty</span><span class="w"> </span><span class="kn">import</span> <span class="n">pretty</span><span class="p">,</span> <span class="n">RepresentationPrinter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BOPAlgo</span><span class="w"> </span><span class="kn">import</span> <span class="n">BOPAlgo_GlueEnum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRep</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRep_Tool</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAdaptor</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepAdaptor_Curve</span><span class="p">,</span> <span class="n">BRepAdaptor_Surface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepAlgoAPI</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BRepAlgoAPI_BooleanOperation</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Common</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Cut</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Fuse</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Section</span><span class="p">,</span>
    <span class="n">BRepAlgoAPI_Splitter</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepBuilderAPI</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BRepBuilderAPI_Copy</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_GTransform</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeFace</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_MakeVertex</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_RightCorner</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_RoundCorner</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_Sewing</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_Transform</span><span class="p">,</span>
    <span class="n">BRepBuilderAPI_Transformed</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepCheck</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepCheck_Analyzer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepExtrema</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepExtrema_DistShapeShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepFeat</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepFeat_SplitShape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepGProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepGProp</span><span class="p">,</span> <span class="n">BRepGProp_Face</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepIntCurveSurface</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepIntCurveSurface_Inter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepMesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepMesh_IncrementalMesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.BRepTools</span><span class="w"> </span><span class="kn">import</span> <span class="n">BRepTools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Bnd</span><span class="w"> </span><span class="kn">import</span> <span class="n">Bnd_Box</span><span class="p">,</span> <span class="n">Bnd_OBB</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GProp</span><span class="w"> </span><span class="kn">import</span> <span class="n">GProp_GProps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.Geom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geom_Line</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomAPI</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomAPI_ProjectPointOnSurf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.GeomLib</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeomLib_IsPlanarSurface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeAnalysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeAnalysis_Curve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeCustom</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeCustom</span><span class="p">,</span> <span class="n">ShapeCustom_RestrictionParameters</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeFix</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeFix_Shape</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.ShapeUpgrade</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeUpgrade_UnifySameDomain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopAbs</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopAbs_Orientation</span><span class="p">,</span> <span class="n">TopAbs_ShapeEnum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopExp</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopExp</span><span class="p">,</span> <span class="n">TopExp_Explorer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopLoc</span><span class="w"> </span><span class="kn">import</span> <span class="n">TopLoc_Location</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopTools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">,</span>
    <span class="n">TopTools_ListOfShape</span><span class="p">,</span>
    <span class="n">TopTools_SequenceOfShape</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.TopoDS</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TopoDS</span><span class="p">,</span>
    <span class="n">TopoDS_Compound</span><span class="p">,</span>
    <span class="n">TopoDS_Face</span><span class="p">,</span>
    <span class="n">TopoDS_Iterator</span><span class="p">,</span>
    <span class="n">TopoDS_Shape</span><span class="p">,</span>
    <span class="n">TopoDS_Shell</span><span class="p">,</span>
    <span class="n">TopoDS_Solid</span><span class="p">,</span>
    <span class="n">TopoDS_Vertex</span><span class="p">,</span>
    <span class="n">TopoDS_Edge</span><span class="p">,</span>
    <span class="n">TopoDS_Wire</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.gce</span><span class="w"> </span><span class="kn">import</span> <span class="n">gce_MakeLin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">OCP.gp</span><span class="w"> </span><span class="kn">import</span> <span class="n">gp_Ax1</span><span class="p">,</span> <span class="n">gp_Ax2</span><span class="p">,</span> <span class="n">gp_Ax3</span><span class="p">,</span> <span class="n">gp_Dir</span><span class="p">,</span> <span class="n">gp_Pnt</span><span class="p">,</span> <span class="n">gp_Trsf</span><span class="p">,</span> <span class="n">gp_Vec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">anytree</span><span class="w"> </span><span class="kn">import</span> <span class="n">NodeMixin</span><span class="p">,</span> <span class="n">RenderTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.build_enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">CenterOf</span><span class="p">,</span> <span class="n">GeomType</span><span class="p">,</span> <span class="n">Keep</span><span class="p">,</span> <span class="n">SortBy</span><span class="p">,</span> <span class="n">Transition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEG2RAD</span><span class="p">,</span>
    <span class="n">TOLERANCE</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">BoundBox</span><span class="p">,</span>
    <span class="n">Color</span><span class="p">,</span>
    <span class="n">Location</span><span class="p">,</span>
    <span class="n">Matrix</span><span class="p">,</span>
    <span class="n">OrientedBoundBox</span><span class="p">,</span>
    <span class="n">Plane</span><span class="p">,</span>
    <span class="n">Vector</span><span class="p">,</span>
    <span class="n">VectorLike</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.zero_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Vertex</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.one_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.two_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Shell</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.three_d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Solid</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.composite</span><span class="w"> </span><span class="kn">import</span> <span class="n">Compound</span>  <span class="c1"># pylint: disable=R0801</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">build123d.build_part</span><span class="w"> </span><span class="kn">import</span> <span class="n">BuildPart</span>  <span class="c1"># pylint: disable=R0801</span>

<span class="n">Shapes</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span> <span class="s2">&quot;Solid&quot;</span><span class="p">,</span> <span class="s2">&quot;Compound&quot;</span><span class="p">]</span>
<span class="n">TrimmingTool</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Plane</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">]</span>
<span class="n">TOPODS</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TOPODS&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">TopoDS_Shape</span><span class="p">)</span>


<div class="viewcode-block" id="Shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="p">(</span><span class="n">NodeMixin</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">TOPODS</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shape</span>

<span class="sd">    Base class for all CAD objects such as Edge, Face, Solid, etc.</span>

<span class="sd">    Args:</span>
<span class="sd">        obj (TopoDS_Shape, optional): OCCT object. Defaults to None.</span>
<span class="sd">        label (str, optional): Defaults to &#39;&#39;.</span>
<span class="sd">        color (Color, optional): Defaults to None.</span>
<span class="sd">        parent (Compound, optional): assembly parent. Defaults to None.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        wrapped (TopoDS_Shape): the OCP object</span>
<span class="sd">        label (str): user assigned label</span>
<span class="sd">        color (Color): object color</span>
<span class="sd">        joints (dict[str:Joint]): dictionary of joints bound to this object (Solid only)</span>
<span class="sd">        children (Shape): list of assembly children of this object (Compound only)</span>
<span class="sd">        topo_parent (Shape): assembly parent of this object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shape_LUT</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">:</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">:</span> <span class="s2">&quot;Wire&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">:</span> <span class="s2">&quot;Face&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SHELL</span><span class="p">:</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SOLID</span><span class="p">:</span> <span class="s2">&quot;Solid&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPOUND</span><span class="p">:</span> <span class="s2">&quot;Compound&quot;</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPSOLID</span><span class="p">:</span> <span class="s2">&quot;CompSolid&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">shape_properties_LUT</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">LinearProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">LinearProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">SurfaceProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SHELL</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">SurfaceProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SOLID</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPOUND</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPSOLID</span><span class="p">:</span> <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">inverse_shape_LUT</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shape_LUT</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">downcast_LUT</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Vertex_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Wire_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Face_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SHELL</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Shell_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_SOLID</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Solid_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPOUND</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Compound_s</span><span class="p">,</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_COMPSOLID</span><span class="p">:</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">CompSolid_s</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">geom_LUT_EDGE</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_CurveType</span><span class="p">,</span> <span class="n">GeomType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Line</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Circle</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CIRCLE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Ellipse</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">ELLIPSE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Hyperbola</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">HYPERBOLA</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Parabola</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">PARABOLA</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_BezierCurve</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">BEZIER</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_BSplineCurve</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">BSPLINE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_OffsetCurve</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">OFFSET</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_OtherCurve</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">OTHER</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">geom_LUT_FACE</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_SurfaceType</span><span class="p">,</span> <span class="n">GeomType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Plane</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">PLANE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Cylinder</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CYLINDER</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Cone</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">CONE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Sphere</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">SPHERE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_Torus</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">TORUS</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_BezierSurface</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">BEZIER</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_BSplineSurface</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">BSPLINE</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_SurfaceOfRevolution</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">REVOLUTION</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_SurfaceOfExtrusion</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">EXTRUSION</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_OffsetSurface</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">OFFSET</span><span class="p">,</span>
        <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_OtherSurface</span><span class="p">:</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">OTHER</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_transModeDict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSFORMED</span><span class="p">:</span> <span class="n">BRepBuilderAPI_Transformed</span><span class="p">,</span>
        <span class="n">Transition</span><span class="o">.</span><span class="n">ROUND</span><span class="p">:</span> <span class="n">BRepBuilderAPI_RoundCorner</span><span class="p">,</span>
        <span class="n">Transition</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span> <span class="n">BRepBuilderAPI_RightCorner</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">_DisplayNode</span><span class="p">(</span><span class="n">NodeMixin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used to create anytree structures from TopoDS_Shapes&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">address</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">position</span><span class="p">:</span> <span class="n">Vector</span> <span class="o">|</span> <span class="n">Location</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">:</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_DisplayNode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_ordered_shapes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_COMPOUND</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_COMPSOLID</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_SOLID</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_SHELL</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_WIRE</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">,</span>
        <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="c1"># ---- Constructor ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">:</span> <span class="n">TOPODS</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tcast</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="n">TOPODS</span><span class="p">],</span> <span class="n">downcast</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">for_construction</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># parent must be set following children as post install accesses children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

        <span class="c1"># Extracted objects like Vertices and Edges may need to know where they came from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topo_parent</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="c1"># pylint: disable=too-many-instance-attributes, too-many-public-methods</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimension of the object&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;area -the surface area of all faces in this Shape&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">SurfaceProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">properties</span><span class="o">.</span><span class="n">Mass</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Color</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the shape&#39;s color.  If it&#39;s None, get the color of the nearest</span>
<span class="sd">        ancestor, assign it to this Shape and return this value.&quot;&quot;&quot;</span>
        <span class="c1"># Find the correct color for this node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Find parent color</span>
            <span class="n">current_node</span><span class="p">:</span> <span class="n">Compound</span> <span class="o">|</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">while</span> <span class="n">current_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent_color</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">_color</span>
                <span class="k">if</span> <span class="n">parent_color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">node_color</span> <span class="o">=</span> <span class="n">parent_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="n">node_color</span>  <span class="c1"># Set the node&#39;s color for next time</span>
        <span class="k">return</span> <span class="n">node_color</span>

    <span class="nd">@color</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the shape&#39;s color&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeomType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the underlying geometry type.</span>

<span class="sd">        Returns:</span>
<span class="sd">            GeomType: The geometry type of the shape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine geometry type of an empty shape&quot;</span><span class="p">)</span>

        <span class="n">shape</span><span class="p">:</span> <span class="n">TopAbs_ShapeEnum</span> <span class="o">=</span> <span class="n">shapetype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">geom_LUT_EDGE</span><span class="p">[</span>
                <span class="n">BRepAdaptor_Curve</span><span class="p">(</span><span class="n">tcast</span><span class="p">(</span><span class="n">TopoDS_Edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span><span class="o">.</span><span class="n">GetType</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">geom_LUT_FACE</span><span class="p">[</span>
                <span class="n">BRepAdaptor_Surface</span><span class="p">(</span><span class="n">tcast</span><span class="p">(</span><span class="n">TopoDS_Face</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span><span class="o">.</span><span class="n">GetType</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">OTHER</span>

        <span class="k">return</span> <span class="n">geom</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;is_manifold</span>

<span class="sd">        Check if each edge in the given Shape has exactly two faces associated with it</span>
<span class="sd">        (skipping degenerate edges). If so, the shape is manifold.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: is the shape manifold or water tight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract one or more (if a Compound) shape from self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">shape_stack</span> <span class="o">=</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">shape_stack</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Create an empty indexed data map to store the edges and their corresponding faces.</span>
            <span class="n">shape_map</span> <span class="o">=</span> <span class="n">TopTools_IndexedDataMapOfShapeListOfShape</span><span class="p">()</span>

            <span class="c1"># Fill the map with edges and their associated faces in the given shape. Each edge in</span>
            <span class="c1"># the map is associated with a list of faces that share that edge.</span>
            <span class="n">TopExp</span><span class="o">.</span><span class="n">MapShapesAndAncestors_s</span><span class="p">(</span>
                <span class="c1"># shape.wrapped, ta.TopAbs_EDGE, ta.TopAbs_FACE, shape_map</span>
                <span class="n">shape</span><span class="p">,</span>
                <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">,</span>
                <span class="n">ta</span><span class="o">.</span><span class="n">TopAbs_FACE</span><span class="p">,</span>
                <span class="n">shape_map</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Iterate over the edges in the map and checks if each edge is non-degenerate and has</span>
            <span class="c1"># exactly two faces associated with it.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape_map</span><span class="o">.</span><span class="n">Extent</span><span class="p">()):</span>
                <span class="c1"># Access each edge in the map sequentially</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">TopoDS</span><span class="o">.</span><span class="n">Edge_s</span><span class="p">(</span><span class="n">shape_map</span><span class="o">.</span><span class="n">FindKey</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

                <span class="n">vertex0</span> <span class="o">=</span> <span class="n">TopoDS_Vertex</span><span class="p">()</span>
                <span class="n">vertex1</span> <span class="o">=</span> <span class="n">TopoDS_Vertex</span><span class="p">()</span>

                <span class="c1"># Extract the two vertices of the current edge and stores them in vertex0/1.</span>
                <span class="n">TopExp</span><span class="o">.</span><span class="n">Vertices_s</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">vertex0</span><span class="p">,</span> <span class="n">vertex1</span><span class="p">)</span>

                <span class="c1"># Check if both vertices are null and if they are the same vertex. If so, the</span>
                <span class="c1"># edge is considered degenerate (i.e., has zero length), and it is skipped.</span>
                <span class="k">if</span> <span class="n">vertex0</span><span class="o">.</span><span class="n">IsNull</span><span class="p">()</span> <span class="ow">and</span> <span class="n">vertex1</span><span class="o">.</span><span class="n">IsNull</span><span class="p">()</span> <span class="ow">and</span> <span class="n">vertex0</span><span class="o">.</span><span class="n">IsSame</span><span class="p">(</span><span class="n">vertex1</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Check if the current edge has exactly two faces associated with it. If not,</span>
                <span class="c1"># it means the edge is not shared by exactly two faces, indicating that the</span>
                <span class="c1"># shape is not manifold.</span>
                <span class="k">if</span> <span class="n">shape_map</span><span class="o">.</span><span class="n">FindFromIndex</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Extent</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_planar_face</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the shape a planar face even though its geom_type may not be PLANE&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Face</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">surface</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Surface_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">is_face_planar</span> <span class="o">=</span> <span class="n">GeomLib_IsPlanarSurface</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_face_planar</span><span class="o">.</span><span class="n">IsPlanar</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get this Shape&#39;s Location&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Location</span><span class="p">())</span>

    <span class="nd">@location</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Location</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set Shape&#39;s Location to value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">matrix_of_inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the inertia matrix (moment of inertia tensor) of the shape.</span>

<span class="sd">        The inertia matrix represents how the mass of the shape is distributed</span>
<span class="sd">        with respect to its reference frame. It is a 3×3 symmetric tensor that</span>
<span class="sd">        describes the resistance of the shape to rotational motion around</span>
<span class="sd">        different axes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[list[float]]: A 3×3 nested list representing the inertia matrix.</span>
<span class="sd">            The elements of the matrix are given as:</span>

<span class="sd">            | Ixx  Ixy  Ixz |</span>
<span class="sd">            | Ixy  Iyy  Iyz |</span>
<span class="sd">            | Ixz  Iyz  Izz |</span>

<span class="sd">            where:</span>
<span class="sd">            - Ixx, Iyy, Izz are the moments of inertia about the X, Y, and Z axes.</span>
<span class="sd">            - Ixy, Ixz, Iyz are the products of inertia.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; obj = MyShape()</span>
<span class="sd">            &gt;&gt;&gt; obj.matrix_of_inertia</span>
<span class="sd">            [[1000.0, 50.0, 0.0],</span>
<span class="sd">            [50.0, 1200.0, 0.0],</span>
<span class="sd">            [0.0, 0.0, 300.0]]</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The inertia matrix is computed relative to the shape&#39;s center of mass.</span>
<span class="sd">            - It is commonly used in structural analysis, mechanical simulations,</span>
<span class="sd">              and physics-based motion calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="n">inertia_matrix</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">MatrixOfInertia</span><span class="p">()</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">inertia_matrix</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the orientation component of this Shape&#39;s Location&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">orientation</span>

    <span class="nd">@orientation</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotations</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the orientation component of this Shape&#39;s Location to rotations&quot;&quot;&quot;</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">loc</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the position component of this Shape&#39;s Location&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">position</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the position component of this Shape&#39;s Location to value&quot;&quot;&quot;</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">loc</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">principal_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Vector</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the principal moments of inertia and their corresponding axes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[Vector, float]]: A list of tuples, where each tuple contains:</span>
<span class="sd">            - A `Vector` representing the axis of inertia.</span>
<span class="sd">            - A `float` representing the moment of inertia for that axis.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; obj = MyShape()</span>
<span class="sd">            &gt;&gt;&gt; obj.principal_properties</span>
<span class="sd">            [(Vector(1, 0, 0), 1200.0),</span>
<span class="sd">            (Vector(0, 1, 0), 1000.0),</span>
<span class="sd">            (Vector(0, 0, 1), 300.0)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="n">principal_props</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">PrincipalProperties</span><span class="p">()</span>
        <span class="n">principal_moments</span> <span class="o">=</span> <span class="n">principal_props</span><span class="o">.</span><span class="n">Moments</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">principal_props</span><span class="o">.</span><span class="n">FirstAxisOfInertia</span><span class="p">()),</span> <span class="n">principal_moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">principal_props</span><span class="o">.</span><span class="n">SecondAxisOfInertia</span><span class="p">()),</span> <span class="n">principal_moments</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">principal_props</span><span class="o">.</span><span class="n">ThirdAxisOfInertia</span><span class="p">()),</span> <span class="n">principal_moments</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the static moments (first moments of mass) of the shape.</span>

<span class="sd">        The static moments represent the weighted sum of the coordinates</span>
<span class="sd">        with respect to the mass distribution, providing insight into the</span>
<span class="sd">        center of mass and mass distribution of the shape.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[float, float, float]: The static moments (Mx, My, Mz),</span>
<span class="sd">            where:</span>
<span class="sd">            - Mx is the first moment of mass about the YZ plane.</span>
<span class="sd">            - My is the first moment of mass about the XZ plane.</span>
<span class="sd">            - Mz is the first moment of mass about the XY plane.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; obj = MyShape()</span>
<span class="sd">            &gt;&gt;&gt; obj.static_moments</span>
<span class="sd">            (150.0, 200.0, 50.0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">properties</span><span class="o">.</span><span class="n">StaticMoments</span><span class="p">()</span>

    <span class="c1"># ---- Class Methods ----</span>

<div class="viewcode-block" id="Shape.cast">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.cast">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span> <span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the right type of wrapper, given a OCCT object&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Shape.extrude">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.extrude">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrude</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;extrude</span>

<span class="sd">        Extrude a Shape in the provided direction.</span>
<span class="sd">        * Vertices generate Edges</span>
<span class="sd">        * Edges generate Faces</span>
<span class="sd">        * Wires generate Shells</span>
<span class="sd">        * Faces generate Solids</span>
<span class="sd">        * Shells generate Compounds</span>

<span class="sd">        Args:</span>
<span class="sd">            direction (VectorLike): direction and magnitude of extrusion</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Unsupported class</span>
<span class="sd">            RuntimeError: Generated invalid result</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge | Face | Shell | Solid | Compound: extruded shape</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># ---- Static Methods ----</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_build_tree</span><span class="p">(</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_DisplayNode</span><span class="p">],</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">_DisplayNode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="n">TopAbs_ShapeEnum</span> <span class="o">=</span> <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">,</span>
        <span class="n">show_center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_DisplayNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an anytree copy of the TopoDS_Shape structure&quot;&quot;&quot;</span>

        <span class="n">obj_type</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">shape_LUT</span><span class="p">[</span><span class="n">shape</span><span class="o">.</span><span class="n">ShapeType</span><span class="p">()]</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">Vector</span> <span class="o">|</span> <span class="n">Location</span>
        <span class="k">if</span> <span class="n">show_center</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">Location</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">Location</span><span class="p">())</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Shape</span><span class="o">.</span><span class="n">_DisplayNode</span><span class="p">(</span><span class="n">obj_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">loc</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">TopoDS_Iterator</span><span class="p">()</span>
        <span class="n">iterator</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">parent_node</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">iterator</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_ordered_shapes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                <span class="n">child</span><span class="o">.</span><span class="n">ShapeType</span><span class="p">()</span>
            <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_ordered_shapes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
                <span class="n">Shape</span><span class="o">.</span><span class="n">_build_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">parent_node</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
            <span class="n">iterator</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_show_tree</span><span class="p">(</span><span class="n">root_node</span><span class="p">,</span> <span class="n">show_center</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display an assembly or TopoDS_Shape anytree structure&quot;&quot;&quot;</span>

        <span class="c1"># Calculate the size of the tree labels</span>
        <span class="n">size_tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root_node</span><span class="o">.</span><span class="n">descendants</span><span class="p">]</span>
        <span class="n">size_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">root_node</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">root_node</span><span class="o">.</span><span class="n">label</span><span class="p">)))</span>
        <span class="c1"># pylint: disable=cell-var-from-loop</span>
        <span class="n">size_tuples_per_level</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ll</span><span class="p">:</span> <span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_tuples</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">root_node</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">max_sizes_per_level</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">level</span><span class="p">))</span> <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">size_tuples_per_level</span>
        <span class="p">]</span>
        <span class="n">level_sizes_per_level</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">l</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">max_sizes_per_level</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">tree_label_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">level_sizes_per_level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Build the tree line by line</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pre</span><span class="p">,</span> <span class="n">_fill</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">RenderTree</span><span class="p">(</span><span class="n">root_node</span><span class="p">):</span>
            <span class="n">treestr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">tree_label_width</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">root_node</span><span class="p">,</span> <span class="s2">&quot;address&quot;</span><span class="p">):</span>
                <span class="n">address</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Center&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">show_center</span>
                    <span class="k">else</span> <span class="s2">&quot;Position&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">address</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Center&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">show_center</span>
                    <span class="k">else</span> <span class="s2">&quot;Location&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">treestr</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">at </span><span class="si">{</span><span class="n">address</span><span class="si">:</span><span class="s2">#x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Shape.combined_center">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.combined_center">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">combined_center</span><span class="p">(</span>
        <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">],</span> <span class="n">center_of</span><span class="p">:</span> <span class="n">CenterOf</span> <span class="o">=</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">MASS</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;combined center</span>

<span class="sd">        Calculates the center of a multiple objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            objects (Iterable[Shape]): list of objects</span>
<span class="sd">            center_of (CenterOf, optional): centering option. Defaults to CenterOf.MASS.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: CenterOf.GEOMETRY not implemented</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: center of multiple objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">MASS</span><span class="p">:</span>
            <span class="n">total_mass</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Shape</span><span class="o">.</span><span class="n">compute_mass</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">)</span>
            <span class="n">weighted_centers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">o</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">CenterOf</span><span class="o">.</span><span class="n">MASS</span><span class="p">)</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">Shape</span><span class="o">.</span><span class="n">compute_mass</span><span class="p">(</span><span class="n">o</span><span class="p">))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span>
            <span class="p">]</span>

            <span class="n">sum_wc</span> <span class="o">=</span> <span class="n">weighted_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">weighted_center</span> <span class="ow">in</span> <span class="n">weighted_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">sum_wc</span> <span class="o">=</span> <span class="n">sum_wc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">weighted_center</span><span class="p">)</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">sum_wc</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">total_mass</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">center_of</span> <span class="o">==</span> <span class="n">CenterOf</span><span class="o">.</span><span class="n">BOUNDING_BOX</span><span class="p">:</span>
            <span class="n">total_mass</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span>

            <span class="n">weighted_centers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="n">weighted_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>

            <span class="n">sum_wc</span> <span class="o">=</span> <span class="n">weighted_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">weighted_center</span> <span class="ow">in</span> <span class="n">weighted_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">sum_wc</span> <span class="o">=</span> <span class="n">sum_wc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">weighted_center</span><span class="p">)</span>

            <span class="n">middle</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">sum_wc</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">total_mass</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;CenterOf.GEOMETRY not implemented&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">middle</span></div>


<div class="viewcode-block" id="Shape.compute_mass">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.compute_mass">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_mass</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the &#39;mass&#39; of an object.</span>

<span class="sd">        Args:</span>
<span class="sd">          obj: Compute the mass of this object</span>
<span class="sd">          obj: Shape:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">calc_function</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">shape_properties_LUT</span><span class="p">[</span><span class="n">shapetype</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">calc_function</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">calc_function</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">properties</span><span class="o">.</span><span class="n">Mass</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.get_shape_list">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.get_shape_list">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape_list</span><span class="p">(</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
        <span class="n">entity_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span> <span class="s2">&quot;Solid&quot;</span><span class="p">,</span> <span class="s2">&quot;Compound&quot;</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper to extract entities of a specific type from a shape.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span>
        <span class="n">shape_list</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
            <span class="p">[</span><span class="n">shape</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">entities</span><span class="p">(</span><span class="n">entity_type</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">shape_list</span><span class="p">:</span>
            <span class="n">item</span><span class="o">.</span><span class="n">topo_parent</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">return</span> <span class="n">shape_list</span></div>


<div class="viewcode-block" id="Shape.get_single_shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.get_single_shape">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_single_shape</span><span class="p">(</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
        <span class="n">entity_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span> <span class="s2">&quot;Solid&quot;</span><span class="p">,</span> <span class="s2">&quot;Compound&quot;</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper to extract a single entity of a specific type from a shape,</span>
<span class="sd">        with a warning if count != 1.&quot;&quot;&quot;</span>
        <span class="n">shape_list</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">get_shape_list</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">)</span>
        <span class="n">entity_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">entity_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">entity_count</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">entity_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">s, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">shape_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape_list</span> <span class="k">else</span> <span class="kc">None</span></div>


    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Shape.__add__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__add__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fuse shape to self operator +&quot;&quot;&quot;</span>
        <span class="c1"># Convert `other` to list of base objects and filter out None values</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">summands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summands</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">shape</span>
                <span class="c1"># for o in (other if isinstance(other, (list, tuple)) else [other])</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="p">([</span><span class="n">other</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">get_top_level_shapes</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="c1"># If there is nothing to add return the original object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">summands</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Check that all dimensions are the same</span>
        <span class="n">addend_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>
        <span class="k">if</span> <span class="n">addend_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensions of objects to add to are inconsistent&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">summand</span><span class="o">.</span><span class="n">_dim</span> <span class="o">==</span> <span class="n">addend_dim</span> <span class="k">for</span> <span class="n">summand</span> <span class="ow">in</span> <span class="n">summands</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only shapes with the same dimension can be added&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># an empty object</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">summands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">summands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">summands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sum_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">summands</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sum_shape</span> <span class="o">=</span> <span class="n">sum_shape</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sum_shape</span></div>


<div class="viewcode-block" id="Shape.__and__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__and__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;intersect shape with self operator &amp;&quot;&quot;&quot;</span>
        <span class="n">others</span> <span class="o">=</span> <span class="n">other</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot intersect shape with empty compound&quot;</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="o">*</span><span class="n">others</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">new_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">new_shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span>
        <span class="p">):</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_shape</span></div>


<div class="viewcode-block" id="Shape.__copy__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__copy__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return shallow copy or reference of self</span>

<span class="sd">        Create an copy of this Shape that shares the underlying TopoDS_TShape.</span>

<span class="sd">        Used when there is a need for many objects with the same CAD structure but at</span>
<span class="sd">        different Locations, etc. - for examples fasteners in a larger assembly. By</span>
<span class="sd">        sharing the TopoDS_TShape, the memory size of such assemblies can be greatly reduced.</span>

<span class="sd">        Changes to the CAD structure of the base object will be reflected in all instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">reference</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">)</span>  <span class="c1"># Ensure mypy knows reference.wrapped is not None</span>
            <span class="n">reference</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">TShape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">TShape</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">reference</span></div>


<div class="viewcode-block" id="Shape.__deepcopy__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__deepcopy__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return deepcopy of self&quot;&quot;&quot;</span>
        <span class="c1"># The wrapped object is a OCCT TopoDS_Shape which can&#39;t be pickled or copied</span>
        <span class="c1"># with the standard python copy/deepcopy, so create a deepcopy &#39;memo&#39; with this</span>
        <span class="c1"># value already copied which causes deepcopy to skip it.</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)]</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">BRepBuilderAPI_Copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;topo_parent&quot;</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">topo_parent</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;joints&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">joint</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">joints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">joint</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Shape.__eq__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__eq__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two shapes are the same.</span>

<span class="sd">        This method checks if the current shape is the same as the other shape.</span>
<span class="sd">        Two shapes are considered the same if they share the same TShape with</span>
<span class="sd">        the same Locations. Orientations may differ.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Shape): The shape to compare with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the shapes are the same, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_same</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="Shape.__hash__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__hash__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return hash code&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.__rmul__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__rmul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;right multiply for positioning operator *&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="n">Location</span><span class="p">,</span> <span class="n">Plane</span><span class="p">))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;shapes can only be multiplied list of locations or planes&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">loc</span> <span class="o">*</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span></div>


<div class="viewcode-block" id="Shape.__sub__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.__sub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;cut shape from self operator -&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot subtract shape from empty compound&quot;</span><span class="p">)</span>

        <span class="c1"># Convert `other` to list of base objects and filter out None values</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subtrahends</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subtrahends</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">shape</span>
                <span class="c1"># for o in (other if isinstance(other, (list, tuple)) else [other])</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="p">([</span><span class="n">other</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">get_top_level_shapes</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="c1"># If there is nothing to subtract return the original object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subtrahends</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Check that all dimensions are the same</span>
        <span class="n">minuend_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>
        <span class="k">if</span> <span class="n">minuend_dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subtrahends</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensions of objects to subtract from are inconsistent&quot;</span><span class="p">)</span>

        <span class="c1"># Check that the operation is valid</span>
        <span class="n">subtrahend_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">_dim</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subtrahends</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">minuend_dim</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">subtrahend_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Only shapes with equal or greater dimension can be subtracted: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">minuend_dim</span><span class="si">}</span><span class="s2">D) and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="n">subtrahend_dims</span><span class="p">)</span><span class="si">}</span><span class="s2">D)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Do the actual cut operation</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="o">*</span><span class="n">subtrahends</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">difference</span></div>


<div class="viewcode-block" id="Shape.bounding_box">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.bounding_box">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounding_box</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">optimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a bounding box for this Shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance (float, optional): Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            BoundBox: A box sized to contain this Shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundBox</span><span class="p">(</span><span class="n">Bnd_Box</span><span class="p">())</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">TOLERANCE</span> <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tolerance</span>
        <span class="k">return</span> <span class="n">BoundBox</span><span class="o">.</span><span class="n">from_topo_ds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">optimal</span><span class="o">=</span><span class="n">optimal</span><span class="p">)</span></div>


    <span class="c1"># Actually creating the abstract method causes the subclass to pass center_of</span>
    <span class="c1"># even when not required - possibly this could be improved.</span>
    <span class="c1"># @abstractmethod</span>
    <span class="c1"># def center(self, center_of: CenterOf) -&gt; Vector:</span>
    <span class="c1">#     &quot;&quot;&quot;Compute the center with a specific type of calculation.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Shape.clean">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.clean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;clean</span>

<span class="sd">        Remove internal edges</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: Original object with extraneous internal edges removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">upgrader</span> <span class="o">=</span> <span class="n">ShapeUpgrade_UnifySameDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">upgrader</span><span class="o">.</span><span class="n">AllowInternalEdges</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># upgrader.SetAngularTolerance(1e-5)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">upgrader</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">downcast</span><span class="p">(</span><span class="n">upgrader</span><span class="o">.</span><span class="n">Shape</span><span class="p">()))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to clean </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Shape.closest_points">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.closest_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">closest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Vector</span><span class="p">,</span> <span class="n">Vector</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Points on two shapes where the distance between them is minimal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_with_closest_points</span><span class="p">(</span><span class="n">other</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span></div>


<div class="viewcode-block" id="Shape.compound">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.compound">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compound</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Compound&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Shape.compounds">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.compounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Compound</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compounds - all the compounds in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.copy_attributes_to">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.copy_attributes_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy_attributes_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">exceptions</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy common object attributes to target</span>

<span class="sd">        Note that preset attributes of target will not be overridden.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (Shape): object to gain attributes</span>
<span class="sd">            exceptions (Iterable[str], optional): attributes not to copy</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: invalid attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find common attributes and eliminate exceptions</span>
        <span class="n">attrs1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">attrs2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">common_attrs</span> <span class="o">=</span> <span class="n">attrs1</span> <span class="o">&amp;</span> <span class="n">attrs2</span>
        <span class="k">if</span> <span class="n">exceptions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">common_attrs</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exceptions</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">:</span>
            <span class="c1"># Copy the attribute only if the target&#39;s attribute not set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="c1"># Attach joints to the new part</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;joints&quot;</span><span class="p">:</span>
                <span class="n">joint</span><span class="p">:</span> <span class="n">Joint</span>
                <span class="k">for</span> <span class="n">joint</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">joints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">joint</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">target</span></div>


<div class="viewcode-block" id="Shape.cut">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.cut">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">to_cut</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the positional arguments from this Shape.</span>

<span class="sd">        Args:</span>
<span class="sd">          *to_cut: Shape:</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self | ShapeList[Self]: Resulting object may be of a different class than self</span>
<span class="sd">                or a ShapeList if multiple non-Compound object created</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cut_op</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Cut</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_op</span><span class="p">((</span><span class="bp">self</span><span class="p">,),</span> <span class="n">to_cut</span><span class="p">,</span> <span class="n">cut_op</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.distance">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimal distance between two shapes</span>

<span class="sd">        Args:</span>
<span class="sd">          other: Shape:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate distance to or from an empty shape&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BRepExtrema_DistShapeShape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.distance_to">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.distance_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimal distance between two shapes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_with_closest_points</span><span class="p">(</span><span class="n">other</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Shape.distance_to_with_closest_points">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.distance_to_with_closest_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to_with_closest_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">VectorLike</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">Vector</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimal distance between two shapes and the points on each shape&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate distance to or from an empty shape&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">topods_shape</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TopoDS_Shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">topods_shape</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_MakeVertex</span><span class="p">(</span>
                <span class="n">gp_Pnt</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">vec</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">Vertex</span><span class="p">()</span>

        <span class="n">dist_calc</span> <span class="o">=</span> <span class="n">BRepExtrema_DistShapeShape</span><span class="p">()</span>
        <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS2</span><span class="p">(</span><span class="n">topods_shape</span><span class="p">)</span>
        <span class="n">dist_calc</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">dist_calc</span><span class="o">.</span><span class="n">Value</span><span class="p">(),</span>
            <span class="n">Vector</span><span class="p">(</span><span class="n">dist_calc</span><span class="o">.</span><span class="n">PointOnShape1</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">Vector</span><span class="p">(</span><span class="n">dist_calc</span><span class="o">.</span><span class="n">PointOnShape2</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Shape.distances">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.distances">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimal distances to between self and other shapes</span>

<span class="sd">        Args:</span>
<span class="sd">          *others: Shape:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate distance to or from an empty shape&quot;</span><span class="p">)</span>

        <span class="n">dist_calc</span> <span class="o">=</span> <span class="n">BRepExtrema_DistShapeShape</span><span class="p">()</span>
        <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">other_shape</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot calculate distance to or from an empty shape&quot;</span><span class="p">)</span>
            <span class="n">dist_calc</span><span class="o">.</span><span class="n">LoadS2</span><span class="p">(</span><span class="n">other_shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="n">dist_calc</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>

            <span class="k">yield</span> <span class="n">dist_calc</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.edge">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Edge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="c1"># Note all sub-classes have vertices and vertex methods</span>

<div class="viewcode-block" id="Shape.edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;edges - all the edges in this Shape - subclasses may override&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.entities">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.entities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topo_type</span><span class="p">:</span> <span class="n">Shapes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TopoDS_Shape</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all of the TopoDS sub entities of the given type&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">_topods_entities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">topo_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.face">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.face">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">face</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Face&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Shape.faces">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;faces - all the faces in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.faces_intersected_by_axis">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.faces_intersected_by_axis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">faces_intersected_by_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Line Intersection</span>

<span class="sd">        Computes the intersections between the provided axis and the faces of this Shape</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Axis): Axis on which the intersection line rests</span>
<span class="sd">            tol (float, optional): Intersection tolerance. Defaults to 1e-4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Face]: A list of intersected faces sorted by distance from axis.position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">gce_MakeLin</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>

        <span class="n">intersect_maker</span> <span class="o">=</span> <span class="n">BRepIntCurveSurface_Inter</span><span class="p">()</span>
        <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="n">faces_dist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># using a list instead of a dictionary to be able to sort it</span>
        <span class="k">while</span> <span class="n">intersect_maker</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">inter_pt</span> <span class="o">=</span> <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Pnt</span><span class="p">()</span>

            <span class="n">distance</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">()</span><span class="o">.</span><span class="n">SquareDistance</span><span class="p">(</span><span class="n">inter_pt</span><span class="p">)</span>

            <span class="n">faces_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Face</span><span class="p">(),</span>
                    <span class="nb">abs</span><span class="p">(</span><span class="n">distance</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># will sort all intersected faces by distance whatever the direction is</span>

            <span class="n">intersect_maker</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

        <span class="n">faces_dist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces_dist</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">])</span></div>


<div class="viewcode-block" id="Shape.fix">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.fix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fix - try to fix shape if not valid&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="n">shape_copy</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">shape_copy</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">shape_copy</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Shape.fuse">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.fuse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fuse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">to_fuse</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">glue</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fuse</span>

<span class="sd">        Fuse a sequence of shapes into a single shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            to_fuse (sequence Shape): shapes to fuse</span>
<span class="sd">            glue (bool, optional): performance improvement for some shapes. Defaults to False.</span>
<span class="sd">            tol (float, optional): tolerance. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self | ShapeList[Self]: Resulting object may be of a different class than self</span>
<span class="sd">                or a ShapeList if multiple non-Compound object created</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fuse_op</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Fuse</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">glue</span><span class="p">:</span>
            <span class="n">fuse_op</span><span class="o">.</span><span class="n">SetGlue</span><span class="p">(</span><span class="n">BOPAlgo_GlueEnum</span><span class="o">.</span><span class="n">BOPAlgo_GlueShift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">fuse_op</span><span class="o">.</span><span class="n">SetFuzzyValue</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_op</span><span class="p">((</span><span class="bp">self</span><span class="p">,),</span> <span class="n">to_fuse</span><span class="p">,</span> <span class="n">fuse_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_value</span></div>


    <span class="c1"># def _entities_from(</span>
    <span class="c1">#     self, child_type: Shapes, parent_type: Shapes</span>
    <span class="c1"># ) -&gt; Dict[Shape, list[Shape]]:</span>
    <span class="c1">#     &quot;&quot;&quot;This function is very slow on M1 macs and is currently unused&quot;&quot;&quot;</span>
    <span class="c1">#     if self.wrapped is None:</span>
    <span class="c1">#         return {}</span>

    <span class="c1">#     res = TopTools_IndexedDataMapOfShapeListOfShape()</span>

    <span class="c1">#     TopExp.MapShapesAndAncestors_s(</span>
    <span class="c1">#         self.wrapped,</span>
    <span class="c1">#         Shape.inverse_shape_LUT[child_type],</span>
    <span class="c1">#         Shape.inverse_shape_LUT[parent_type],</span>
    <span class="c1">#         res,</span>
    <span class="c1">#     )</span>

    <span class="c1">#     out: Dict[Shape, list[Shape]] = {}</span>
    <span class="c1">#     for i in range(1, res.Extent() + 1):</span>
    <span class="c1">#         out[self.__class__.cast(res.FindKey(i))] = [</span>
    <span class="c1">#             self.__class__.cast(el) for el in res.FindFromIndex(i)</span>
    <span class="c1">#         ]</span>

    <span class="c1">#     return out</span>

<div class="viewcode-block" id="Shape.get_top_level_shapes">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.get_top_level_shapes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_top_level_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Shape</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the first level of child shapes from the shape.</span>

<span class="sd">        This method collects all the non-compound shapes directly contained in the</span>
<span class="sd">        current shape. If the wrapped shape is a `TopoDS_Compound`, it traverses</span>
<span class="sd">        its immediate children and collects all shapes that are not further nested</span>
<span class="sd">        compounds. Nested compounds are traversed to gather their non-compound elements</span>
<span class="sd">        without returning the nested compound itself.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Shape]: A list of all first-level non-compound child shapes.</span>

<span class="sd">        Example:</span>
<span class="sd">            If the current shape is a compound containing both simple shapes</span>
<span class="sd">            (e.g., edges, vertices) and other compounds, the method returns a list</span>
<span class="sd">            of only the simple shapes directly contained at the top level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Shape.intersect">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.intersect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">to_intersect</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Plane</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersection of the arguments and this shape</span>

<span class="sd">        Args:</span>
<span class="sd">            to_intersect (sequence of Union[Shape, Axis, Plane]): Shape(s) to</span>
<span class="sd">                intersect with</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self | ShapeList[Self]: Resulting object may be of a different class than self</span>
<span class="sd">                or a ShapeList if multiple non-Compound object created</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_to_vertex</span><span class="p">(</span><span class="n">vec</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper method to convert vector to shape&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                <span class="n">downcast</span><span class="p">(</span>
                    <span class="n">BRepBuilderAPI_MakeVertex</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">vec</span><span class="o">.</span><span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">Vertex</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_to_edge</span><span class="p">(</span><span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper method to convert axis to shape&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
                <span class="n">BRepBuilderAPI_MakeEdge</span><span class="p">(</span>
                    <span class="n">Geom_Line</span><span class="p">(</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">direction</span><span class="o">.</span><span class="n">to_dir</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">Edge</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_to_face</span><span class="p">(</span><span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper method to convert plane to shape&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">BRepBuilderAPI_MakeFace</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Face</span><span class="p">())</span>

        <span class="c1"># Convert any geometry objects into their respective topology objects</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_intersect</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
                <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_to_vertex</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
                <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_to_edge</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
                <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_to_face</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Location</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot intersect with an empty location&quot;</span><span class="p">)</span>
                <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_to_vertex</span><span class="p">(</span><span class="n">tcast</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">position</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># Find the shape intersections</span>
        <span class="n">intersect_op</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Common</span><span class="p">()</span>
        <span class="n">shape_intersections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_op</span><span class="p">((</span><span class="bp">self</span><span class="p">,),</span> <span class="n">objs</span><span class="p">,</span> <span class="n">intersect_op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape_intersections</span><span class="p">,</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape_intersections</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape_intersections</span><span class="p">,</span> <span class="n">ShapeList</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">shape_intersections</span><span class="o">.</span><span class="n">is_null</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">shape_intersections</span></div>


<div class="viewcode-block" id="Shape.is_equal">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.is_equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if two shapes are equal, i.e. if they share the same</span>
<span class="sd">        TShape with the same Locations and Orientations. Also see</span>
<span class="sd">        :py:meth:`is_same`.</span>

<span class="sd">        Args:</span>
<span class="sd">          other: Shape:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">IsEqual</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.is_null">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.is_null">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_null</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns true if this shape is null. In other words, it references no</span>
<span class="sd">        underlying shape with the potential to be given a location and an</span>
<span class="sd">        orientation.</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">IsNull</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.is_same">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.is_same">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if other and this shape are same, i.e. if they share the</span>
<span class="sd">        same TShape with the same Locations. Orientations may differ. Also see</span>
<span class="sd">        :py:meth:`is_equal`</span>

<span class="sd">        Args:</span>
<span class="sd">          other: Shape:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">IsSame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.is_valid">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.is_valid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if no defect is detected on the shape S or any of its</span>
<span class="sd">        subshapes. See the OCCT docs on BRepCheck_Analyzer::IsValid for a full</span>
<span class="sd">        description of what is checked.</span>

<span class="sd">        Args:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="n">BRepCheck_Analyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="n">chk</span><span class="o">.</span><span class="n">SetParallel</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chk</span><span class="o">.</span><span class="n">IsValid</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.locate">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.locate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">locate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a location in absolute sense to self</span>

<span class="sd">        Args:</span>
<span class="sd">          loc: Location:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot locate an empty shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot locate a shape at an empty location&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Shape.located">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.located">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">located</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;located</span>

<span class="sd">        Apply a location in absolute sense to a copy of self</span>

<span class="sd">        Args:</span>
<span class="sd">            loc (Location): new absolute location</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: copy of Shape at location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot locate an empty shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot locate a shape at an empty location&quot;</span><span class="p">)</span>
        <span class="n">shape_copy</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">shape_copy</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">shape_copy</span></div>


<div class="viewcode-block" id="Shape.mesh">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">angular_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate triangulation if none exists.</span>

<span class="sd">        Args:</span>
<span class="sd">          tolerance: float:</span>
<span class="sd">          angular_tolerance: float:  (Default value = 0.1)</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot mesh an empty shape&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">BRepTools</span><span class="o">.</span><span class="n">Triangulation_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="n">BRepMesh_IncrementalMesh</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">angular_tolerance</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Shape.mirror">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.mirror">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mirror_plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a mirror transform to this Shape. Does not duplicate objects</span>
<span class="sd">        about the plane.</span>

<span class="sd">        Args:</span>
<span class="sd">          mirror_plane (Plane): The plane to mirror about. Defaults to Plane.XY</span>
<span class="sd">        Returns:</span>
<span class="sd">          The mirrored shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mirror_plane</span><span class="p">:</span>
            <span class="n">mirror_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">XY</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">transformation</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">SetMirror</span><span class="p">(</span>
            <span class="n">gp_Ax2</span><span class="p">(</span><span class="n">mirror_plane</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">to_pnt</span><span class="p">(),</span> <span class="n">mirror_plane</span><span class="o">.</span><span class="n">z_dir</span><span class="o">.</span><span class="n">to_dir</span><span class="p">())</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.move">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.move">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a location in relative sense (i.e. update current location) to self</span>

<span class="sd">        Args:</span>
<span class="sd">          loc: Location:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot move an empty shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot move a shape at an empty location&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Move</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Shape.moved">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.moved">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">moved</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;moved</span>

<span class="sd">        Apply a location in relative sense (i.e. update current location) to a copy of self</span>

<span class="sd">        Args:</span>
<span class="sd">            loc (Location): new location relative to current location</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: copy of Shape moved to relative location</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot move an empty shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot move a shape at an empty location&quot;</span><span class="p">)</span>
        <span class="n">shape_copy</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">shape_copy</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">downcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Moved</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">shape_copy</span></div>


<div class="viewcode-block" id="Shape.oriented_bounding_box">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.oriented_bounding_box">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">oriented_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OrientedBoundBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an oriented bounding box for this Shape.</span>

<span class="sd">        Returns:</span>
<span class="sd">            OrientedBoundBox: A box oriented and sized to contain this Shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OrientedBoundBox</span><span class="p">(</span><span class="n">Bnd_OBB</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">OrientedBoundBox</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.project_faces">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.project_faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_faces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">faces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Edge</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Projected Faces following the given path on Shape</span>

<span class="sd">        Project by positioning each face of to the shape along the path and</span>
<span class="sd">        projecting onto the surface.</span>

<span class="sd">        Note that projection may result in distortion depending on</span>
<span class="sd">        the shape at a position along the path.</span>

<span class="sd">        .. image:: projectText.png</span>

<span class="sd">        Args:</span>
<span class="sd">            faces (Union[list[Face], Compound]): faces to project</span>
<span class="sd">            path: Path on the Shape to follow</span>
<span class="sd">            start: Relative location on path to start the faces. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The projected faces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">path_length</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span>
        <span class="c1"># The derived classes of Shape implement center</span>
        <span class="n">shape_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">faces</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>

        <span class="n">first_face_min_x</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">X</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;projecting </span><span class="si">%d</span><span class="s2"> face(s)&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">))</span>

        <span class="c1"># Position each face normal to the surface along the path and project to the surface</span>
        <span class="n">projected_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span>
            <span class="n">face_center_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">bbox</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">relative_position_on_wire</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">face_center_x</span> <span class="o">-</span> <span class="n">first_face_min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">path_length</span>
            <span class="p">)</span>
            <span class="n">path_position</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">position_at</span><span class="p">(</span><span class="n">relative_position_on_wire</span><span class="p">)</span>
            <span class="n">path_tangent</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">tangent_at</span><span class="p">(</span><span class="n">relative_position_on_wire</span><span class="p">)</span>
            <span class="n">projection_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">path_position</span><span class="p">,</span> <span class="n">shape_center</span> <span class="o">-</span> <span class="n">path_position</span><span class="p">)</span>
            <span class="p">(</span><span class="n">surface_point</span><span class="p">,</span> <span class="n">surface_normal</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_intersection_points</span><span class="p">(</span>
                <span class="n">projection_axis</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">surface_normal_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span>
                <span class="n">origin</span><span class="o">=</span><span class="n">surface_point</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="n">path_tangent</span><span class="p">,</span> <span class="n">z_dir</span><span class="o">=</span><span class="n">surface_normal</span>
            <span class="p">)</span>
            <span class="n">projection_face</span><span class="p">:</span> <span class="n">Face</span> <span class="o">=</span> <span class="n">surface_normal_plane</span><span class="o">.</span><span class="n">from_local_coords</span><span class="p">(</span>
                <span class="n">face</span><span class="o">.</span><span class="n">moved</span><span class="p">(</span><span class="n">Location</span><span class="p">((</span><span class="o">-</span><span class="n">face_center_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;projecting face at </span><span class="si">%0.2f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">relative_position_on_wire</span><span class="p">)</span>
            <span class="n">projected_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">projection_face</span><span class="o">.</span><span class="n">project_to_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_normal</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;finished projecting &#39;</span><span class="si">%d</span><span class="s2">&#39; faces&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">projected_faces</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.radius_of_gyration">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.radius_of_gyration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">radius_of_gyration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the radius of gyration of the shape about a given axis.</span>

<span class="sd">        The radius of gyration represents the distance from the axis at which the entire</span>
<span class="sd">        mass of the shape could be concentrated without changing its moment of inertia.</span>
<span class="sd">        It provides insight into how mass is distributed relative to the axis and is</span>
<span class="sd">        useful in structural analysis, rotational dynamics, and mechanical simulations.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Axis): The axis about which the radius of gyration is computed.</span>
<span class="sd">                        The axis should be defined in the same coordinate system</span>
<span class="sd">                        as the shape.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The radius of gyration in the same units as the shape&#39;s dimensions.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; obj = MyShape()</span>
<span class="sd">            &gt;&gt;&gt; axis = Axis((0, 0, 0), (0, 0, 1))</span>
<span class="sd">            &gt;&gt;&gt; obj.radius_of_gyration(axis)</span>
<span class="sd">            5.47</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The radius of gyration is computed based on the shape’s mass properties.</span>
<span class="sd">            - It is useful for evaluating structural stability and rotational behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">GProp_GProps</span><span class="p">()</span>
        <span class="n">BRepGProp</span><span class="o">.</span><span class="n">VolumeProperties_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">properties</span><span class="o">.</span><span class="n">RadiusOfGyration</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.relocate">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.relocate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">relocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the location of self while keeping it geometrically similar</span>

<span class="sd">        Args:</span>
<span class="sd">            loc (Location): new location to set for self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot relocate an empty shape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot relocate a shape at an empty location&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">!=</span> <span class="n">loc</span><span class="p">:</span>
            <span class="n">old_ax</span> <span class="o">=</span> <span class="n">gp_Ax3</span><span class="p">()</span>
            <span class="n">old_ax</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Transformation</span><span class="p">())</span>  <span class="c1"># type: ignore</span>

            <span class="n">new_ax</span> <span class="o">=</span> <span class="n">gp_Ax3</span><span class="p">()</span>
            <span class="n">new_ax</span><span class="o">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Transformation</span><span class="p">())</span>

            <span class="n">trsf</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
            <span class="n">trsf</span><span class="o">.</span><span class="n">SetDisplacement</span><span class="p">(</span><span class="n">new_ax</span><span class="p">,</span> <span class="n">old_ax</span><span class="p">)</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_Transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">trsf</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">downcast</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">Shape</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Location</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.rotate">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.rotate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rotate a copy</span>

<span class="sd">        Rotates a shape around an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Axis): rotation Axis</span>
<span class="sd">            angle (float): angle to rotate, in degrees</span>

<span class="sd">        Returns:</span>
<span class="sd">            a copy of the shape, rotated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformation</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">SetRotation</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">DEG2RAD</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.scale">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scales this shape through a transformation.</span>

<span class="sd">        Args:</span>
<span class="sd">          factor: float:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transformation</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">SetScale</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(),</span> <span class="n">factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.shape_type">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.shape_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shapes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the shape type string for this class&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tcast</span><span class="p">(</span><span class="n">Shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="o">.</span><span class="n">shape_LUT</span><span class="p">[</span><span class="n">shapetype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Shape.shell">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.shell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Shell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Shape.shells">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.shells">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Shell</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;shells - all the shells in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


<div class="viewcode-block" id="Shape.show_topology">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.show_topology">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_topology</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">limit_class</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;Compound&quot;</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;Face&quot;</span><span class="p">,</span> <span class="s2">&quot;Shell&quot;</span><span class="p">,</span> <span class="s2">&quot;Solid&quot;</span><span class="p">,</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;Wire&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span>
        <span class="n">show_center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display internal topology</span>

<span class="sd">        Display the internal structure of a Compound &#39;assembly&#39; or Shape. Example:</span>

<span class="sd">        .. code::</span>

<span class="sd">            &gt;&gt;&gt; c1.show_topology()</span>

<span class="sd">            c1 is the root         Compound at 0x7f4a4cafafa0, Location(...))</span>
<span class="sd">            ├──                    Solid    at 0x7f4a4cafafd0, Location(...))</span>
<span class="sd">            ├── c2 is 1st compound Compound at 0x7f4a4cafaee0, Location(...))</span>
<span class="sd">            │   ├──                Solid    at 0x7f4a4cafad00, Location(...))</span>
<span class="sd">            │   └──                Solid    at 0x7f4a11a52790, Location(...))</span>
<span class="sd">            └── c3 is 2nd          Compound at 0x7f4a4cafad60, Location(...))</span>
<span class="sd">                ├──                Solid    at 0x7f4a11a52700, Location(...))</span>
<span class="sd">                └──                Solid    at 0x7f4a11a58550, Location(...))</span>

<span class="sd">        Args:</span>
<span class="sd">            limit_class: type of displayed leaf node. Defaults to &#39;Vertex&#39;.</span>
<span class="sd">            show_center (bool, optional): If None, shows the Location of Compound &#39;assemblies&#39;</span>
<span class="sd">                and the bounding box center of Shapes. True or False forces the display.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: tree representation of internal structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="p">):</span>
            <span class="n">show_center</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">show_center</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">show_center</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_show_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_center</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_build_tree</span><span class="p">(</span>
                <span class="n">tcast</span><span class="p">(</span><span class="n">TopoDS_Shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">),</span>
                <span class="n">tree</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">limit</span><span class="o">=</span><span class="n">Shape</span><span class="o">.</span><span class="n">inverse_shape_LUT</span><span class="p">[</span><span class="n">limit_class</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">show_center</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">show_center</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">show_center</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">_show_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">show_center</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Shape.solid">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.solid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Solid</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Solid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Shape.solids">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.solids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Solid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;solids - all the solids in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_by_perimeter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Keep</span><span class="o">.</span><span class="n">INSIDE</span><span class="p">,</span> <span class="n">Keep</span><span class="o">.</span><span class="n">OUTSIDE</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split_by_perimeter and keep inside or outside&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_by_perimeter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split_by_perimeter and keep inside and outside&quot;&quot;&quot;</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_by_perimeter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Shell</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split_by_perimeter and keep inside (default)&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Shape.split_by_perimeter">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.split_by_perimeter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_by_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Keep</span> <span class="o">=</span> <span class="n">Keep</span><span class="o">.</span><span class="n">INSIDE</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;split_by_perimeter</span>

<span class="sd">        Divide the faces of this object into those within the perimeter</span>
<span class="sd">        and those outside the perimeter.</span>

<span class="sd">        Note: this method may fail if the perimeter intersects shape edges.</span>

<span class="sd">        Args:</span>
<span class="sd">            perimeter (Union[Edge,Wire]): closed perimeter</span>
<span class="sd">            keep (Keep, optional): which object(s) to return. Defaults to Keep.INSIDE.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: perimeter must be closed</span>
<span class="sd">            ValueError: keep must be one of Keep.INSIDE|OUTSIDE|BOTH</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[Face | Shell | ShapeList[Face] | None,</span>
<span class="sd">            Tuple[Face | Shell | ShapeList[Face] | None]: The result of the split operation.</span>

<span class="sd">            - **Keep.INSIDE**: Returns the inside part as a `Shell` or `Face`, or `None`</span>
<span class="sd">              if no inside part is found.</span>
<span class="sd">            - **Keep.OUTSIDE**: Returns the outside part as a `Shell` or `Face`, or `None`</span>
<span class="sd">              if no outside part is found.</span>
<span class="sd">            - **Keep.BOTH**: Returns a tuple `(inside, outside)` where each element is</span>
<span class="sd">              either a `Shell`, `Face`, or `None` if no corresponding part is found.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">los</span><span class="p">:</span> <span class="n">TopTools_ListOfShape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Return objects from TopTools_ListOfShape as list&quot;&quot;&quot;</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">los</span><span class="o">.</span><span class="n">Size</span><span class="p">()):</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">First</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="o">.</span><span class="n">IsNull</span><span class="p">():</span>
                    <span class="n">shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">first</span><span class="p">))</span>
                <span class="n">los</span><span class="o">.</span><span class="n">RemoveFirst</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">shapes</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process_sides</span><span class="p">(</span><span class="n">sides</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Process sides to determine if it should be None, a single element,</span>
<span class="sd">            a Shell, or a ShapeList.&quot;&quot;&quot;</span>
            <span class="c1"># if not sides:</span>
            <span class="c1">#     return None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Attempt to create a shell</span>
            <span class="n">potential_shell</span> <span class="o">=</span> <span class="n">_sew_topods_faces</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">wrapped</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sides</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">potential_shell</span><span class="p">,</span> <span class="n">TopoDS_Shell</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">potential_shell</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">sides</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keep</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="n">Keep</span><span class="o">.</span><span class="n">INSIDE</span><span class="p">,</span> <span class="n">Keep</span><span class="o">.</span><span class="n">OUTSIDE</span><span class="p">,</span> <span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;keep must be one of Keep.INSIDE, Keep.OUTSIDE, or Keep.BOTH&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot split an empty shape&quot;</span><span class="p">)</span>

        <span class="c1"># Process the perimeter</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">perimeter</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;perimeter must be a closed Wire or Edge&quot;</span><span class="p">)</span>
        <span class="n">perimeter_edges</span> <span class="o">=</span> <span class="n">TopTools_SequenceOfShape</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">perimeter_edge</span> <span class="ow">in</span> <span class="n">perimeter</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">perimeter_edges</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">perimeter_edge</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="c1"># Split the shells by the perimeter edges</span>
        <span class="n">lefts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shell</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shell</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target_shell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">():</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="n">BRepFeat_SplitShape</span><span class="p">(</span><span class="n">target_shell</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="n">constructor</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">perimeter_edges</span><span class="p">)</span>
            <span class="n">constructor</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
            <span class="n">lefts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="n">constructor</span><span class="o">.</span><span class="n">Left</span><span class="p">()))</span>
            <span class="n">rights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="n">constructor</span><span class="o">.</span><span class="n">Right</span><span class="p">()))</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">process_sides</span><span class="p">(</span><span class="n">lefts</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">process_sides</span><span class="p">(</span><span class="n">rights</span><span class="p">)</span>

        <span class="c1"># Is left or right the inside?</span>
        <span class="n">perimeter_length</span> <span class="o">=</span> <span class="n">perimeter</span><span class="o">.</span><span class="n">length</span>
        <span class="n">left_perimeter_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="k">if</span> <span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">right_perimeter_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">right</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="k">if</span> <span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">left_inside</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">perimeter_length</span> <span class="o">-</span> <span class="n">left_perimeter_length</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span>
            <span class="n">perimeter_length</span> <span class="o">-</span> <span class="n">right_perimeter_length</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">BOTH</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">if</span> <span class="n">left_inside</span> <span class="k">else</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="n">Keep</span><span class="o">.</span><span class="n">INSIDE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span> <span class="k">if</span> <span class="n">left_inside</span> <span class="k">else</span> <span class="n">right</span>
        <span class="c1"># keep == Keep.OUTSIDE:</span>
        <span class="k">return</span> <span class="n">right</span> <span class="k">if</span> <span class="n">left_inside</span> <span class="k">else</span> <span class="n">left</span></div>


<div class="viewcode-block" id="Shape.tessellate">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.tessellate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tessellate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">angular_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;General triangulated approximation&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot tessellate an empty shape&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">angular_tolerance</span><span class="p">)</span>

        <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">triangles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">face</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">TopLoc_Location</span><span class="p">()</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Triangulation_s</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="n">trsf</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">Transformation</span><span class="p">()</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Orientation</span><span class="p">()</span> <span class="o">==</span> <span class="n">TopAbs_Orientation</span><span class="o">.</span><span class="n">TopAbs_REVERSED</span>

            <span class="c1"># add vertices</span>
            <span class="n">vertices</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">Z</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="n">poly</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">Transformed</span><span class="p">(</span><span class="n">trsf</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">poly</span><span class="o">.</span><span class="n">NbNodes</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="c1"># add triangles</span>
            <span class="n">triangles</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">reverse</span>
                    <span class="k">else</span> <span class="p">(</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">Triangles</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="n">offset</span> <span class="o">+=</span> <span class="n">poly</span><span class="o">.</span><span class="n">NbNodes</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span></div>


<div class="viewcode-block" id="Shape.to_splines">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.to_splines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_splines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">nurbs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;to_splines</span>

<span class="sd">        Approximate shape with b-splines of the specified degree.</span>

<span class="sd">        Args:</span>
<span class="sd">            degree (int, optional): Maximum degree. Defaults to 3.</span>
<span class="sd">            tolerance (float, optional): Approximation tolerance. Defaults to 1e-3.</span>
<span class="sd">            nurbs (bool, optional): Use rational splines. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: Approximated shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot approximate an empty shape&quot;</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">ShapeCustom_RestrictionParameters</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">ShapeCustom</span><span class="o">.</span><span class="n">BSplineRestriction_s</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="p">,</span>  <span class="c1"># 3D tolerance</span>
            <span class="n">tolerance</span><span class="p">,</span>  <span class="c1"># 2D tolerance</span>
            <span class="n">degree</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>  <span class="c1"># dummy value, degree is leading</span>
            <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_C0</span><span class="p">,</span>
            <span class="n">ga</span><span class="o">.</span><span class="n">GeomAbs_C0</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>  <span class="c1"># set degree to be leading</span>
            <span class="ow">not</span> <span class="n">nurbs</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.transform_geometry">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.transform_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_matrix</span><span class="p">:</span> <span class="n">Matrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply affine transform</span>

<span class="sd">        WARNING: transform_geometry will sometimes convert lines and circles to</span>
<span class="sd">        splines, but it also has the ability to handle skew and stretching</span>
<span class="sd">        transformations.</span>

<span class="sd">        If your transformation is only translation and rotation, it is safer to</span>
<span class="sd">        use :py:meth:`transform_shape`, which doesn&#39;t change the underlying type</span>
<span class="sd">        of the geometry, but cannot handle skew transformations.</span>

<span class="sd">        Args:</span>
<span class="sd">            t_matrix (Matrix): affine transformation matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: a copy of the object, but with geometry transformed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">transformed</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span>
            <span class="n">BRepBuilderAPI_GTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">t_matrix</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">new_shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">transformed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_shape</span></div>


<div class="viewcode-block" id="Shape.transform_shape">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.transform_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_matrix</span><span class="p">:</span> <span class="n">Matrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply affine transform without changing type</span>

<span class="sd">        Transforms a copy of this Shape by the provided 3D affine transformation matrix.</span>
<span class="sd">        Note that not all transformation are supported - primarily designed for translation</span>
<span class="sd">        and rotation.  See :transform_geometry: for more comprehensive transformations.</span>

<span class="sd">        Args:</span>
<span class="sd">            t_matrix (Matrix): affine transformation matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: copy of transformed shape with all objects keeping their type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">transformed</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span>
            <span class="n">BRepBuilderAPI_Transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">t_matrix</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">Trsf</span><span class="p">())</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">new_shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">transformed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_shape</span></div>


<div class="viewcode-block" id="Shape.transformed">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.transformed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transformed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">rotate</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">offset</span><span class="p">:</span> <span class="n">VectorLike</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform Shape</span>

<span class="sd">        Rotate and translate the Shape by the three angles (in degrees) and offset.</span>

<span class="sd">        Args:</span>
<span class="sd">            rotate (VectorLike, optional): 3-tuple of angles to rotate, in degrees.</span>
<span class="sd">                Defaults to (0, 0, 0).</span>
<span class="sd">            offset (VectorLike, optional): 3-tuple to offset. Defaults to (0, 0, 0).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: transformed object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert to a Vector of radians</span>
        <span class="n">rotate_vector</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">DEG2RAD</span><span class="p">)</span>
        <span class="c1"># Compute rotation matrix.</span>
        <span class="n">t_rx</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">t_rx</span><span class="o">.</span><span class="n">SetRotation</span><span class="p">(</span><span class="n">gp_Ax1</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">rotate_vector</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">t_ry</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">t_ry</span><span class="o">.</span><span class="n">SetRotation</span><span class="p">(</span><span class="n">gp_Ax1</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">rotate_vector</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">t_rz</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">t_rz</span><span class="o">.</span><span class="n">SetRotation</span><span class="p">(</span><span class="n">gp_Ax1</span><span class="p">(</span><span class="n">gp_Pnt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">gp_Dir</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">rotate_vector</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">t_o</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">t_o</span><span class="o">.</span><span class="n">SetTranslation</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">t_o</span> <span class="o">*</span> <span class="n">t_rx</span> <span class="o">*</span> <span class="n">t_ry</span> <span class="o">*</span> <span class="n">t_rz</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.translate">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.translate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates this shape through a transformation.</span>

<span class="sd">        Args:</span>
<span class="sd">          vector: VectorLike:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transformation</span> <span class="o">=</span> <span class="n">gp_Trsf</span><span class="p">()</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">SetTranslation</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transform</span><span class="p">(</span><span class="n">transformation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Shape.wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Wire&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Shape.wires">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Shape.wires">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wires</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wires - all the wires in this Shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">:</span> <span class="n">gp_Trsf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private Apply Transform</span>

<span class="sd">        Apply the provided transformation matrix to a copy of Shape</span>

<span class="sd">        Args:</span>
<span class="sd">            transformation (gp_Trsf): transformation matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            Shape: copy of transformed Shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">shape_copy</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">transformed_shape</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_Transform</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span>
            <span class="n">transformation</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>
        <span class="n">shape_copy</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">tcast</span><span class="p">(</span><span class="n">TOPODS</span><span class="p">,</span> <span class="n">downcast</span><span class="p">(</span><span class="n">transformed_shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">shape_copy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_bool_op</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">],</span>
        <span class="n">tools</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">],</span>
        <span class="n">operation</span><span class="p">:</span> <span class="n">BRepAlgoAPI_BooleanOperation</span> <span class="o">|</span> <span class="n">BRepAlgoAPI_Splitter</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic boolean operation</span>

<span class="sd">        Args:</span>
<span class="sd">          args: Iterable[Shape]:</span>
<span class="sd">          tools: Iterable[Shape]:</span>
<span class="sd">          operation: Union[BRepAlgoAPI_BooleanOperation:</span>
<span class="sd">          BRepAlgoAPI_Splitter]:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">tools</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tools</span><span class="p">)</span>
        <span class="c1"># Find the highest order class from all the inputs Solid &gt; Vertex</span>
        <span class="n">order_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">order</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span> <span class="o">+</span> <span class="n">tools</span><span class="p">}</span>
        <span class="n">highest_order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">order_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># The base of the operation</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">args</span>

        <span class="n">arg</span> <span class="o">=</span> <span class="n">TopTools_ListOfShape</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arg</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="n">tool</span> <span class="o">=</span> <span class="n">TopTools_ListOfShape</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">tools</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tool</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

        <span class="n">operation</span><span class="o">.</span><span class="n">SetArguments</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">operation</span><span class="o">.</span><span class="n">SetTools</span><span class="p">(</span><span class="n">tool</span><span class="p">)</span>

        <span class="n">operation</span><span class="o">.</span><span class="n">SetRunParallel</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">operation</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="n">topo_result</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>

        <span class="c1"># Clean</span>
        <span class="k">if</span> <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span><span class="p">:</span>
            <span class="n">upgrader</span> <span class="o">=</span> <span class="n">ShapeUpgrade_UnifySameDomain</span><span class="p">(</span><span class="n">topo_result</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">upgrader</span><span class="o">.</span><span class="n">AllowInternalEdges</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">upgrader</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
                <span class="n">topo_result</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">upgrader</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Boolean operation unable to clean&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Remove unnecessary TopoDS_Compound around single shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topo_result</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
            <span class="n">topo_result</span> <span class="o">=</span> <span class="n">unwrap_topods_compound</span><span class="p">(</span><span class="n">topo_result</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topo_result</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">)</span> <span class="ow">and</span> <span class="n">highest_order</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
                <span class="n">highest_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">topo_result</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">base</span><span class="o">.</span><span class="n">copy_attributes_to</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;wrapped&quot;</span><span class="p">,</span> <span class="s2">&quot;_NodeMixin__children&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">highest_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">topo_result</span><span class="p">)</span>
        <span class="n">base</span><span class="o">.</span><span class="n">copy_attributes_to</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;wrapped&quot;</span><span class="p">,</span> <span class="s2">&quot;_NodeMixin__children&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_ocp_section</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Face</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Vertex</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_ocp_section</span>

<span class="sd">        Create a BRepAlgoAPI_Section object</span>

<span class="sd">        The algorithm is to build a Section operation between arguments and tools.</span>
<span class="sd">        The result of Section operation consists of vertices and edges. The result</span>
<span class="sd">        of Section operation contains:</span>
<span class="sd">        - new vertices that are subjects of V/V, E/E, E/F, F/F interferences</span>
<span class="sd">        - vertices that are subjects of V/E, V/F interferences</span>
<span class="sd">        - new edges that are subjects of F/F interferences</span>
<span class="sd">        - edges that are Common Blocks</span>


<span class="sd">        Args:</span>
<span class="sd">            other (Union[Vertex, Edge, Wire, Face]): shape to section with</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[list[Vertex], list[Edge]]: section results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Section</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="n">BRepAlgoAPI_Section</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>

        <span class="c1"># Perform the intersection calculation</span>
        <span class="n">section</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="c1"># Get the resulting shapes from the intersection</span>
        <span class="n">intersection_shape</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">Shape</span><span class="p">()</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Iterate through the intersection shape to find intersection points/edges</span>
        <span class="n">explorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">intersection_shape</span><span class="p">,</span> <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_VERTEX</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">explorer</span><span class="o">.</span><span class="n">Current</span><span class="p">())))</span>
            <span class="n">explorer</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">explorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">intersection_shape</span><span class="p">,</span> <span class="n">TopAbs_ShapeEnum</span><span class="o">.</span><span class="n">TopAbs_EDGE</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">downcast</span><span class="p">(</span><span class="n">explorer</span><span class="o">.</span><span class="n">Current</span><span class="p">())))</span>
            <span class="n">explorer</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Jupyter 3D representation support&quot;&quot;&quot;</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">build123d.jupyter_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">shape_to_html</span>

        <span class="k">return</span> <span class="n">shape_to_html</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">Comparable</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class that requires comparison methods&quot;&quot;&quot;</span>

    <span class="c1"># ---- Instance Methods ----</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="o">...</span>


<span class="c1"># This TypeVar allows IDEs to see the type of objects within the ShapeList</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="n">Shape</span><span class="p">,</span> <span class="n">Vector</span><span class="p">])</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Comparable</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ShapePredicate</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Predicate for shape filters&quot;&quot;&quot;</span>

    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GroupBy</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Result of a Shape.groupby operation. Groups can be accessed by index or key&quot;&quot;&quot;</span>

    <span class="c1"># ---- Constructor ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">K</span><span class="p">],</span>
        <span class="n">shapelist</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># can&#39;t be a dict because K may not be hashable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_to_group_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_f</span> <span class="o">=</span> <span class="n">key_f</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">shapegroup</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">shapelist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_f</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">key_f</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ShapeList</span><span class="p">(</span><span class="n">shapegroup</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_to_group_index</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ShapeList</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pretty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select group by key&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_to_group_index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">group_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select group by shape&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_f</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_pretty_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">:</span> <span class="n">RepresentationPrinter</span><span class="p">,</span> <span class="n">cycle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a formatted representation of the object for pretty-printing in</span>
<span class="sd">        interactive environments.</span>

<span class="sd">        Args:</span>
<span class="sd">            printer (PrettyPrinter): The pretty printer instance handling the output.</span>
<span class="sd">            cycle (bool): Indicates if a reference cycle is detected to</span>
<span class="sd">                prevent infinite recursion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">printer</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;(...)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">printer</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">printer</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                        <span class="n">printer</span><span class="o">.</span><span class="n">breakable</span><span class="p">()</span>
                    <span class="n">printer</span><span class="o">.</span><span class="n">pretty</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>


<div class="viewcode-block" id="ShapeList">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShapeList</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of list with custom filter and sort methods appropriate to CAD&quot;&quot;&quot;</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="c1"># pylint: disable=too-many-public-methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First element in the ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Last element in the ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine two ShapeLists together operator +&quot;&quot;&quot;</span>
        <span class="c1"># return ShapeList(itertools.chain(self, other)) # breaks MacOS-13</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

<div class="viewcode-block" id="ShapeList.__and__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__and__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect two ShapeLists operator &amp;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;ShapeLists equality operator ==&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="k">else</span> <span class="bp">NotImplemented</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">SupportsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span> <span class="o">...</span>

<div class="viewcode-block" id="ShapeList.__getitem__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">SupportsIndex</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="o">|</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return slices of ShapeList as ShapeList&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.__gt__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__gt__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort operator &gt;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">sort_by</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.__lshift__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__lshift__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group and select smallest group operator &lt;&lt;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">group_by</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.__lt__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__lt__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse sort operator &lt;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="c1"># Normally implementing __eq__ is enough, but ShapeList subclasses list,</span>
    <span class="c1"># which already implements __ne__, so we need to override it, too</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;ShapeLists inequality operator !=&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="k">else</span> <span class="bp">NotImplemented</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ShapeList.__or__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__or__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">GeomType</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter by axis or geomtype operator |&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">filter_by</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.__rshift__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__rshift__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group and select largest group operator &gt;&gt;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">group_by</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.__sub__">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.__sub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Differences between two ShapeLists operator -&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="ShapeList.center">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.center">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The average of the center of objects within the ShapeList&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">total_center</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">center</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">),</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">total_center</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.compound">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.compound">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compound</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Compound&quot;&quot;&quot;</span>
        <span class="n">compounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compounds</span><span class="p">()</span>
        <span class="n">compound_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compound_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">compound_count</span><span class="si">}</span><span class="s2"> compounds, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">compounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.compounds">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.compounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Compound</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compounds - all the compounds in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">compounds</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.edge">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Edge&quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">edge_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">edge_count</span><span class="si">}</span><span class="s2"> edges, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.edges">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;edges - all the edges in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.face">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.face">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">face</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Face&quot;&quot;&quot;</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
        <span class="n">face_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">face_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">face_count</span><span class="si">}</span><span class="s2"> faces, returning first&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.faces">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;faces - all the faces in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">faces</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.filter_by">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.filter_by">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_by</span><span class="p">:</span> <span class="n">ShapePredicate</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Plane</span> <span class="o">|</span> <span class="n">GeomType</span> <span class="o">|</span> <span class="nb">property</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;filter by Axis, Plane, or GeomType</span>

<span class="sd">        Either:</span>
<span class="sd">        - filter objects of type planar Face or linear Edge by their normal or tangent</span>
<span class="sd">        (respectively) and sort the results by the given axis, or</span>
<span class="sd">        - filter the objects by the provided type. Note that not all types apply to all</span>
<span class="sd">        objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            filter_by (Union[Axis,Plane,GeomType]): axis, plane, or geom type to filter</span>
<span class="sd">                and possibly sort by. Filtering by a plane returns faces/edges parallel</span>
<span class="sd">                to that plane.</span>
<span class="sd">            reverse (bool, optional): invert the geom type filter. Defaults to False.</span>
<span class="sd">            tolerance (float, optional): maximum deviation from axis. Defaults to 1e-5.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Invalid filter_by type</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList: filtered list of objects</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># could be moved out maybe?</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">axis_parallel_predicate</span><span class="p">(</span><span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">pred</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">is_planar_face</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Face</span>
                    <span class="p">)</span>
                    <span class="n">gp_pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
                    <span class="n">surface_normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
                    <span class="n">u_val</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">BRepTools</span><span class="o">.</span><span class="n">UVBounds_s</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
                    <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span>
                        <span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">surface_normal</span>
                    <span class="p">)</span>
                    <span class="n">normalized_surface_normal</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span>
                        <span class="n">surface_normal</span><span class="o">.</span><span class="n">X</span><span class="p">(),</span> <span class="n">surface_normal</span><span class="o">.</span><span class="n">Y</span><span class="p">(),</span> <span class="n">surface_normal</span><span class="o">.</span><span class="n">Z</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
                    <span class="n">shape_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">center</span><span class="p">(),</span> <span class="n">normalized_surface_normal</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Edge</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">shape</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">GeomType</span><span class="o">.</span><span class="n">LINE</span>
                <span class="p">):</span>
                    <span class="n">curve</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">geom_adaptor</span><span class="p">()</span>
                    <span class="n">umin</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">FirstParameter</span><span class="p">()</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
                    <span class="n">curve</span><span class="o">.</span><span class="n">D1</span><span class="p">(</span><span class="n">umin</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                    <span class="n">start_pos</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                    <span class="n">start_dir</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">gp_Dir</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                    <span class="n">shape_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">start_pos</span><span class="p">,</span> <span class="n">start_dir</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_parallel</span><span class="p">(</span><span class="n">shape_axis</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">pred</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">plane_parallel_predicate</span><span class="p">(</span><span class="n">plane</span><span class="p">:</span> <span class="n">Plane</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">plane_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span><span class="p">)</span>
            <span class="n">plane_xyz</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">z_dir</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">XYZ</span><span class="p">()</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">pred</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">is_planar_face</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Face</span>
                    <span class="p">)</span>
                    <span class="n">gp_pnt</span><span class="p">:</span> <span class="n">gp_Pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
                    <span class="n">surface_normal</span><span class="p">:</span> <span class="n">gp_Vec</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
                    <span class="n">u_val</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">BRepTools</span><span class="o">.</span><span class="n">UVBounds_s</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
                    <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span>
                        <span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">surface_normal</span>
                    <span class="p">)</span>
                    <span class="n">normalized_surface_normal</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">surface_normal</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
                    <span class="n">shape_axis</span> <span class="o">=</span> <span class="n">Axis</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">center</span><span class="p">(),</span> <span class="n">normalized_surface_normal</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">plane_axis</span><span class="o">.</span><span class="n">is_parallel</span><span class="p">(</span><span class="n">shape_axis</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Wire</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">TopoDS_Edge</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">TShape</span><span class="p">()</span><span class="o">.</span><span class="n">Curves</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">curve</span><span class="o">.</span><span class="n">IsCurve3D</span><span class="p">():</span>
                            <span class="k">return</span> <span class="n">ShapeAnalysis_Curve</span><span class="o">.</span><span class="n">IsPlanar_s</span><span class="p">(</span>
                                <span class="n">curve</span><span class="o">.</span><span class="n">Curve3D</span><span class="p">(),</span> <span class="n">plane_xyz</span><span class="p">,</span> <span class="n">tolerance</span>
                            <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="n">pred</span>

        <span class="c1"># convert input to callable predicate</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">filter_by</span><span class="p">):</span>
            <span class="n">predicate</span> <span class="o">=</span> <span class="n">filter_by</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">predicate</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">filter_by</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
            <span class="n">predicate</span> <span class="o">=</span> <span class="n">axis_parallel_predicate</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
            <span class="n">predicate</span> <span class="o">=</span> <span class="n">plane_parallel_predicate</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_by</span><span class="p">,</span> <span class="n">GeomType</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">predicate</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="n">filter_by</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported filter_by predicate: </span><span class="si">{</span><span class="n">filter_by</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># final predicate is negated if `reverse=True`</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">actual_predicate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">actual_predicate</span> <span class="o">=</span> <span class="n">predicate</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">actual_predicate</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="ShapeList.filter_by_position">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.filter_by_position">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_by_position</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span><span class="p">,</span>
        <span class="n">minimum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">inclusive</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;filter by position</span>

<span class="sd">        Filter and sort objects by the position of their centers along given axis.</span>
<span class="sd">        min and max values can be inclusive or exclusive depending on the inclusive tuple.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (Axis): axis to sort by</span>
<span class="sd">            minimum (float): minimum value</span>
<span class="sd">            maximum (float): maximum value</span>
<span class="sd">            inclusive (tuple[bool, bool], optional): include min,max values.</span>
<span class="sd">                Defaults to (True, True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList: filtered object list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inclusive</span> <span class="o">==</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">minimum</span>
                <span class="o">&lt;=</span> <span class="n">axis</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span>
                <span class="o">&lt;=</span> <span class="n">maximum</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">inclusive</span> <span class="o">==</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">minimum</span>
                <span class="o">&lt;=</span> <span class="n">axis</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span>
                <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">inclusive</span> <span class="o">==</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">minimum</span>
                <span class="o">&lt;</span> <span class="n">axis</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span>
                <span class="o">&lt;=</span> <span class="n">maximum</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">inclusive</span> <span class="o">==</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">minimum</span>
                <span class="o">&lt;</span> <span class="n">axis</span><span class="o">.</span><span class="n">to_plane</span><span class="p">()</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span>
                <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.group_by">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.group_by">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_by</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Shape</span><span class="p">],</span> <span class="n">K</span><span class="p">]</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">|</span> <span class="nb">property</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tol_digits</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GroupBy</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;group by</span>

<span class="sd">        Group objects by provided criteria and then sort the groups according to the criteria.</span>
<span class="sd">        Note that not all group_by criteria apply to all objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            group_by (SortBy, optional): group and sort criteria. Defaults to Axis.Z.</span>
<span class="sd">            reverse (bool, optional): flip order of sort. Defaults to False.</span>
<span class="sd">            tol_digits (int, optional): Tolerance for building the group keys by</span>
<span class="sd">                round(key, tol_digits)</span>

<span class="sd">        Returns:</span>
<span class="sd">            GroupBy[K, ShapeList]: sorted list of ShapeLists</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">group_by</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot group by an empty axis&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">group_by</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">axis_as_location</span> <span class="o">=</span> <span class="n">group_by</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">round</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">axis_as_location</span> <span class="o">*</span> <span class="n">Location</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">center</span><span class="p">()))</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
                    <span class="n">tol_digits</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="s2">&quot;wrapped&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">group_by</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot group by an empty object&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="p">(</span><span class="n">TopoDS_Edge</span><span class="p">,</span> <span class="n">TopoDS_Wire</span><span class="p">)):</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="n">pnt1</span><span class="p">,</span> <span class="n">_pnt2</span> <span class="o">=</span> <span class="n">group_by</span><span class="o">.</span><span class="n">closest_points</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">group_by</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="n">pnt1</span><span class="p">),</span> <span class="n">tol_digits</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="n">SortBy</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">group_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">LENGTH</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">tol_digits</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">group_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">RADIUS</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">tol_digits</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">group_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">DISTANCE</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">tol_digits</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">group_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">AREA</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">tol_digits</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">group_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">VOLUME</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">key_f</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">tol_digits</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">group_by</span><span class="p">):</span>
            <span class="n">key_f</span> <span class="o">=</span> <span class="n">group_by</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_by</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">key_f</span> <span class="o">=</span> <span class="n">group_by</span><span class="o">.</span><span class="fm">__get__</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported group_by function: </span><span class="si">{</span><span class="n">group_by</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">GroupBy</span><span class="p">(</span><span class="n">key_f</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.shell">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.shell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shell</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Shell&quot;&quot;&quot;</span>
        <span class="n">shells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">()</span>
        <span class="n">shell_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shell_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">shell_count</span><span class="si">}</span><span class="s2"> shells, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.shells">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.shells">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Shell</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;shells - all the shells in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">shells</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.solid">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.solid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Solid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Solid&quot;&quot;&quot;</span>
        <span class="n">solids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span>
        <span class="n">solid_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">solids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solid_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">solid_count</span><span class="si">}</span><span class="s2"> solids, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.solids">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.solids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Solid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;solids - all the solids in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">solids</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.sort_by">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.sort_by">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sort_by</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">K</span><span class="p">]</span> <span class="o">|</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">SortBy</span> <span class="o">|</span> <span class="nb">property</span> <span class="o">=</span> <span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sort by</span>

<span class="sd">        Sort objects by provided criteria. Note that not all sort_by criteria apply to all</span>
<span class="sd">        objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            sort_by (Axis | Callable[[T], K] | Edge | Wire | SortBy, optional): sort criteria.</span>
<span class="sd">               Defaults to Axis.Z.</span>
<span class="sd">            reverse (bool, optional): flip order of sort. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Cannot sort by an empty axis</span>
<span class="sd">            ValueError: Cannot sort by an empty object</span>
<span class="sd">            ValueError: Invalid sort_by criteria provided</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList: sorted list of objects</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">sort_by</span><span class="p">):</span>
            <span class="c1"># If a callable is provided, use it directly as the key</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_by</span><span class="o">.</span><span class="fm">__get__</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot sort by an empty axis&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">axis_as_location</span> <span class="o">=</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">tcast</span><span class="p">(</span>
                    <span class="n">Location</span><span class="p">,</span> <span class="p">(</span><span class="n">axis_as_location</span> <span class="o">*</span> <span class="n">Location</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">center</span><span class="p">()))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
                <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="s2">&quot;wrapped&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot sort by an empty object&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="p">(</span><span class="n">TopoDS_Edge</span><span class="p">,</span> <span class="n">TopoDS_Wire</span><span class="p">)):</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">u_of_closest_center</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;u-value of closest point between object center and sort_by&quot;&quot;&quot;</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">SortBy</span><span class="p">)</span>
                    <span class="n">pnt1</span><span class="p">,</span> <span class="n">_pnt2</span> <span class="o">=</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">closest_points</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
                    <span class="k">return</span> <span class="n">sort_by</span><span class="o">.</span><span class="n">param_at_point</span><span class="p">(</span><span class="n">pnt1</span><span class="p">)</span>

                <span class="c1"># pylint: disable=unnecessary-lambda</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">u_of_closest_center</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">SortBy</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">LENGTH</span><span class="p">:</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">RADIUS</span><span class="p">:</span>
                <span class="n">with_radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;radius&quot;</span><span class="p">)]</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">with_radius</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">DISTANCE</span><span class="p">:</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">AREA</span><span class="p">:</span>
                <span class="n">with_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)]</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">with_area</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">area</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="n">SortBy</span><span class="o">.</span><span class="n">VOLUME</span><span class="p">:</span>
                <span class="n">with_volume</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;volume&quot;</span><span class="p">)]</span>
                <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">with_volume</span><span class="p">,</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid sort_by criteria provided&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShapeList.sort_by_distance">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.sort_by_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort_by_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">VectorLike</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort by distance</span>

<span class="sd">        Sort by minimal distance between objects and other</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Union[Shape,VectorLike]): reference object</span>
<span class="sd">            reverse (bool, optional): flip order of sort. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList: Sorted shapes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">obj</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">])</span></div>


<div class="viewcode-block" id="ShapeList.vertex">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.vertex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Vertex&quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="n">vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertex_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">vertex_count</span><span class="si">}</span><span class="s2"> vertices, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.vertices">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;vertices - all the vertices in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">vertices</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="ShapeList.wire">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.wire">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Wire&quot;&quot;&quot;</span>
        <span class="n">wires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wires</span><span class="p">()</span>
        <span class="n">wire_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wires</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wire_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">wire_count</span><span class="si">}</span><span class="s2"> wires, returning first&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ShapeList.wires">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.ShapeList.wires">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wires</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wires - all the wires in this ShapeList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">wires</span><span class="p">()])</span>  <span class="c1"># type: ignore</span></div>
</div>



<div class="viewcode-block" id="Joint">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Joint">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Joint</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Joint</span>

<span class="sd">    Abstract Base Joint class - used to join two components together</span>

<span class="sd">    Args:</span>
<span class="sd">        parent (Union[Solid, Compound]): object that joint to bound to</span>

<span class="sd">    Attributes:</span>
<span class="sd">        label (str): user assigned label</span>
<span class="sd">        parent (Shape): object joint is bound to</span>
<span class="sd">        connected_to (Joint): joint that is connect to this joint</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ---- Constructor ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">BuildPart</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_to</span><span class="p">:</span> <span class="n">Joint</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ---- Properties ----</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Location of joint&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compound</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A CAD object positioned in global space to illustrate the joint&quot;&quot;&quot;</span>

    <span class="c1"># ---- Instance Methods ----</span>

<div class="viewcode-block" id="Joint.connect_to">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Joint.connect_to">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All derived classes must provide a connect_to method&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Joint.relative_to">
<a class="viewcode-back" href="../../direct_api_reference.html#topology.Joint.relative_to">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">relative_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Location</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return relative location to another joint&quot;&quot;&quot;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_connect_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Joint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Connect Joint self by repositioning other&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Joint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;other must of type Joint not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parent location is not set&quot;</span><span class="p">)</span>
        <span class="n">relative_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">locate</span><span class="p">(</span><span class="n">tcast</span><span class="p">(</span><span class="n">Location</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">location</span> <span class="o">*</span> <span class="n">relative_location</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_to</span> <span class="o">=</span> <span class="n">other</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">SkipClean</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Skip clean context for use in operator driven code where clean=False wouldn&#39;t work&quot;&quot;&quot;</span>

    <span class="n">clean</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># ---- Instance Methods ----</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">SkipClean</span><span class="o">.</span><span class="n">clean</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_sew_topods_faces</span><span class="p">(</span><span class="n">faces</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TopoDS_Face</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sew faces into a shell if possible&quot;&quot;&quot;</span>
    <span class="n">shell_builder</span> <span class="o">=</span> <span class="n">BRepBuilderAPI_Sewing</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
        <span class="n">shell_builder</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
    <span class="n">shell_builder</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">downcast</span><span class="p">(</span><span class="n">shell_builder</span><span class="o">.</span><span class="n">SewedShape</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_topods_entities</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">,</span> <span class="n">topo_type</span><span class="p">:</span> <span class="n">Shapes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TopoDS_Shape</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the TopoDS_Shapes of topo_type from this TopoDS_Shape&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># using dict to prevent duplicates</span>

    <span class="n">explorer</span> <span class="o">=</span> <span class="n">TopExp_Explorer</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Shape</span><span class="o">.</span><span class="n">inverse_shape_LUT</span><span class="p">[</span><span class="n">topo_type</span><span class="p">])</span>

    <span class="k">while</span> <span class="n">explorer</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">Current</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span> <span class="o">=</span> <span class="n">item</span>  <span class="c1"># needed to avoid pseudo-duplicate entities</span>
        <span class="n">explorer</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_topods_face_normal_at</span><span class="p">(</span><span class="n">face</span><span class="p">:</span> <span class="n">TopoDS_Face</span><span class="p">,</span> <span class="n">surface_point</span><span class="p">:</span> <span class="n">gp_Pnt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the normal at a point on surface&quot;&quot;&quot;</span>
    <span class="n">surface</span> <span class="o">=</span> <span class="n">BRep_Tool</span><span class="o">.</span><span class="n">Surface_s</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>

    <span class="c1"># project point on surface</span>
    <span class="n">projector</span> <span class="o">=</span> <span class="n">GeomAPI_ProjectPointOnSurf</span><span class="p">(</span><span class="n">surface_point</span><span class="p">,</span> <span class="n">surface</span><span class="p">)</span>
    <span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span> <span class="o">=</span> <span class="n">projector</span><span class="o">.</span><span class="n">LowerDistanceParameters</span><span class="p">()</span>

    <span class="n">gp_pnt</span> <span class="o">=</span> <span class="n">gp_Pnt</span><span class="p">()</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">gp_Vec</span><span class="p">()</span>
    <span class="n">BRepGProp_Face</span><span class="p">(</span><span class="n">face</span><span class="p">)</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">u_val</span><span class="p">,</span> <span class="n">v_val</span><span class="p">,</span> <span class="n">gp_pnt</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">downcast</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Downcasts a TopoDS object to suitable specialized type</span>

<span class="sd">    Args:</span>
<span class="sd">      obj: TopoDS_Shape:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">f_downcast</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">downcast_LUT</span><span class="p">[</span><span class="n">shapetype</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">f_downcast</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fix</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fix a TopoDS object to suitable specialized type</span>

<span class="sd">    Args:</span>
<span class="sd">      obj: TopoDS_Shape:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shape_fix</span> <span class="o">=</span> <span class="n">ShapeFix_Shape</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">shape_fix</span><span class="o">.</span><span class="n">Perform</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">downcast</span><span class="p">(</span><span class="n">shape_fix</span><span class="o">.</span><span class="n">Shape</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_top_level_topods_shapes</span><span class="p">(</span>
    <span class="n">topods_shape</span><span class="p">:</span> <span class="n">TopoDS_Shape</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TopoDS_Shape</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the first level of child shapes from the shape.</span>

<span class="sd">    This method collects all the non-compound shapes directly contained in the</span>
<span class="sd">    current shape. If the wrapped shape is a `TopoDS_Compound`, it traverses</span>
<span class="sd">    its immediate children and collects all shapes that are not further nested</span>
<span class="sd">    compounds. Nested compounds are traversed to gather their non-compound elements</span>
<span class="sd">    without returning the nested compound itself.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[TopoDS_Shape]: A list of all first-level non-compound child shapes.</span>

<span class="sd">    Example:</span>
<span class="sd">        If the current shape is a compound containing both simple shapes</span>
<span class="sd">        (e.g., edges, vertices) and other compounds, the method returns a list</span>
<span class="sd">        of only the simple shapes directly contained at the top level.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">topods_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">()</span>

    <span class="n">first_level_shapes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">topods_shape</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">current_shape</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_shape</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">TopoDS_Iterator</span><span class="p">()</span>
            <span class="n">iterator</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">current_shape</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">iterator</span><span class="o">.</span><span class="n">More</span><span class="p">():</span>
                <span class="n">child_shape</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">Value</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_shape</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
                    <span class="c1"># Traverse further into the compound</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Add non-compound shape</span>
                    <span class="n">first_level_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_shape</span><span class="p">)</span>
                <span class="n">iterator</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_level_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">first_level_shapes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">shapetype</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">TopoDS_Shape</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopAbs_ShapeEnum</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return TopoDS_Shape&#39;s TopAbs_ShapeEnum&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="n">IsNull</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Null TopoDS_Shape object&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">ShapeType</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">topods_dim</span><span class="p">(</span><span class="n">topods</span><span class="p">:</span> <span class="n">TopoDS_Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the dimension of this TopoDS_Shape&quot;&quot;&quot;</span>
    <span class="n">shape_dim_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">TopoDS_Vertex</span><span class="p">,):</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">(</span><span class="n">TopoDS_Edge</span><span class="p">,</span> <span class="n">TopoDS_Wire</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">(</span><span class="n">TopoDS_Face</span><span class="p">,</span> <span class="n">TopoDS_Shell</span><span class="p">):</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">(</span><span class="n">TopoDS_Solid</span><span class="p">,):</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">shape_types</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape_dim_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topods</span><span class="p">,</span> <span class="n">shape_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dim</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topods</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
        <span class="n">sub_dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">topods_dim</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">get_top_level_topods_shapes</span><span class="p">(</span><span class="n">topods</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">sub_dims</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">unwrap_topods_compound</span><span class="p">(</span>
    <span class="n">compound</span><span class="p">:</span> <span class="n">TopoDS_Compound</span><span class="p">,</span> <span class="n">fully</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopoDS_Compound</span> <span class="o">|</span> <span class="n">TopoDS_Shape</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Strip unnecessary Compound wrappers</span>

<span class="sd">    Args:</span>
<span class="sd">        compound (TopoDS_Compound): The TopoDS_Compound to unwrap.</span>
<span class="sd">        fully (bool, optional): return base shape without any TopoDS_Compound</span>
<span class="sd">            wrappers (otherwise one TopoDS_Compound is left). Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        TopoDS_Compound | TopoDS_Shape: base shape</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">compound</span><span class="o">.</span><span class="n">NbChildren</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">TopoDS_Iterator</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>
        <span class="n">single_element</span> <span class="o">=</span> <span class="n">downcast</span><span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">Value</span><span class="p">())</span>

        <span class="c1"># If the single element is another TopoDS_Compound, unwrap it recursively</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">single_element</span><span class="p">,</span> <span class="n">TopoDS_Compound</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unwrap_topods_compound</span><span class="p">(</span><span class="n">single_element</span><span class="p">,</span> <span class="n">fully</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">single_element</span> <span class="k">if</span> <span class="n">fully</span> <span class="k">else</span> <span class="n">compound</span>

    <span class="c1"># If there are no elements or more than one element, return TopoDS_Compound</span>
    <span class="k">return</span> <span class="n">compound</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gumyr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
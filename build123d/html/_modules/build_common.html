

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>build_common &mdash; build123d 0.9.2.dev40+gb1f0eed documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/sphinx_rtd_theme.css?v=3234e928" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c97902b4"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/js/hoverxref.js"></script>
      <script src="../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../_static/js/micromodal.min.js"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            build123d
              <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../key_concepts_builder.html">Key Concepts (builder mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../key_concepts_algebra.html">Key Concepts (algebra mode)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../moving_objects.html">Moving Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OpenSCAD.html">Transitioning from OpenSCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introductory_examples.html">Introductory Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../objects.html">Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../selectors_operators.html">Selectors and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builders.html">Builders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../joints.html">Joints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assemblies.html">Assemblies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tips.html">Tips, Best Practices and FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../import_export.html">Import/Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheat_sheet.html">Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../external.html">External Tools and Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../builder_api_reference.html">Builder Common API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../direct_api_reference.html">Direct API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">build123d</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">build_common</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for build_common</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">build123d Common</span>

<span class="sd">name: build_common.py</span>
<span class="sd">by:   Gumyr</span>
<span class="sd">date: July 12th 2022</span>

<span class="sd">desc:</span>
<span class="sd">    This is a Python code defining a class hierarchy for building CAD</span>
<span class="sd">    models. The code defines an abstract base class Builder with three</span>
<span class="sd">    concrete subclasses BuildLine, BuildPart, and BuildSketch in separate</span>
<span class="sd">    modules.</span>

<span class="sd">    The Builder class has several methods for adding and retrieving</span>
<span class="sd">    geometric shapes such as vertices, edges, faces, and solids. It also</span>
<span class="sd">    has a method _add_to_pending for adding shapes to a pending list that</span>
<span class="sd">    will be integrated into the final model later. The class has a</span>
<span class="sd">    _get_context method for retrieving the current Builder instance and a</span>
<span class="sd">    validate_inputs method for validating input shapes.</span>

<span class="sd">    The code also defines a validate_inputs function that takes a Builder</span>
<span class="sd">    instance and validates the input shapes.</span>

<span class="sd">license:</span>

<span class="sd">    Copyright 2022 Gumyr</span>

<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>

<span class="sd">        http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">contextvars</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.build_enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">Align</span><span class="p">,</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">Select</span><span class="p">,</span> <span class="n">Unit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">Location</span><span class="p">,</span>
    <span class="n">Plane</span><span class="p">,</span>
    <span class="n">Vector</span><span class="p">,</span>
    <span class="n">VectorLike</span><span class="p">,</span>
    <span class="n">to_align_offset</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">build123d.topology</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Compound</span><span class="p">,</span>
    <span class="n">Curve</span><span class="p">,</span>
    <span class="n">Edge</span><span class="p">,</span>
    <span class="n">Face</span><span class="p">,</span>
    <span class="n">Joint</span><span class="p">,</span>
    <span class="n">Part</span><span class="p">,</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">ShapeList</span><span class="p">,</span>
    <span class="n">Sketch</span><span class="p">,</span>
    <span class="n">Solid</span><span class="p">,</span>
    <span class="n">Vertex</span><span class="p">,</span>
    <span class="n">Wire</span><span class="p">,</span>
    <span class="n">tuplify</span><span class="p">,</span>
    <span class="n">new_edges</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># pylint: disable=too-many-lines</span>

<span class="c1"># Create a build123d logger to distinguish these logs from application logs.</span>
<span class="c1"># If the user doesn&#39;t configure logging, all build123d logs will be discarded.</span>
<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;build123d&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NullHandler</span><span class="p">())</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;build123d&quot;</span><span class="p">)</span>

<span class="c1"># The recommended user log configuration is as follows:</span>
<span class="c1"># logging.basicConfig(</span>
<span class="c1">#     filename=&quot;myapp.log&quot;,</span>
<span class="c1">#     level=logging.INFO,</span>
<span class="c1">#     format=&quot;%(name)s-%(levelname)s %(asctime)s - [%(filename)s:%(lineno)s - \</span>
<span class="c1">#     %(funcName)20s() ] - %(message)s&quot;,</span>
<span class="c1"># )</span>
<span class="c1"># Where using %(name)s in the log format will distinguish between user and build123d library logs</span>

<span class="c1">#</span>
<span class="c1"># CONSTANTS</span>
<span class="c1">#</span>

<span class="c1"># LENGTH CONSTANTS</span>
<span class="n">MC</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">MM</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">CM</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">MM</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">MM</span>
<span class="n">IN</span> <span class="o">=</span> <span class="mf">25.4</span> <span class="o">*</span> <span class="n">MM</span>
<span class="n">FT</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">IN</span>
<span class="n">THOU</span> <span class="o">=</span> <span class="n">IN</span> <span class="o">/</span> <span class="mi">1000</span>

<span class="c1"># UNIT CONVERSIONS</span>
<span class="n">UNITS_PER_METER</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">IN</span><span class="p">:</span> <span class="n">M</span> <span class="o">/</span> <span class="n">IN</span><span class="p">,</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">FT</span><span class="p">:</span> <span class="n">M</span> <span class="o">/</span> <span class="n">FT</span><span class="p">,</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">MC</span><span class="p">:</span> <span class="n">M</span> <span class="o">/</span> <span class="n">MC</span><span class="p">,</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">MM</span><span class="p">:</span> <span class="n">M</span> <span class="o">/</span> <span class="n">MM</span><span class="p">,</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">CM</span><span class="p">:</span> <span class="n">M</span> <span class="o">/</span> <span class="n">CM</span><span class="p">,</span>
    <span class="n">Unit</span><span class="o">.</span><span class="n">M</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># MASS CONSTANTS</span>
<span class="n">G</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">KG</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">G</span>
<span class="n">LB</span> <span class="o">=</span> <span class="mf">453.59237</span> <span class="o">*</span> <span class="n">G</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_point</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify points as tuples of numbers&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span>
    <span class="p">)</span>


<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">flatten_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a sequence of object potentially containing iterables into a flat list&quot;&quot;&quot;</span>

    <span class="n">flat_list</span><span class="p">:</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
        <span class="c1"># Note: an Iterable can&#39;t be used here as it will match with Vector &amp; Vertex</span>
        <span class="c1"># and break them into a list of floats.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_point</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">flat_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flat_list</span>


<span class="n">operations_apply_to</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;bounding_box&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;chamfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;extrude&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;fillet&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;full_round&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildSketch&quot;</span><span class="p">],</span>
    <span class="s2">&quot;loft&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;make_brake_formed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;make_face&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildSketch&quot;</span><span class="p">],</span>
    <span class="s2">&quot;make_hull&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildSketch&quot;</span><span class="p">],</span>
    <span class="s2">&quot;mirror&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;project&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;project_workplane&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;revolve&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;section&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
    <span class="s2">&quot;split&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildLine&quot;</span><span class="p">],</span>
    <span class="s2">&quot;sweep&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">,</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">],</span>
    <span class="s2">&quot;thicken&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;BuildPart&quot;</span><span class="p">],</span>
<span class="p">}</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Builder&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Builder type hint&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Builder</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builder</span>

<span class="sd">    Base class for the build123d Builders.</span>

<span class="sd">    Args:</span>
<span class="sd">        workplanes: sequence of Union[Face, Plane, Location]: set plane(s) to work on</span>
<span class="sd">        mode (Mode, optional): combination mode. Defaults to Mode.ADD.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        mode (Mode): builder&#39;s combination mode</span>
<span class="sd">        workplanes (list[Plane]): active workplanes</span>
<span class="sd">        builder_parent (Builder): build to pass objects to on exit</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-instance-attributes</span>

    <span class="c1"># Context variable used to by Objects and Operations to link to current builder instance</span>
    <span class="n">_current</span><span class="p">:</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">[</span><span class="n">Builder</span><span class="p">]</span> <span class="o">=</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">(</span>
        <span class="s2">&quot;Builder._current&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Abstract class variables</span>
    <span class="n">_tag</span> <span class="o">=</span> <span class="s2">&quot;Builder&quot;</span>
    <span class="n">_obj_name</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
    <span class="c1"># _shape: Shape  # The type of the shape the builder creates</span>
    <span class="c1"># _sub_class: Curve | Sketch | Part  # The class of the shape the builder creates</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">workplanes</span><span class="p">:</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Plane</span> <span class="o">|</span> <span class="n">Location</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Mode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_convert_to_planes</span><span class="p">(</span><span class="n">workplanes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span> <span class="o">=</span> <span class="n">planes</span> <span class="k">if</span> <span class="n">planes</span> <span class="k">else</span> <span class="p">[</span><span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">current_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">current_frame</span><span class="o">.</span><span class="n">f_back</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_python_frame</span> <span class="o">=</span> <span class="n">current_frame</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">Vertex</span><span class="p">:</span> <span class="p">[],</span> <span class="n">Edge</span><span class="p">:</span> <span class="p">[],</span> <span class="n">Face</span><span class="p">:</span> <span class="p">[],</span> <span class="n">Solid</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workplanes_context</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_workplanes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Plane</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_before</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_combine</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Shape</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Object to pass to parent&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@_obj</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Part</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum size of object in all directions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">()</span><span class="o">.</span><span class="n">diagonal</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Edges that changed during last operation&quot;&quot;&quot;</span>
        <span class="n">before_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_before</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_before</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_edges</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">before_list</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_combine</span><span class="p">),</span> <span class="n">combined</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon entering record the parent and a token to restore contextvars&quot;&quot;&quot;</span>

        <span class="c1"># Only set parents from the same scope. Note inspect.currentframe() is supported</span>
        <span class="c1"># by CPython in Linux, Window &amp; MacOS but may not be supported in other python</span>
        <span class="c1"># implementations.  Support outside of these OS&#39;s is outside the scope of this</span>
        <span class="c1"># project.</span>
        <span class="n">same_scope</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Builder</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">_python_frame</span> <span class="o">==</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span>
            <span class="k">if</span> <span class="n">Builder</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span>
            <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">same_scope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Entering </span><span class="si">%s</span><span class="s2"> with mode=</span><span class="si">%s</span><span class="s2"> which is in </span><span class="si">%s</span><span class="s2"> scope as parent&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="s2">&quot;same&quot;</span> <span class="k">if</span> <span class="n">same_scope</span> <span class="k">else</span> <span class="s2">&quot;different&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If there are no workplanes, create a default XY plane</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workplanes_context</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">)</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workplanes_context</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="p">(</span><span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">)</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_exit_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Any builder specific exit actions&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon exiting restore context and send object to parent&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_exit_extras</span><span class="p">()</span>  <span class="c1"># custom builder exit code</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">Mode</span><span class="o">.</span><span class="n">PRIVATE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Transferring object(s) to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_name</span><span class="si">}</span><span class="s2"> is None - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="si">}</span><span class="s2"> didn&#39;t create anything&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">builder_parent</span><span class="o">.</span><span class="n">_add_to_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exit_workplanes</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">workplanes</span>

        <span class="c1"># Now that the object has been transferred, it&#39;s save to remove any (non-default)</span>
        <span class="c1"># workplanes that were created then exit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workplanes_context</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exiting </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_to_pending</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">objects</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Face</span><span class="p">,</span> <span class="n">face_plane</span><span class="p">:</span> <span class="n">Plane</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrate a sequence of objects into existing builder object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>  <span class="c1"># pragma: no cover</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_context</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">B</span><span class="p">],</span>
        <span class="n">caller</span><span class="p">:</span> <span class="n">Builder</span> <span class="o">|</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Joint</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the instance of the current builder&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">context_name</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span> <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="p">(</span><span class="n">Part</span><span class="p">,</span> <span class="n">Sketch</span><span class="p">,</span> <span class="n">Curve</span><span class="p">,</span> <span class="n">Wire</span><span class="p">)):</span>
                <span class="n">caller_name</span> <span class="o">=</span> <span class="n">caller</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">caller_name</span> <span class="o">=</span> <span class="n">caller</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">caller_name</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> context requested by </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">context_name</span><span class="p">,</span> <span class="n">caller_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_to_context</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">objects</span><span class="p">:</span> <span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">,</span>
        <span class="n">faces_to_pending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Mode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add objects to Builder instance</span>

<span class="sd">        Core method to interface with Builder instance. Input sequence of objects is</span>
<span class="sd">        parsed into lists of edges, faces, and solids. Edges and faces are added to pending</span>
<span class="sd">        lists. Solids are combined with current part.</span>

<span class="sd">        Each operation generates a list of vertices, edges, faces, and solids that have</span>
<span class="sd">        changed during this operation. These lists are only guaranteed to be valid up until</span>
<span class="sd">        the next operation as subsequent operations can eliminate these objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            objects (Union[Edge, Wire, Face, Solid, Compound]): sequence of objects to add</span>
<span class="sd">            faces_to_pending (bool, optional): add faces to pending_faces. Default to True.</span>
<span class="sd">            clean (bool, optional): Remove extraneous internal structure. Defaults to True.</span>
<span class="sd">            mode (Mode, optional): combination mode. Defaults to Mode.ADD.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Invalid input</span>
<span class="sd">            ValueError: Nothing to intersect with</span>
<span class="sd">            ValueError: Nothing to intersect with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="c1"># pylint: disable=too-many-statements</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obj_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_combine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">Mode</span><span class="o">.</span><span class="n">PRIVATE</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Typed dictionary: keys are classes, values are lists of instances of those classes</span>
            <span class="n">typed</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
                <span class="n">Type</span><span class="p">[</span><span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">],</span>
                <span class="nb">list</span><span class="p">[</span><span class="n">Edge</span> <span class="o">|</span> <span class="n">Wire</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Solid</span> <span class="o">|</span> <span class="n">Compound</span><span class="p">],</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="bp">cls</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Solid</span><span class="p">,</span> <span class="n">Compound</span><span class="p">]}</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Solid</span><span class="p">,</span> <span class="n">Compound</span><span class="p">]:</span>
                <span class="n">typed</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)]</span>

            <span class="c1"># Check for invalid inputs</span>
            <span class="n">num_stored</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">typed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="c1"># Generate an exception if not processing exceptions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_stored</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">unsupported</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">v</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">typed</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">unsupported</span> <span class="o">!=</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="si">}</span><span class="s2"> doesn&#39;t accept </span><span class="si">{</span><span class="n">unsupported</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Extract base objects from Compounds</span>
            <span class="n">compound</span><span class="p">:</span> <span class="n">Compound</span>
            <span class="k">for</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">typed</span><span class="p">[</span><span class="n">Compound</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">obj_types</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Wire</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Solid</span><span class="p">]:</span>
                    <span class="n">typed</span><span class="p">[</span><span class="n">obj_types</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">compound</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">obj_types</span><span class="p">))</span>

            <span class="c1"># Align sketch planar faces with Plane.XY</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">==</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">:</span>
                <span class="n">aligned</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">new_face</span><span class="p">:</span> <span class="n">Face</span>
                <span class="k">for</span> <span class="n">new_face</span> <span class="ow">in</span> <span class="n">typed</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_face</span><span class="o">.</span><span class="n">is_coplanar</span><span class="p">(</span><span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">):</span>
                        <span class="c1"># Try to keep the x direction, if not allow it to be assigned automatically</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span>
                                <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="n">x_dir</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="n">z_dir</span><span class="o">=</span><span class="n">new_face</span><span class="o">.</span><span class="n">normal_at</span><span class="p">(),</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">z_dir</span><span class="o">=</span><span class="n">new_face</span><span class="o">.</span><span class="n">normal_at</span><span class="p">())</span>

                        <span class="n">new_face</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">to_local_coords</span><span class="p">(</span><span class="n">new_face</span><span class="p">)</span>
                        <span class="n">new_face</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">Location</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">new_face</span><span class="o">.</span><span class="n">center</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="n">new_face</span><span class="o">.</span><span class="n">normal_at</span><span class="p">()</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Flip the face if up-side-down</span>
                        <span class="n">aligned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aligned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">new_face</span><span class="p">)</span>
                <span class="n">typed</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">=</span> <span class="n">aligned</span>

            <span class="c1"># Convert wires to edges</span>
            <span class="n">new_wire</span><span class="p">:</span> <span class="n">Wire</span>
            <span class="k">for</span> <span class="n">new_wire</span> <span class="ow">in</span> <span class="n">typed</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
                <span class="n">typed</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_wire</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

            <span class="c1"># Allow faces to be combined with solids for section operations</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">faces_to_pending</span><span class="p">:</span>
                <span class="n">typed</span><span class="p">[</span><span class="n">Solid</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="n">Face</span><span class="p">])</span>
                <span class="n">typed</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Store the objects pre integration</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Solid</span><span class="p">]:</span>
                <span class="n">pre</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to integrate </span><span class="si">%d</span><span class="s2"> object(s) into part with Mode=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">]),</span>
                    <span class="n">mode</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">combined</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">Mode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">combined</span> <span class="o">=</span> <span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">combined</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">])</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">Mode</span><span class="o">.</span><span class="n">SUBTRACT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Nothing to subtract from&quot;</span><span class="p">)</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">Mode</span><span class="o">.</span><span class="n">INTERSECT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Nothing to intersect with&quot;</span><span class="p">)</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">Mode</span><span class="o">.</span><span class="n">REPLACE</span><span class="p">:</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">]))</span>

                <span class="k">if</span> <span class="n">combined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># empty intersection result</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">combined</span><span class="p">,</span> <span class="nb">list</span>
                <span class="p">):</span>  <span class="c1"># If the boolean operation created a list, convert back</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">combined</span>
                <span class="c1"># If the boolean operation created a list, convert back</span>
                <span class="c1"># self._obj = (</span>
                <span class="c1">#     self._sub_class(combined)</span>
                <span class="c1">#     if isinstance(combined, list)</span>
                <span class="c1">#     else combined</span>
                <span class="c1"># )</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">clean</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Completed integrating </span><span class="si">%d</span><span class="s2"> object(s) into part with Mode=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">]),</span>
                    <span class="n">mode</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Determine the last object</span>
            <span class="c1"># Note that when determining the Select.LAST values for the core shape type of a builder</span>
            <span class="c1"># the answer is just the categorized inputs to this method.  I.e.</span>
            <span class="c1"># Buildline.edges(Select.LAST) just returns the typed[Edge] values as that&#39;s what</span>
            <span class="c1"># just was added - no need for the set math.</span>
            <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Face</span><span class="p">,</span> <span class="n">Solid</span><span class="p">]:</span>
                <span class="n">post</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">ShapeList</span><span class="p">(</span><span class="n">typed</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">==</span> <span class="bp">cls</span>
                    <span class="k">else</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">post</span> <span class="o">-</span> <span class="n">pre</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
                <span class="p">)</span>

            <span class="c1"># Cast to appropriate base types (Curve, Sketch or Part)</span>
            <span class="c1"># _sub_class is an abstract class variable assigned in the sub classes</span>
            <span class="c1"># pylint: disable=not-callable</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">Compound</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_class</span><span class="p">(</span><span class="n">Compound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shapes</span><span class="p">())</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>

            <span class="c1"># Add to pending</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">==</span> <span class="s2">&quot;BuildPart&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_pending</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="n">Edge</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">plane</span> <span class="ow">in</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">workplanes</span><span class="p">:</span>
                    <span class="n">global_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">from_local_coords</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">typed</span><span class="p">[</span><span class="n">Face</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_pending</span><span class="p">(</span><span class="o">*</span><span class="n">global_faces</span><span class="p">,</span> <span class="n">face_plane</span><span class="o">=</span><span class="n">plane</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">==</span> <span class="s2">&quot;BuildSketch&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_pending</span><span class="p">(</span><span class="o">*</span><span class="n">typed</span><span class="p">[</span><span class="n">Edge</span><span class="p">])</span>

    <span class="c1"># Known pylint issue with Enums</span>
    <span class="c1"># pylint: disable=no-member</span>
<div class="viewcode-block" id="Builder.vertices">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Builder.vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Vertices</span>

<span class="sd">        Return either all or the vertices created during the last operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Vertex selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Vertex]: Vertices extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">vertex_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj_edge</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">vertex_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Select.NEW only valid for edges&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input, must be one of Select.</span><span class="si">{</span><span class="n">Select</span><span class="o">.</span><span class="n">_member_names_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vertex_list</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vertex</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Vertex</span>

<span class="sd">        Return a vertex.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Vertex selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vertex: Vertex extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_vertices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertex_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">vertex_count</span><span class="si">}</span><span class="s2"> vertices, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">all_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Builder.edges">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Builder.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Edge</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Edges</span>

<span class="sd">        Return either all or the edges created during the last operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Edge selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Edge]: Edges extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input, must be one of Select.</span><span class="si">{</span><span class="n">Select</span><span class="o">.</span><span class="n">_member_names_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Edge</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Edge</span>

<span class="sd">        Return an edge.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Edge selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Edge: Edge extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">edge_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">edge_count</span><span class="si">}</span><span class="s2"> edges, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">all_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Builder.wires">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Builder.wires">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wires</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Wire</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Wires</span>

<span class="sd">        Return either all or the wires created during the last operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Wire selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Wire]: Wires extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="n">wire_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">wires</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">wire_list</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="n">Edge</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Select.NEW only valid for edges&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input, must be one of Select.</span><span class="si">{</span><span class="n">Select</span><span class="o">.</span><span class="n">_member_names_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">wire_list</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wire</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Wire</span>

<span class="sd">        Return a wire.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Wire selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Wire: Wire extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_wires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wires</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">wire_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_wires</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wire_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">wire_count</span><span class="si">}</span><span class="s2"> wires, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">all_wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Builder.faces">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Builder.faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Face</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Faces</span>

<span class="sd">        Return either all or the faces created during the last operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Face selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Face]: Faces extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="n">face_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">face_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Select.NEW only valid for edges&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input, must be one of Select.</span><span class="si">{</span><span class="n">Select</span><span class="o">.</span><span class="n">_member_names_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">face_list</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Face</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Face</span>

<span class="sd">        Return a face.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Face selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Face: Face extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">face_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_faces</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">face_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">face_count</span><span class="si">}</span><span class="s2"> faces, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">all_faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Builder.solids">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Builder.solids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Solid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Solids</span>

<span class="sd">        Return either all or the solids created during the last operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Solid selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ShapeList[Solid]: Solids extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="n">solid_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">solid_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasts</span><span class="p">[</span><span class="n">Solid</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">select</span> <span class="o">==</span> <span class="n">Select</span><span class="o">.</span><span class="n">NEW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Select.NEW only valid for edges&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input, must be one of Select.</span><span class="si">{</span><span class="n">Select</span><span class="o">.</span><span class="n">_member_names_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ShapeList</span><span class="p">(</span><span class="n">solid_list</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">solid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Solid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Solid</span>

<span class="sd">        Return a solid.</span>

<span class="sd">        Args:</span>
<span class="sd">            select (Select, optional): Solid selector. Defaults to Select.ALL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Solid: Solid extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_solids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solids</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">solid_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_solids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solid_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">solid_count</span><span class="si">}</span><span class="s2"> solids, returning first&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">all_solids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_shapes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Vertex</span><span class="p">]</span> <span class="o">|</span> <span class="n">Type</span><span class="p">[</span><span class="n">Edge</span><span class="p">]</span> <span class="o">|</span> <span class="n">Type</span><span class="p">[</span><span class="n">Face</span><span class="p">]</span> <span class="o">|</span> <span class="n">Type</span><span class="p">[</span><span class="n">Solid</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ShapeList</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract Shapes&quot;&quot;&quot;</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="k">if</span> <span class="n">obj_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">obj_type</span>
        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">Vertex</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">Edge</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">Face</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">Solid</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">validate_inputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">validating_class</span><span class="p">,</span> <span class="n">objects</span><span class="p">:</span> <span class="n">Shape</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that objects/operations and parameters apply&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">validating_class</span><span class="p">,</span> <span class="p">(</span><span class="n">Part</span><span class="p">,</span> <span class="n">Sketch</span><span class="p">,</span> <span class="n">Curve</span><span class="p">,</span> <span class="n">Wire</span><span class="p">))</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validating_class</span><span class="o">.</span><span class="n">_applies_to</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> doesn&#39;t have a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">validating_class</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object or operation &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">validating_class</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> applies to </span><span class="si">{</span><span class="n">validating_class</span><span class="o">.</span><span class="n">_applies_to</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">validating_class</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operations_apply_to</span><span class="p">[</span><span class="n">validating_class</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">validating_class</span><span class="si">}</span><span class="s2"> doesn&#39;t apply to </span><span class="si">{</span><span class="n">operations_apply_to</span><span class="p">[</span><span class="n">validating_class</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Check for valid object inputs</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">validating_class</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validating_class</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">validating_class</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2"> doesn&#39;t accept </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; did you intend &lt;keyword&gt;=</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">?&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_invalid_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise an error for invalid boolean combine operations&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is a builder of Shapes and can&#39;t be &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;combined. The object being constructed is accessible via the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_name</span><span class="si">}</span><span class="s2">&#39; attribute.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invalid add&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_combine</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invalid sub&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_combine</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invalid and&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_combine</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The user is likely trying to reference the builder&#39;s object&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; has no attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Did you intend &#39;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&gt;.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj_name</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;?&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_inputs</span><span class="p">(</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Builder</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">validating_class</span><span class="p">,</span> <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Shape</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function to wrap the method when used outside of a Builder context&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">context</span><span class="o">.</span><span class="n">validate_inputs</span><span class="p">(</span><span class="n">validating_class</span><span class="p">,</span> <span class="n">objects</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LocationList</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location Context</span>

<span class="sd">    A stateful context of active locations. At least one must be active</span>
<span class="sd">    at all time. Note that local locations are stored and global locations</span>
<span class="sd">    are returned as a property of the local locations and the currently</span>
<span class="sd">    active workplanes.</span>

<span class="sd">    Args:</span>
<span class="sd">        locations (list[Location]): list of locations to add to the context</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Context variable used to link to LocationList instance</span>
    <span class="n">_current</span><span class="p">:</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">[</span><span class="n">LocationList</span><span class="p">]</span> <span class="o">=</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">(</span>
        <span class="s2">&quot;ContextList._current&quot;</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">locations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Current local locations globalized with current workplanes&quot;&quot;&quot;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span>
        <span class="n">workplanes</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">workplanes</span> <span class="k">if</span> <span class="n">context</span> <span class="k">else</span> <span class="p">[</span><span class="n">Plane</span><span class="o">.</span><span class="n">XY</span><span class="p">]</span>
        <span class="n">global_locations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">location</span> <span class="o">*</span> <span class="n">local_location</span>
            <span class="k">for</span> <span class="n">plane</span> <span class="ow">in</span> <span class="n">workplanes</span>
            <span class="k">for</span> <span class="n">local_location</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">global_locations</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span> <span class="o">=</span> <span class="n">locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_loc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon entering create a token to restore contextvars&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is pushing </span><span class="si">%d</span><span class="s2"> points: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon exiting restore context&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is popping </span><span class="si">%d</span><span class="s2"> points&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize to beginning&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locations</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;While not through all the locations, return the next one&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">location_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_loc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">location_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized application of locations to a shape&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location list can only be multiplied with shapes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">loc</span> <span class="o">*</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">locations</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_context</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the instance of the current LocationList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<div class="viewcode-block" id="HexLocations">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.HexLocations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HexLocations</span><span class="p">(</span><span class="n">LocationList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location Context: Hex Array</span>

<span class="sd">    Creates a context of hexagon array of locations for Part or Sketch. When creating</span>
<span class="sd">    hex locations for an array of circles, set `radius` to the radius of the circle</span>
<span class="sd">    plus one half the spacing between the circles.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (float): distance from origin to vertices (major), or</span>
<span class="sd">            optionally from the origin to side (minor or apothem)</span>
<span class="sd">            with major_radius = False</span>
<span class="sd">        x_count (int): number of points ( &gt; 0 )</span>
<span class="sd">        y_count (int): number of points ( &gt; 0 )</span>
<span class="sd">        major_radius (bool): If True the radius is the major radius, else the</span>
<span class="sd">            radius is the minor radius (also known as inscribed radius).</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.</span>
<span class="sd">            Defaults to (Align.CENTER, Align.CENTER).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        radius (float): distance from origin to vertices (major), or</span>
<span class="sd">            optionally from the origin to side (minor or apothem)</span>
<span class="sd">            with major_radius = False</span>
<span class="sd">        apothem (float): radius of the inscribed circle, also known as minor radius</span>
<span class="sd">        x_count (int): number of points ( &gt; 0 )</span>
<span class="sd">        y_count (int): number of points ( &gt; 0 )</span>
<span class="sd">        major_radius (bool): If True the radius is the major radius, else the</span>
<span class="sd">            radius is the minor radius (also known as inscribed radius).</span>
<span class="sd">        align (Union[Align, tuple[Align, Align]]): align min, center, or max of object.</span>
<span class="sd">        diagonal (float): major radius</span>
<span class="sd">        local_locations (list{Location}): locations relative to workplane</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Spacing and count must be &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">x_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">y_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">major_radius</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">align</span><span class="p">:</span> <span class="n">Align</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Align</span><span class="p">,</span> <span class="n">Align</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Align</span><span class="o">.</span><span class="n">CENTER</span><span class="p">,</span> <span class="n">Align</span><span class="o">.</span><span class="n">CENTER</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="k">if</span> <span class="n">major_radius</span><span class="p">:</span>
            <span class="n">diagonal</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span>
            <span class="n">apothem</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diagonal</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">apothem</span> <span class="o">=</span> <span class="n">radius</span>

        <span class="n">x_spacing</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">diagonal</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="n">y_spacing</span> <span class="o">=</span> <span class="n">diagonal</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">x_spacing</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y_spacing</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spacing and count must be &gt; 0 &quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apothem</span> <span class="o">=</span> <span class="n">apothem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span> <span class="o">=</span> <span class="n">diagonal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_count</span> <span class="o">=</span> <span class="n">x_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_count</span> <span class="o">=</span> <span class="n">y_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">major_radius</span> <span class="o">=</span> <span class="n">major_radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align</span> <span class="o">=</span> <span class="n">tuplify</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Generate the raw coordinates relative to bottom left point</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">[</span><span class="n">Vector</span><span class="p">]()</span>
        <span class="k">for</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_count</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y_val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_count</span><span class="p">):</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Vector</span><span class="p">(</span><span class="n">x_spacing</span> <span class="o">*</span> <span class="n">x_val</span><span class="p">,</span> <span class="n">y_spacing</span> <span class="o">*</span> <span class="n">y_val</span> <span class="o">+</span> <span class="n">y_spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_count</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y_val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_count</span><span class="p">):</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">x_spacing</span> <span class="o">*</span> <span class="n">x_val</span><span class="p">,</span> <span class="n">y_spacing</span> <span class="o">*</span> <span class="n">y_val</span> <span class="o">+</span> <span class="n">y_spacing</span><span class="p">))</span>

        <span class="c1"># Determine the minimum point and size of the array</span>
        <span class="n">sorted_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">points</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="o">.</span><span class="n">X</span><span class="p">),</span> <span class="n">points</span><span class="o">.</span><span class="n">sort_by</span><span class="p">(</span><span class="n">Axis</span><span class="o">.</span><span class="n">Y</span><span class="p">)]</span>
        <span class="c1"># pylint doesn&#39;t recognize that a ShapeList of Vector is valid</span>
        <span class="c1"># pylint: disable=no-member</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sorted_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">sorted_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
            <span class="n">sorted_points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">sorted_points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">min_corner</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">sorted_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># Calculate the amount to offset the array to align it</span>
        <span class="n">align_offset</span> <span class="o">=</span> <span class="n">to_align_offset</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>

        <span class="c1"># Align the points</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">ShapeList</span><span class="p">(</span>
            <span class="p">[</span><span class="n">point</span> <span class="o">+</span> <span class="n">Vector</span><span class="p">(</span><span class="o">*</span><span class="n">align_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_corner</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Convert to locations and store the reference plane</span>
        <span class="n">local_locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Location</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span> <span class="o">=</span> <span class="n">Locations</span><span class="o">.</span><span class="n">_move_to_existing</span><span class="p">(</span>
            <span class="n">local_locations</span>
        <span class="p">)</span>  <span class="c1">#: values independent of workplanes</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">)</span></div>



<div class="viewcode-block" id="PolarLocations">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.PolarLocations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PolarLocations</span><span class="p">(</span><span class="n">LocationList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location Context: Polar Array</span>

<span class="sd">    Creates a context of polar array of locations for Part or Sketch</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (float): array radius</span>
<span class="sd">        count (int): Number of points to push</span>
<span class="sd">        start_angle (float, optional): angle to first point from +ve X axis. Defaults to 0.0.</span>
<span class="sd">        angular_range (float, optional): magnitude of array from start angle. Defaults to 360.0.</span>
<span class="sd">        rotate (bool, optional): Align locations with arc tangents. Defaults to True.</span>
<span class="sd">        endpoint (bool, optional): If True, `start_angle` + `angular_range` is the last sample.</span>
<span class="sd">            Otherwise, it is not included. Defaults to False.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        local_locations (list{Location}): locations relative to workplane</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Count must be greater than or equal to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">angular_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">360.0</span><span class="p">,</span>
        <span class="n">rotate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At least 1 elements required, requested </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angle_step</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle_step</span> <span class="o">=</span> <span class="n">angular_range</span> <span class="o">/</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span>

        <span class="c1"># Note: rotate==False==0 so the location orientation doesn&#39;t change</span>
        <span class="n">local_locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Location</span><span class="p">(</span>
                    <span class="n">Vector</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">Axis</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">start_angle</span> <span class="o">+</span> <span class="n">angle_step</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span>
                    <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">rotate</span> <span class="o">*</span> <span class="p">(</span><span class="n">angle_step</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">start_angle</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span> <span class="o">=</span> <span class="n">Locations</span><span class="o">.</span><span class="n">_move_to_existing</span><span class="p">(</span>
            <span class="n">local_locations</span>
        <span class="p">)</span>  <span class="c1">#: values independent of workplanes</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">)</span></div>



<div class="viewcode-block" id="Locations">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.Locations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Locations</span><span class="p">(</span><span class="n">LocationList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location Context: Push Points</span>

<span class="sd">    Creates a context of locations for Part or Sketch</span>

<span class="sd">    Args:</span>
<span class="sd">        pts (Union[VectorLike, Vertex, Location, Face, Plane, Axis] or iterable of same):</span>
<span class="sd">            sequence of points to push</span>

<span class="sd">    Attributes:</span>
<span class="sd">        local_locations (list{Location}): locations relative to workplane</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">pts</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">VectorLike</span>
            <span class="o">|</span> <span class="n">Vertex</span>
            <span class="o">|</span> <span class="n">Location</span>
            <span class="o">|</span> <span class="n">Face</span>
            <span class="o">|</span> <span class="n">Plane</span>
            <span class="o">|</span> <span class="n">Axis</span>
            <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">VectorLike</span> <span class="o">|</span> <span class="n">Vertex</span> <span class="o">|</span> <span class="n">Location</span> <span class="o">|</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Plane</span> <span class="o">|</span> <span class="n">Axis</span><span class="p">]</span>
        <span class="p">),</span>
    <span class="p">):</span>
        <span class="n">local_locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">flatten_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">pts</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Location</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Axis</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Face</span><span class="p">):</span>
                <span class="n">local_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Location</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">point</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Locations doesn&#39;t accept type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span> <span class="o">=</span> <span class="n">Locations</span><span class="o">.</span><span class="n">_move_to_existing</span><span class="p">(</span>
            <span class="n">local_locations</span>
        <span class="p">)</span>  <span class="c1">#: values independent of workplanes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_move_to_existing</span><span class="p">(</span><span class="n">local_locations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Location</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_move_to_existing</span>

<span class="sd">        Move as a group the local locations to any existing locations  Note that existing</span>
<span class="sd">        polar locations may be rotated so this rotates the group not the individuals.</span>

<span class="sd">        Args:</span>
<span class="sd">            local_locations (list[Location]): location group to move to existing locations</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Location]: group of locations moved to existing locations as a group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">location_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">LocationList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group_center</span> <span class="ow">in</span> <span class="n">LocationList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">local_locations</span><span class="p">:</span>
                <span class="n">location_group</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">group_center</span> <span class="o">*</span> <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">local_locations</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">location_group</span> <span class="o">=</span> <span class="n">local_locations</span>
        <span class="k">return</span> <span class="n">location_group</span></div>



<div class="viewcode-block" id="GridLocations">
<a class="viewcode-back" href="../builder_api_reference.html#build_common.GridLocations">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GridLocations</span><span class="p">(</span><span class="n">LocationList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Location Context: Rectangular Array</span>

<span class="sd">    Creates a context of rectangular array of locations for Part or Sketch</span>

<span class="sd">    Args:</span>
<span class="sd">        x_spacing (float): horizontal spacing</span>
<span class="sd">        y_spacing (float): vertical spacing</span>
<span class="sd">        x_count (int): number of horizontal points</span>
<span class="sd">        y_count (int): number of vertical points</span>
<span class="sd">        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.</span>
<span class="sd">            Defaults to (Align.CENTER, Align.CENTER).</span>


<span class="sd">    Attributes:</span>
<span class="sd">        x_spacing (float): horizontal spacing</span>
<span class="sd">        y_spacing (float): vertical spacing</span>
<span class="sd">        x_count (int): number of horizontal points</span>
<span class="sd">        y_count (int): number of vertical points</span>
<span class="sd">        align (Union[Align, tuple[Align, Align]]): align min, center, or max of object.</span>
<span class="sd">        local_locations (list{Location}): locations relative to workplane</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Either x or y count must be greater than or equal to one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-instance-attributes</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_spacing</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">y_spacing</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">x_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">y_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">align</span><span class="p">:</span> <span class="n">Align</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Align</span><span class="p">,</span> <span class="n">Align</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Align</span><span class="o">.</span><span class="n">CENTER</span><span class="p">,</span> <span class="n">Align</span><span class="o">.</span><span class="n">CENTER</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">x_count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;At least 1 elements required, requested </span><span class="si">{</span><span class="n">x_count</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y_count</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_spacing</span> <span class="o">=</span> <span class="n">x_spacing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_spacing</span> <span class="o">=</span> <span class="n">y_spacing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_count</span> <span class="o">=</span> <span class="n">x_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_count</span> <span class="o">=</span> <span class="n">y_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align</span> <span class="o">=</span> <span class="n">tuplify</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">y_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span>  <span class="c1">#: size of the grid</span>

        <span class="n">align_offset</span> <span class="o">=</span> <span class="n">to_align_offset</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">align_offset</span>  <span class="c1">#: bottom left corner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>  <span class="c1">#: top right corner</span>

        <span class="c1"># Create the list of local locations</span>
        <span class="n">local_locations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Location</span><span class="p">(</span>
                <span class="n">align_offset</span>
                <span class="o">+</span> <span class="n">Vector</span><span class="p">(</span>
                    <span class="n">i</span> <span class="o">*</span> <span class="n">x_spacing</span><span class="p">,</span>
                    <span class="n">j</span> <span class="o">*</span> <span class="n">y_spacing</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x_count</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_count</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span> <span class="o">=</span> <span class="n">Locations</span><span class="o">.</span><span class="n">_move_to_existing</span><span class="p">(</span>
            <span class="n">local_locations</span>
        <span class="p">)</span>  <span class="c1">#: values independent of workplanes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">planes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Plane</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_locations</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">WorkplaneList</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Workplane Context</span>

<span class="sd">    A stateful context of active workplanes. At least one must be active</span>
<span class="sd">    at all time.</span>

<span class="sd">    Args:</span>
<span class="sd">        workplanes (sequence of Union[Face, Plane, Location]): objects to become planes</span>

<span class="sd">    Attributes:</span>
<span class="sd">        workplanes (list[Plane]): list of workplanes</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Context variable used to link to WorkplaneList instance</span>
    <span class="n">_current</span><span class="p">:</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">[</span><span class="n">WorkplaneList</span><span class="p">]</span> <span class="o">=</span> <span class="n">contextvars</span><span class="o">.</span><span class="n">ContextVar</span><span class="p">(</span>
        <span class="s2">&quot;WorkplaneList._current&quot;</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">workplanes</span><span class="p">:</span> <span class="n">Face</span> <span class="o">|</span> <span class="n">Plane</span> <span class="o">|</span> <span class="n">Location</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_convert_to_planes</span><span class="p">(</span><span class="n">workplanes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locations_context</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_planes</span><span class="p">(</span><span class="n">objs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Face</span> <span class="o">|</span> <span class="n">Plane</span> <span class="o">|</span> <span class="n">Location</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Plane</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate objects to planes&quot;&quot;&quot;</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="n">flatten_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">objs</span><span class="p">)</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Plane</span><span class="p">):</span>
                <span class="n">planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">Location</span><span class="p">,</span> <span class="n">Face</span><span class="p">)):</span>
                <span class="n">planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Plane</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WorkplaneList does not accept </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">planes</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon entering create a token to restore contextvars&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is pushing </span><span class="si">%d</span><span class="s2"> workplanes: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locations_context</span> <span class="o">=</span> <span class="n">LocationList</span><span class="p">([</span><span class="n">Location</span><span class="p">(</span><span class="n">Vector</span><span class="p">())])</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Upon exiting restore context&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reset_tok</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locations_context</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is popping </span><span class="si">%d</span><span class="s2"> workplanes&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize to beginning&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;While not through all the workplanes, return the next one&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workplanes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_context</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the instance of the current ContextList&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_current</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">localize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span> <span class="o">...</span>  <span class="c1"># type: ignore[overload-overlap]</span>

    <span class="nd">@overload</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">localize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">points</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Vector</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@classmethod</span>  <span class="c1"># type: ignore[misc]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">localize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">points</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Localize a sequence of points to the active workplane</span>
<span class="sd">        (only used by BuildLine where there is only one active workplane)</span>

<span class="sd">        The return value is conditional:</span>
<span class="sd">        - 1 point -&gt; Vector</span>
<span class="sd">        - &gt;1 points -&gt; list[Vector]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points_per_workplane</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points_per_workplane</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">workplane</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">workplanes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">localized_pts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">workplane</span><span class="o">.</span><span class="n">from_local_coords</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">pt</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">Vector</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">points</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localized_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">points_per_workplane</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localized_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">points_per_workplane</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">localized_pts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_per_workplane</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points_per_workplane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">points_per_workplane</span>


<span class="c1"># Type variable representing the return type of the wrapped function</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T2&quot;</span><span class="p">)</span>
<span class="n">T2_covar</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T2_covar&quot;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ContextComponentGetter</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T2_covar</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T2_covar</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">__gen_context_component_getter</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Builder</span><span class="p">,</span> <span class="n">Select</span><span class="p">],</span> <span class="n">T2</span><span class="p">],</span>
    <span class="c1"># ) -&gt; ContextComponentGetter[T2]:</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Select</span><span class="p">],</span> <span class="n">T2</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps a Builder method to automatically provide the Builder context.</span>

<span class="sd">    This function creates a wrapper around the provided Builder method (`func`) that</span>
<span class="sd">    automatically retrieves the current Builder context and passes it as the first</span>
<span class="sd">    argument to the method. This allows the method to be called without explicitly</span>
<span class="sd">    providing the Builder context.</span>

<span class="sd">    Args:</span>
<span class="sd">        func (Callable[[Builder, Select], T2]): The Builder method to be wrapped.</span>
<span class="sd">            - The method must take a `Builder` instance as its first argument and</span>
<span class="sd">              a `Select` instance as its second argument.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ContextComponentGetter[T2]: A callable that takes only a `Select` argument and</span>
<span class="sd">        internally retrieves the Builder context to call the original method.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If no Builder context is available when the returned function</span>
<span class="sd">        is called.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">getter</span><span class="p">(</span><span class="n">select</span><span class="p">:</span> <span class="n">Select</span> <span class="o">=</span> <span class="n">Select</span><span class="o">.</span><span class="n">ALL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T2</span><span class="p">:</span>
        <span class="c1"># Retrieve the current Builder context based on the method name</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">_get_context</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() requires a Builder context to be in scope&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Call the original method with the retrieved context and provided select</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">select</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">getter</span>


<span class="c1"># The following functions are used to get the shapes from the builder in context</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="n">wires</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
<span class="n">faces</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
<span class="n">solids</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">solids</span><span class="p">)</span>

<span class="n">vertex</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">vertex</span><span class="p">)</span>
<span class="n">edge</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
<span class="n">wire</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">wire</span><span class="p">)</span>
<span class="n">face</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">face</span><span class="p">)</span>
<span class="n">solid</span> <span class="o">=</span> <span class="n">__gen_context_component_getter</span><span class="p">(</span><span class="n">Builder</span><span class="o">.</span><span class="n">solid</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># To avoid import loops, Vector add &amp; sub are monkey-patched</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_vector_add_sub_wrapper</span><span class="p">(</span><span class="n">original_op</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Vector</span><span class="p">,</span> <span class="n">VectorLike</span><span class="p">],</span> <span class="n">Vector</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="n">VectorLike</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Relative adds must take into consideration planes with non-zero origins</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">_get_context</span><span class="p">()</span><span class="o">.</span><span class="n">workplanes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">origin</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">WorkplaneList</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">origin</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># raised from `WorkplaneList._get_context().workplanes[0]` when context is `None`</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">original_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;monkey-patching `Vector.add` and `Vector.sub`&quot;</span><span class="p">)</span>
<span class="n">Vector</span><span class="o">.</span><span class="n">add</span> <span class="o">=</span> <span class="n">_vector_add_sub_wrapper</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="n">Vector</span><span class="o">.</span><span class="n">sub</span> <span class="o">=</span> <span class="n">_vector_add_sub_wrapper</span><span class="p">(</span><span class="n">Vector</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Gumyr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>